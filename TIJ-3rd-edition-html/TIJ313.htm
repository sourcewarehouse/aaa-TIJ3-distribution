<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en">
<!--
This document was converted from RTF source: 
By r2net 5.8 r2netcmd Windows 
See http://www.logictran.com
-->
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Thinking in Java, 3rd ed. Revision 4.0: 11: Collections of  Objects</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css"></head>

<body >
   <CENTER>     <a href="http://www.MindView.net">     <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>     <Font FACE="Verdana, Tahoma, Arial, Helvetica, Sans">     <h2>Thinking in Java, 3<sup>rd</sup> ed. Revision 4.0</h2>     <FONT size = "-1"><br>     [ <a href="README.txt">Viewing Hints</a> ]     [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]     [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>     [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]     [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]     [ <a href="http://www.mindview.net/Services">Consulting</a> ] <br><br>     </FONT></FONT>   </CENTER> 
<font face="Georgia"><div align="CENTER"><a href="TIJ312.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ314.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>
<hr>

<h1>
<a name="_Toc24272650"></a><a name="_Toc24775733"></a><a name="Heading10173"></a>11:
Collections of <br>Objects</h1>
<p class="Intro">It&#146;s a fairly simple program that has only a fixed quantity of objects with known lifetimes.<br></p>
<p>In general, your programs will always be creating new objects based on some criteria that will be known only at the time the program is running. You won&#146;t know until run time the quantity or even the exact type of the objects you need. To solve the general programming problem, you need to be able to create any number of objects, anytime, anywhere. So you can&#146;t rely on creating a named reference to hold each one of your objects:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MyObject myReference;</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>since you&#146;ll never know how many of these you&#146;ll actually need. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1248" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Most languages provide some way to solve this rather essential problem. Java has several ways to hold objects (or rather, references to objects). The built-in type is the array, which has been discussed before. Also, the Java utilities library has a reasonably complete set of <a name="Index955"></a><i>container classes</i> (also known as <a name="Index956"></a><i>collection</i> <i>classes</i>, but because the Java 2 libraries use the name <b>Collection</b> to refer to a particular subset of the library, I shall also use the more inclusive term &#147;container&#148;). Containers provide sophisticated ways to hold and even manipulate your objects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1249" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545347"></a><a name="_Toc24775734"></a><a name="Heading10180"></a>Arrays</h2>
<p>Most of the necessary introduction to arrays is in the last section of Chapter 4, which showed how you define and initialize an array. Holding objects is the focus of this chapter, and an array is just one way to hold objects. But there are a number of other ways to hold objects, so what makes an array special? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1250" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index957"></a>There are three issues that distinguish arrays from other types of containers: efficiency, type, and the ability to hold primitives. The array is the most efficient way that Java provides to store and randomly access a sequence of object references. The array is a simple linear sequence, which makes element access fast, but you pay for this speed; when you create an array object, its size is fixed and cannot be changed for the lifetime of that array object. You might suggest creating an array of a particular size and then, if you run out of space, creating a new one and moving all the references from the old one to the new one. This is the behavior of the <a name="Index958"></a><a name="Index959"></a><b>ArrayList </b>class, which will be studied later in this chapter. However, because of the overhead of this flexibility, an <b>ArrayList</b> is measurably less efficient than an array. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1251" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In C++, the <a name="Index960"></a><b>vector</b> container class <i>does</i> know the type of objects it holds, but it has a different drawback when compared with arrays in Java: The C++ <b>vector</b>&#146;s <b>operator[]</b> doesn&#146;t do bounds checking, so you can run past the end.<sup><a name="fnB51" href="#fn51">[51]</a></sup> In Java, you get bounds checking regardless of whether you&#146;re using an array or a container; you&#146;ll get a <a name="Index961"></a><b>RuntimeException</b> if you exceed the bounds. This type of exception indicates a programmer error, and thus you don&#146;t need to check for it in your code. As an aside, the reason the C++ <b>vector</b> doesn&#146;t check bounds with every access is speed; in Java, you have the constant performance overhead of bounds checking all the time for both arrays and containers. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1252" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The other generic container classes that will be studied in this chapter, <a name="Index962"></a><b>List</b>, <a name="Index963"></a><b>Set</b>, and <a name="Index964"></a><b>Map</b>, all deal with objects as if they had no specific type. That is, they treat them as type <a name="Index965"></a><b>Object</b>, the root class of all classes in Java. This works fine from one standpoint: You need to build only one container, and any Java object will go into that container. (Except for primitives, which can be placed in containers as constants using the Java primitive wrapper classes, or as changeable values by wrapping in your own class.) This is the second place where an array is superior to the generic containers: When you create an array, you create it to hold a specific type (which is related to the third factor&#151;an array can hold primitives, whereas a container cannot). This means that you get compile-time type checking to prevent you from inserting the wrong type or mistaking the type that you&#146;re extracting. Of course, Java will prevent you from sending an inappropriate message to an object at either compile time or run time. So it&#146;s not riskier one way or the other, it&#146;s just nicer if the compiler points it out to you, faster at run time, and there&#146;s less likelihood that the end user will get surprised by an exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1253" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>For efficiency and type checking, it&#146;s always worth trying to use an array. However, when you&#146;re solving a more general problem, arrays can be too restrictive. After looking at arrays, the rest of this chapter will be devoted to the container classes provided by Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1254" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545348"></a><a name="_Toc24775735"></a><a name="Heading10187"></a>Arrays
are first-class objects<br></h3>
<p><a name="Index966"></a><a name="Index967"></a>Regardless of what type of array you&#146;re working with, the array identifier is actually a reference to a true object that&#146;s created on the heap. This is the object that holds the references to the other objects, and it can be created either implicitly, as part of the array initialization syntax, or explicitly with a <b>new</b> expression. Part of the array object (in fact, the only field or method you can access) is the read-only <b>length</b> member that tells you how many elements can be stored in that array object. <a name="Index968"></a><a name="Index969"></a>The &#145;<b>[]</b>&#146; syntax is the only other access that you have to the array object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1255" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The following example shows the various ways that an array can be initialized, and how the array references can be assigned to different array objects. It also shows that arrays of objects and arrays of primitives are almost identical in their use. The only difference is that arrays of objects hold references, but arrays of primitives hold the primitive values directly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1256" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ArraySize.java</font>
<font color=#009900>// Initialization &amp; re-assignment of arrays.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> Weeble {} <font color=#009900>// A small mythical creature</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArraySize {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Arrays of objects:</font>
    Weeble[] a; <font color=#009900>// Local uninitialized variable</font>
    Weeble[] b = <font color=#0000ff>new</font> Weeble[5]; <font color=#009900>// Null references</font>
    Weeble[] c = <font color=#0000ff>new</font> Weeble[4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; c.length; i++)
      <font color=#0000ff>if</font>(c[i] == <font color=#0000ff>null</font>) <font color=#009900>// Can test for null reference</font>
        c[i] = <font color=#0000ff>new</font> Weeble();
    <font color=#009900>// Aggregate initialization:</font>
    Weeble[] d = {
      <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble()
    };
    <font color=#009900>// Dynamic aggregate initialization:</font>
    a = <font color=#0000ff>new</font> Weeble[] {
      <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble()
    };
    System.out.println(<font color=#004488>"a.length="</font> + a.length);
    System.out.println(<font color=#004488>"b.length = "</font> + b.length);
    <font color=#009900>// The references inside the array are</font>
    <font color=#009900>// automatically initialized to null:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; b.length; i++)
      System.out.println(<font color=#004488>"b["</font> + i + <font color=#004488>"]="</font> + b[i]);
    System.out.println(<font color=#004488>"c.length = "</font> + c.length);
    System.out.println(<font color=#004488>"d.length = "</font> + d.length);
    a = d;
    System.out.println(<font color=#004488>"a.length = "</font> + a.length);

    <font color=#009900>// Arrays of primitives:</font>
    <font color=#0000ff>int</font>[] e; <font color=#009900>// Null reference</font>
    <font color=#0000ff>int</font>[] f = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[5];
    <font color=#0000ff>int</font>[] g = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; g.length; i++)
      g[i] = i*i;
    <font color=#0000ff>int</font>[] h = { 11, 47, 93 };
    <font color=#009900>// Compile error: variable e not initialized:</font>
    <font color=#009900>//!System.out.println("e.length=" + e.length);</font>
    System.out.println(<font color=#004488>"f.length = "</font> + f.length);
    <font color=#009900>// The primitives inside the array are</font>
    <font color=#009900>// automatically initialized to zero:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; f.length; i++)
      System.out.println(<font color=#004488>"f["</font> + i + <font color=#004488>"]="</font> + f[i]);
    System.out.println(<font color=#004488>"g.length = "</font> + g.length);
    System.out.println(<font color=#004488>"h.length = "</font> + h.length);
    e = h;
    System.out.println(<font color=#004488>"e.length = "</font> + e.length);
    e = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[] { 1, 2 };
    System.out.println(<font color=#004488>"e.length = "</font> + e.length);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"a.length=2"</font>,
      <font color=#004488>"b.length = 5"</font>,
      <font color=#004488>"b[0]=null"</font>,
      <font color=#004488>"b[1]=null"</font>,
      <font color=#004488>"b[2]=null"</font>,
      <font color=#004488>"b[3]=null"</font>,
      <font color=#004488>"b[4]=null"</font>,
      <font color=#004488>"c.length = 4"</font>,
      <font color=#004488>"d.length = 3"</font>,
      <font color=#004488>"a.length = 3"</font>,
      <font color=#004488>"f.length = 5"</font>,
      <font color=#004488>"f[0]=0"</font>,
      <font color=#004488>"f[1]=0"</font>,
      <font color=#004488>"f[2]=0"</font>,
      <font color=#004488>"f[3]=0"</font>,
      <font color=#004488>"f[4]=0"</font>,
      <font color=#004488>"g.length = 4"</font>,
      <font color=#004488>"h.length = 3"</font>,
      <font color=#004488>"e.length = 3"</font>,
      <font color=#004488>"e.length = 2"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The array <b>a</b> is an uninitialized local variable, and the compiler prevents you from doing anything with this reference until you&#146;ve properly initialized it. The array <b>b</b> is initialized to point to an array of <b>Weeble</b> references, but no actual <b>Weeble</b> objects are ever placed in that array. However, you can still ask what the size of the array is, since <b>b</b> is pointing to a legitimate object. This brings up a slight drawback: You can&#146;t find out how many elements are actually <i>in</i> the array, since <b>length</b> tells you only how many elements <i>can</i> be placed in the array; that is, the size of the array object, not the number of elements it actually holds. However, when an array object is created, its references are automatically initialized to <b>null</b>, so you can see whether a particular array slot has an object in it by checking to see whether it&#146;s <b>null</b>. Similarly, an array of primitives is automatically initialized to zero for numeric types, <b>(char)0 </b>for <b>char</b>, and<b> false</b> for <b>boolean</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1257" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Array <b>c</b> shows the creation of the array object followed by the assignment of <b>Weeble</b> objects to all the slots in the array. Array <b>d</b> shows the &#147;aggregate initialization&#148; syntax that causes the array object to be created (implicitly with <b>new</b> on the heap, just like for array <b>c</b>) <i>and</i> initialized with <b>Weeble</b> objects, all in one statement. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1258" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index972"></a><a name="Index973"></a>The next array initialization could be thought of as a &#147;dynamic aggregate initialization.&#148; The aggregate initialization used by <b>d</b> must be used at the point of <b>d</b>&#146;s definition, but with the second syntax you can create and initialize an array object anywhere. For example, suppose <b>hide(&#160;)</b> is a method that takes an array of <b>Weeble</b> objects. You could call it by saying:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>hide(d);</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>but you can also dynamically create the array you want to pass as the argument:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>hide(<font color=#0000ff>new</font> Weeble[] { <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble() });</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In many situations this syntax provides a more convenient way to write code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1259" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The expression:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a = d;</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>shows how you can take a reference that&#146;s attached to one array object and assign it to another array object, just as you can do with any other type of object reference. Now both <b>a</b> and <b>d</b> are pointing to the same array object on the heap. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1260" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The second part of <b>ArraySize.java</b> shows that primitive arrays work just like object arrays <i>except</i> that primitive arrays hold the primitive values directly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1261" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="_Toc375545349"></a><a name="Heading10284"></a>Containers of
primitives<br></h4>
<p><a name="Index974"></a><a name="Index975"></a>Container classes can hold only references to <b>Object</b>s. An array, however, can be created to hold primitives directly, as well as references to <b>Object</b>s. It <i>is</i> possible to use the &#147;wrapper&#148; classes, such as <b>Integer</b>, <b>Double</b>, etc., to place primitive values inside a container, but the wrapper classes for primitives can be awkward to use. In addition, it&#146;s much more efficient to create and access an array of primitives than a container of wrapped primitives. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1262" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Of course, if you&#146;re using a primitive type and you need the flexibility of a container that automatically expands when more space is needed, the array won&#146;t work, and you&#146;re forced to use a container of wrapped primitives. You might think that there should be a specialized type of <b>ArrayList</b> for each of the primitive data types, but Java doesn&#146;t provide this for you.<sup><a name="fnB52" href="#fn52">[52]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1263" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775736"></a><a name="Heading10288"></a>Returning an array</h3>
<p>Suppose you&#146;re writing a method and you don&#146;t just want to return just one thing, but a whole bunch of things. Languages like C and C++ make this difficult because you can&#146;t just return an array, only a pointer to an array. This introduces problems because it becomes messy to control the lifetime of the array, which easily leads to memory leaks. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1264" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index976"></a><a name="Index977"></a>Java takes a similar approach, but you just &#147;return an array.&#148; Unlike C++, with Java you never worry about responsibility for that array&#151;it will be around as long as you need it, and the garbage collector will clean it up when you&#146;re done. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1265" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As an example, consider returning an array of <b>String</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:IceCream.java</font>
<font color=#009900>// Returning arrays from methods.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IceCream {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random rand = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> String[] flavors = {
    <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>, <font color=#004488>"Vanilla Fudge Swirl"</font>,
    <font color=#004488>"Mint Chip"</font>, <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>,
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font>
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String[] flavorSet(<font color=#0000ff>int</font> n) {
    String[] results = <font color=#0000ff>new</font> String[n];
    <font color=#0000ff>boolean</font>[] picked = <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[flavors.length];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; n; i++) {
      <font color=#0000ff>int</font> t;
      <font color=#0000ff>do</font>
        t = rand.nextInt(flavors.length);
      <font color=#0000ff>while</font>(picked[t]);
      results[i] = flavors[t];
      picked[t] = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>return</font> results;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 20; i++) {
      System.out.println(
        <font color=#004488>"flavorSet("</font> + i + <font color=#004488>") = "</font>);
      String[] fl = flavorSet(flavors.length);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; fl.length; j++)
        System.out.println(<font color=#004488>"\t"</font> + fl[j]);
      monitor.expect(<font color=#0000ff>new</font> Object[] {
        <font color=#004488>"%% flavorSet\\(\\d+\\) = "</font>,
        <font color=#0000ff>new</font> TestExpression(<font color=#004488>"%% \\t(Chocolate|Strawberry|"</font>
          + <font color=#004488>"Vanilla Fudge Swirl|Mint Chip|Mocha Almond "</font>
          + <font color=#004488>"Fudge|Rum Raisin|Praline Cream|Mud Pie)"</font>, 8)
      });
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The method <b>flavorSet(&#160;)</b> creates an array of <b>String</b> called <b>results</b>. The size of this array is <b>n</b>, determined by the argument that you pass into the method. Then it proceeds to choose flavors randomly from the array <b>flavors</b> and place them into <b>results</b>, which it finally returns. Returning an array is just like returning any other object&#151;it&#146;s a reference. It&#146;s not important that the array was created within <b>flavorSet(&#160;)</b>, or that the array was created anyplace else, for that matter. The garbage collector takes care of cleaning up the array when you&#146;re done with it, and the array will persist for as long as you need it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1266" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As an aside, notice that when <b>flavorSet(&#160;)</b> chooses flavors randomly, it ensures that a particular choice hasn&#146;t already been selected. This is performed in a <b>do</b> loop that keeps making random choices until it finds one not already in the <b>picked</b> array. (Of course, a <b>String</b> comparison also could have been performed to see if the random choice was already in the <b>results</b> array.) If it&#146;s successful, it adds the entry and finds the next one (<b>i </b>gets incremented). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1267" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>main(&#160;)</b> prints out 20 full sets of flavors, so you can see that <b>flavorSet(&#160;)</b> chooses the flavors in a random order each time. It&#146;s easiest to see this if you redirect the output into a file. And while you&#146;re looking at the file, remember that you just <i>want</i> the ice cream, you don&#146;t <i>need</i> it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1268" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775737"></a><a name="Heading10338"></a>The <b>Arrays</b>
class</h3>
<p>In <b>java.util</b>, you&#146;ll find the <a name="Index978"></a><b>Arrays</b> class, which holds a set of <b>static</b> methods that perform utility functions for arrays. There are four basic methods: <b>equals(&#160;)</b>, to compare two arrays for equality; <b>fill(&#160;)</b>, to fill an array with a value; <b>sort(&#160;)</b>, to sort the array; and <b>binarySearch(&#160;)</b>, to find an element in a sorted array. All of these methods are overloaded for all the primitive types and <b>Object</b>s. In addition, there&#146;s a single <b>asList(&#160;)</b> method that takes any array and turns it into a <b>List</b> container, which you&#146;ll learn about later in this chapter. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1269" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Although useful, the <b>Arrays</b> class stops short of being fully functional. For example, it would be nice to be able to easily print the elements of an array without having to code a <b>for</b> loop by hand every time. And as you&#146;ll see, the <b>fill(&#160;)</b> method only takes a single value and places it in the array, so if you wanted, for example, to fill an array with randomly generated numbers, <b>fill(&#160;)</b> is no help. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1270" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Thus it makes sense to supplement the <b>Arrays</b> class with some additional utilities, which will be placed in the <b>package</b> <b>com.bruceeckel.util</b> for convenience. These will print an array of any type and fill an array with values or objects that are created by an object called a <i>generator</i> that you can define. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1271" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index979"></a>Because code needs to be created for each primitive type as well as <b>Object</b>, there&#146;s a lot of nearly duplicated code.<sup><a name="fnB53" href="#fn53">[53]</a></sup> For example, a &#147;generator&#148; interface is required for each type because the return type of <b>next(&#160;)</b> must be different in each case: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0125" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Generator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> Generator { Object next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:BooleanGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> BooleanGenerator { <font color=#0000ff>boolean</font> next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:ByteGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> ByteGenerator { <font color=#0000ff>byte</font> next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:CharGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> CharGenerator { <font color=#0000ff>char</font> next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:ShortGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> ShortGenerator { <font color=#0000ff>short</font> next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:IntGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> IntGenerator { <font color=#0000ff>int</font> next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:LongGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> LongGenerator { <font color=#0000ff>long</font> next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:FloatGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> FloatGenerator { <font color=#0000ff>float</font> next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:DoubleGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> DoubleGenerator { <font color=#0000ff>double</font> next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><a name="Index980"></a><b>Arrays2</b> contains a variety of <b>toString(&#160;)</b> methods, overloaded for each type. These methods allow you to easily print an array. The <b>toString(&#160;)</b> code introduces the use of <b>StringBuffer</b> instead of <b>String</b> objects. This is a nod to efficiency; when you&#146;re assembling a string in a method that might be called a lot, it&#146;s wiser to use the more efficient <b>StringBuffer</b> rather than the more convenient <b>String</b> operations. Here, the <b>StringBuffer</b> is created with an initial value, and <b>Strings</b> are appended. Finally, the <b>result</b> is converted to a <b>String</b> as the return value: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0126" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Arrays2.java</font>
<font color=#009900>// A supplement to java.util.Arrays, to provide additional</font>
<font color=#009900>// useful functionality when working with arrays. Allows</font>
<font color=#009900>// any array to be converted to a String, and to be filled</font>
<font color=#009900>// via a user-defined "generator" object.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Arrays2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(<font color=#0000ff>boolean</font>[] a) {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"["</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      result.append(a[i]);
      <font color=#0000ff>if</font>(i &lt; a.length - 1)
        result.append(<font color=#004488>", "</font>);
    }
    result.append(<font color=#004488>"]"</font>);
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(<font color=#0000ff>byte</font>[] a) {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"["</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      result.append(a[i]);
      <font color=#0000ff>if</font>(i &lt; a.length - 1)
        result.append(<font color=#004488>", "</font>);
    }
    result.append(<font color=#004488>"]"</font>);
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(<font color=#0000ff>char</font>[] a) {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"["</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      result.append(a[i]);
      <font color=#0000ff>if</font>(i &lt; a.length - 1)
        result.append(<font color=#004488>", "</font>);
    }
    result.append(<font color=#004488>"]"</font>);
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(<font color=#0000ff>short</font>[] a) {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"["</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      result.append(a[i]);
      <font color=#0000ff>if</font>(i &lt; a.length - 1)
        result.append(<font color=#004488>", "</font>);
    }
    result.append(<font color=#004488>"]"</font>);
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(<font color=#0000ff>int</font>[] a) {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"["</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      result.append(a[i]);
      <font color=#0000ff>if</font>(i &lt; a.length - 1)
        result.append(<font color=#004488>", "</font>);
    }
    result.append(<font color=#004488>"]"</font>);
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(<font color=#0000ff>long</font>[] a) {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"["</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      result.append(a[i]);
      <font color=#0000ff>if</font>(i &lt; a.length - 1)
        result.append(<font color=#004488>", "</font>);
    }
    result.append(<font color=#004488>"]"</font>);
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(<font color=#0000ff>float</font>[] a) {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"["</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      result.append(a[i]);
      <font color=#0000ff>if</font>(i &lt; a.length - 1)
        result.append(<font color=#004488>", "</font>);
    }
    result.append(<font color=#004488>"]"</font>);
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String toString(<font color=#0000ff>double</font>[] a) {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"["</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.length; i++) {
      result.append(a[i]);
      <font color=#0000ff>if</font>(i &lt; a.length - 1)
        result.append(<font color=#004488>", "</font>);
    }
    result.append(<font color=#004488>"]"</font>);
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#009900>// Fill an array using a generator:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(Object[] a, Generator gen) {
    fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(Object[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, Generator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>boolean</font>[] a, BooleanGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>boolean</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to,BooleanGenerator gen){
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(<font color=#0000ff>byte</font>[] a, ByteGenerator gen) {
    fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>byte</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, ByteGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(<font color=#0000ff>char</font>[] a, CharGenerator gen) {
    fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>char</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, CharGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(<font color=#0000ff>short</font>[] a, ShortGenerator gen) {
    fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>short</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, ShortGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(<font color=#0000ff>int</font>[] a, IntGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>int</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, IntGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(<font color=#0000ff>long</font>[] a, LongGenerator gen) {
    fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>long</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, LongGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(<font color=#0000ff>float</font>[] a, FloatGenerator gen) {
    fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>float</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, FloatGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(<font color=#0000ff>double</font>[] a, DoubleGenerator gen){
    fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(<font color=#0000ff>double</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, DoubleGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandBooleanGenerator <font color=#0000ff>implements</font> BooleanGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> next() { <font color=#0000ff>return</font> r.nextBoolean(); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandByteGenerator <font color=#0000ff>implements</font> ByteGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>byte</font> next() { <font color=#0000ff>return</font> (<font color=#0000ff>byte</font>)r.nextInt(); }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> String ssource =
    <font color=#004488>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>char</font>[] src = ssource.toCharArray();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandCharGenerator <font color=#0000ff>implements</font> CharGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>char</font> next() {
      <font color=#0000ff>return</font> src[r.nextInt(src.length)];
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandStringGenerator <font color=#0000ff>implements</font> Generator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> len;
    <font color=#0000ff>private</font> RandCharGenerator cg = <font color=#0000ff>new</font> RandCharGenerator();
    <font color=#0000ff>public</font> RandStringGenerator(<font color=#0000ff>int</font> length) {
      len = length;
    }
    <font color=#0000ff>public</font> Object next() {
      <font color=#0000ff>char</font>[] buf = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[len];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; len; i++)
        buf[i] = cg.next();
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> String(buf);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandShortGenerator <font color=#0000ff>implements</font> ShortGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>short</font> next() { <font color=#0000ff>return</font> (<font color=#0000ff>short</font>)r.nextInt(); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandIntGenerator <font color=#0000ff>implements</font> IntGenerator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> mod = 10000;
    <font color=#0000ff>public</font> RandIntGenerator() {}
    <font color=#0000ff>public</font> RandIntGenerator(<font color=#0000ff>int</font> modulo) { mod = modulo; }
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> next() { <font color=#0000ff>return</font> r.nextInt(mod); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandLongGenerator <font color=#0000ff>implements</font> LongGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>long</font> next() { <font color=#0000ff>return</font> r.nextLong(); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandFloatGenerator <font color=#0000ff>implements</font> FloatGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>float</font> next() { <font color=#0000ff>return</font> r.nextFloat(); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandDoubleGenerator <font color=#0000ff>implements</font> DoubleGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>double</font> next() {<font color=#0000ff>return</font> r.nextDouble();}
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>To fill an array of elements using a generator, the <b>fill(&#160;)</b> method takes a reference to an appropriate generator <b>interface</b>, which has a <b>next(&#160;)</b> method that will somehow produce an object of the right type (depending on how the interface is implemented). The <b>fill(&#160;)</b> method simply calls <b>next(&#160;)</b> until the desired range has been filled. Now you can create any generator by implementing the appropriate <b>interface</b> and use your generator with <b>fill(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1272" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Random data generators are useful for testing, so a set of inner classes is created to implement all the primitive generator interfaces, as well as a <b>String</b> generator to represent <b>Object</b>. You can see that <b>RandStringGenerator</b> uses <b>RandCharGenerator</b> to fill an array of characters, which is then turned into a <b>String</b>. The size of the array is determined by the constructor argument. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1273" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To generate numbers that aren&#146;t too large, <b>RandIntGenerator</b> defaults to a modulus of 10,000, but the overloaded constructor allows you to choose a smaller value. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1274" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s a program to test the library and demonstrate how it is used:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:TestArrays2.java</font>
<font color=#009900>// Test and demonstrate Arrays2 utilities.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestArrays2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 6;
    <font color=#009900>// Or get the size from the command line:</font>
    <font color=#0000ff>if</font>(args.length != 0) {
      size = Integer.parseInt(args[0]);
      <font color=#0000ff>if</font>(size &lt; 3) {
        System.out.println(<font color=#004488>"arg must be &gt;= 3"</font>);
        System.exit(1);
      }
    }
    <font color=#0000ff>boolean</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[size];
    <font color=#0000ff>byte</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[size];
    <font color=#0000ff>char</font>[] a3 = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[size];
    <font color=#0000ff>short</font>[] a4 = <font color=#0000ff>new</font> <font color=#0000ff>short</font>[size];
    <font color=#0000ff>int</font>[] a5 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[size];
    <font color=#0000ff>long</font>[] a6 = <font color=#0000ff>new</font> <font color=#0000ff>long</font>[size];
    <font color=#0000ff>float</font>[] a7 = <font color=#0000ff>new</font> <font color=#0000ff>float</font>[size];
    <font color=#0000ff>double</font>[] a8 = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[size];
    Arrays2.fill(a1, <font color=#0000ff>new</font> Arrays2.RandBooleanGenerator());
    System.out.println(<font color=#004488>"a1 = "</font> + Arrays2.toString(a1));
    Arrays2.fill(a2, <font color=#0000ff>new</font> Arrays2.RandByteGenerator());
    System.out.println(<font color=#004488>"a2 = "</font> + Arrays2.toString(a2));
    Arrays2.fill(a3, <font color=#0000ff>new</font> Arrays2.RandCharGenerator());
    System.out.println(<font color=#004488>"a3 = "</font> + Arrays2.toString(a3));
    Arrays2.fill(a4, <font color=#0000ff>new</font> Arrays2.RandShortGenerator());
    System.out.println(<font color=#004488>"a4 = "</font> + Arrays2.toString(a4));
    Arrays2.fill(a5, <font color=#0000ff>new</font> Arrays2.RandIntGenerator());
    System.out.println(<font color=#004488>"a5 = "</font> + Arrays2.toString(a5));
    Arrays2.fill(a6, <font color=#0000ff>new</font> Arrays2.RandLongGenerator());
    System.out.println(<font color=#004488>"a6 = "</font> + Arrays2.toString(a6));
    Arrays2.fill(a7, <font color=#0000ff>new</font> Arrays2.RandFloatGenerator());
    System.out.println(<font color=#004488>"a7 = "</font> + Arrays2.toString(a7));
    Arrays2.fill(a8, <font color=#0000ff>new</font> Arrays2.RandDoubleGenerator());
    System.out.println(<font color=#004488>"a8 = "</font> + Arrays2.toString(a8));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>size</b> parameter has a default value, but you can also set it from the command line. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1275" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775738"></a><a name="Heading10648"></a>Filling an array</h3>
<p>The Java standard library <b>Arrays</b> also has a <b>fill(&#160;)</b> method, but that is rather trivial; it only duplicates a single value into each location, or in the case of objects, copies the same reference into each location. Using <b>Arrays2.toString(&#160;)</b>, the <a name="Index981"></a><b>Arrays.fill(&#160;)</b> methods can be easily demonstrated:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:FillingArrays.java</font>
<font color=#009900>// Using Arrays.fill()</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillingArrays {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 6;
    <font color=#009900>// Or get the size from the command line:</font>
    <font color=#0000ff>if</font>(args.length != 0)
      size = Integer.parseInt(args[0]);
    <font color=#0000ff>boolean</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[size];
    <font color=#0000ff>byte</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[size];
    <font color=#0000ff>char</font>[] a3 = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[size];
    <font color=#0000ff>short</font>[] a4 = <font color=#0000ff>new</font> <font color=#0000ff>short</font>[size];
    <font color=#0000ff>int</font>[] a5 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[size];
    <font color=#0000ff>long</font>[] a6 = <font color=#0000ff>new</font> <font color=#0000ff>long</font>[size];
    <font color=#0000ff>float</font>[] a7 = <font color=#0000ff>new</font> <font color=#0000ff>float</font>[size];
    <font color=#0000ff>double</font>[] a8 = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[size];
    String[] a9 = <font color=#0000ff>new</font> String[size];
    Arrays.fill(a1, <font color=#0000ff>true</font>);
    System.out.println(<font color=#004488>"a1 = "</font> + Arrays2.toString(a1));
    Arrays.fill(a2, (<font color=#0000ff>byte</font>)11);
    System.out.println(<font color=#004488>"a2 = "</font> + Arrays2.toString(a2));
    Arrays.fill(a3, 'x');
    System.out.println(<font color=#004488>"a3 = "</font> + Arrays2.toString(a3));
    Arrays.fill(a4, (<font color=#0000ff>short</font>)17);
    System.out.println(<font color=#004488>"a4 = "</font> + Arrays2.toString(a4));
    Arrays.fill(a5, 19);
    System.out.println(<font color=#004488>"a5 = "</font> + Arrays2.toString(a5));
    Arrays.fill(a6, 23);
    System.out.println(<font color=#004488>"a6 = "</font> + Arrays2.toString(a6));
    Arrays.fill(a7, 29);
    System.out.println(<font color=#004488>"a7 = "</font> + Arrays2.toString(a7));
    Arrays.fill(a8, 47);
    System.out.println(<font color=#004488>"a8 = "</font> + Arrays2.toString(a8));
    Arrays.fill(a9, <font color=#004488>"Hello"</font>);
    System.out.println(<font color=#004488>"a9 = "</font> + Arrays.asList(a9));
    <font color=#009900>// Manipulating ranges:</font>
    Arrays.fill(a9, 3, 5, <font color=#004488>"World"</font>);
    System.out.println(<font color=#004488>"a9 = "</font> + Arrays.asList(a9));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"a1 = [true, true, true, true, true, true]"</font>,
      <font color=#004488>"a2 = [11, 11, 11, 11, 11, 11]"</font>,
      <font color=#004488>"a3 = [x, x, x, x, x, x]"</font>,
      <font color=#004488>"a4 = [17, 17, 17, 17, 17, 17]"</font>,
      <font color=#004488>"a5 = [19, 19, 19, 19, 19, 19]"</font>,
      <font color=#004488>"a6 = [23, 23, 23, 23, 23, 23]"</font>,
      <font color=#004488>"a7 = [29.0, 29.0, 29.0, 29.0, 29.0, 29.0]"</font>,
      <font color=#004488>"a8 = [47.0, 47.0, 47.0, 47.0, 47.0, 47.0]"</font>,
      <font color=#004488>"a9 = [Hello, Hello, Hello, Hello, Hello, Hello]"</font>,
      <font color=#004488>"a9 = [Hello, Hello, Hello, World, World, Hello]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can either fill the entire array or, as the last two statements show, a range of elements. But since you can only provide a single value to use for filling using <b>Arrays.fill(&#160;)</b>, the <b>Arrays2.fill(&#160;)</b> methods produce much more interesting results. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1276" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775739"></a><a name="Heading10709"></a>Copying an array<br></h3>
<p><a name="Index982"></a><a name="Index983"></a>The Java standard library provides a <b>static </b>method, <b>System.arraycopy(&#160;)</b><a name="Index984"></a>, which can make much faster copies of an array than if you use a <b>for</b> loop to perform the copy by hand. <b>System.arraycopy(&#160;) </b>is overloaded to handle all types. Here&#146;s an example that manipulates arrays of <b>int</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:CopyingArrays.java</font>
<font color=#009900>// Using System.arraycopy()</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CopyingArrays {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] i = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[7];
    <font color=#0000ff>int</font>[] j = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    Arrays.fill(i, 47);
    Arrays.fill(j, 99);
    System.out.println(<font color=#004488>"i = "</font> + Arrays2.toString(i));
    System.out.println(<font color=#004488>"j = "</font> + Arrays2.toString(j));
    System.arraycopy(i, 0, j, 0, i.length);
    System.out.println(<font color=#004488>"j = "</font> + Arrays2.toString(j));
    <font color=#0000ff>int</font>[] k = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[5];
    Arrays.fill(k, 103);
    System.arraycopy(i, 0, k, 0, k.length);
    System.out.println(<font color=#004488>"k = "</font> + Arrays2.toString(k));
    Arrays.fill(k, 103);
    System.arraycopy(k, 0, i, 0, k.length);
    System.out.println(<font color=#004488>"i = "</font> + Arrays2.toString(i));
    <font color=#009900>// Objects:</font>
    Integer[] u = <font color=#0000ff>new</font> Integer[10];
    Integer[] v = <font color=#0000ff>new</font> Integer[5];
    Arrays.fill(u, <font color=#0000ff>new</font> Integer(47));
    Arrays.fill(v, <font color=#0000ff>new</font> Integer(99));
    System.out.println(<font color=#004488>"u = "</font> + Arrays.asList(u));
    System.out.println(<font color=#004488>"v = "</font> + Arrays.asList(v));
    System.arraycopy(v, 0, u, u.length/2, v.length);
    System.out.println(<font color=#004488>"u = "</font> + Arrays.asList(u));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"i = [47, 47, 47, 47, 47, 47, 47]"</font>,
      <font color=#004488>"j = [99, 99, 99, 99, 99, 99, 99, 99, 99, 99]"</font>,
      <font color=#004488>"j = [47, 47, 47, 47, 47, 47, 47, 99, 99, 99]"</font>,
      <font color=#004488>"k = [47, 47, 47, 47, 47]"</font>,
      <font color=#004488>"i = [103, 103, 103, 103, 103, 47, 47]"</font>,
      <font color=#004488>"u = [47, 47, 47, 47, 47, 47, 47, 47, 47, 47]"</font>,
      <font color=#004488>"v = [99, 99, 99, 99, 99]"</font>,
      <font color=#004488>"u = [47, 47, 47, 47, 47, 99, 99, 99, 99, 99]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The arguments to <b>arraycopy(&#160;)</b> are the source array, the offset into the source array from whence to start copying, the destination array, the offset into the destination array where the copying begins, and the number of elements to copy. Naturally, any violation of the array boundaries will cause an exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1277" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The example shows that both primitive arrays and object arrays can be copied. However, if you copy arrays of objects, then only the references get copied&#151;there&#146;s no duplication of the objects themselves. This is called a <i>shallow copy</i> (see Appendix A). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1278" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545350"></a><a name="_Toc24775740"></a><a name="Heading10759"></a>Comparing
arrays<br></h3>
<p><a name="Index985"></a><a name="Index986"></a><b>Arrays</b> provides the overloaded method <b>equals(&#160;)</b> to compare entire arrays for equality. Again, these are overloaded for all the primitives and for <b>Object</b>. To be equal, the arrays must have the same number of elements, and each element must be equivalent to each corresponding element in the other array, using the <b>equals(&#160;) </b>for each element. (For primitives, that primitive&#146;s wrapper class <b>equals(&#160;)</b> is used; for example, <b>Integer.equals(&#160;) </b>for <b>int</b>.)<b> </b>For example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ComparingArrays.java</font>
<font color=#009900>// Using Arrays.equals()</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ComparingArrays {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    <font color=#0000ff>int</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    Arrays.fill(a1, 47);
    Arrays.fill(a2, 47);
    System.out.println(Arrays.equals(a1, a2));
    a2[3] = 11;
    System.out.println(Arrays.equals(a1, a2));
    String[] s1 = <font color=#0000ff>new</font> String[5];
    Arrays.fill(s1, <font color=#004488>"Hi"</font>);
    String[] s2 = {<font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>};
    System.out.println(Arrays.equals(s1, s2));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"true"</font>,
      <font color=#004488>"false"</font>,
      <font color=#004488>"true"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Originally, <b>a1</b> and <b>a2</b> are exactly equal, so the output is &#147;true,&#148; but then one of the elements is changed, which makes the result &#147;false.&#148; In the last case, all the elements of <b>s1</b> point to the same object, but <b>s2</b> has five unique objects. However, array equality is based on contents (via <b>Object.equals(&#160;)</b>) , so the result is &#147;true.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1279" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775741"></a><a name="Heading10789"></a>Array element
comparisons<br></h3>
<p><a name="Index987"></a>One of the missing features in the Java 1.0 and 1.1 libraries was algorithmic operations&#151;even simple sorting. This was a rather confusing situation to someone expecting an adequate standard library. Fortunately, Java 2 remedied the situation, at least for the sorting problem. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1280" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index988"></a>A problem with writing generic sorting code is that sorting must perform comparisons based on the actual type of the object. Of course, one approach is to write a different sorting method for every different type, but you should be able to recognize that this does not produce code that is easily reused for new types. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1281" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A primary goal of programming design is to &#147;separate things that change from things that stay the same,&#148; and here, the code that stays the same is the general sort algorithm, but the thing that changes from one use to the next is the way objects are compared. So instead of placing the comparison code into many different sort routines, the technique of the <a name="Index989"></a><i>callback</i> is used. With a callback, the part of the code that varies from case to case is separated, and the part of the code that&#146;s always the same will call back to the code that changes. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1282" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Java has two ways to provide comparison functionality. The first is with the &#147;natural&#148; comparison method that is imparted to a class by implementing the <b>java.lang.Comparable</b> interface. This is a very simple interface with a single method, <a name="Index990"></a><b>compareTo(&#160;)</b>. This method takes another <b>Object</b> as an argument and produces a negative value if the current object is less than the argument, zero if the argument is equal, and a positive value if the current object is greater than the argument . <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1283" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s a class that implements <a name="Index991"></a><b>Comparable</b> and demonstrates the comparability by using the Java standard library method <b>Arrays.sort(&#160;)</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:CompType.java</font>
<font color=#009900>// Implementing Comparable in a class.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CompType <font color=#0000ff>implements</font> Comparable {
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>int</font> j;
  <font color=#0000ff>public</font> CompType(<font color=#0000ff>int</font> n1, <font color=#0000ff>int</font> n2) {
    i = n1;
    j = n2;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"[i = "</font> + i + <font color=#004488>", j = "</font> + j + <font color=#004488>"]"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object rv) {
    <font color=#0000ff>int</font> rvi = ((CompType)rv).i;
    <font color=#0000ff>return</font> (i &lt; rvi ? -1 : (i == rvi ? 0 : 1));
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Generator generator() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Generator() {
      <font color=#0000ff>public</font> Object next() {
        <font color=#0000ff>return</font> <font color=#0000ff>new</font> CompType(r.nextInt(100),r.nextInt(100));
      }
    };
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, generator());
    System.out.println(
      <font color=#004488>"before sorting, a = "</font> + Arrays.asList(a));
    Arrays.sort(a);
    System.out.println(
      <font color=#004488>"after sorting, a = "</font> + Arrays.asList(a));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>When you define the comparison method, you are responsible for deciding what it means to compare one of your objects to another. Here, only the <b>i</b> values are used in the comparison, and the <b>j</b> values are ignored. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1284" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>static randInt(&#160;)</b> method produces positive values between zero and 100, and the <b>generator(&#160;)</b> method produces an object that implements the <b>Generator</b> interface by creating an anonymous inner class (see Chapter 8). This builds <b>CompType</b> objects by initializing them with random values. In <b>main(&#160;)</b>, the generator is used to fill an array of <b>CompType</b>, which is then sorted. If <b>Comparable</b> hadn&#146;t been implemented, then you&#146;d get a <b>ClassCastException</b> at run time when you tried to call <b>sort(&#160;)</b>. This is because <b>sort(&#160;)</b> casts its argument to <b>Comparable</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1285" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Now suppose someone hands you a class that doesn&#146;t implement <b>Comparable</b>, or hands you this class that <i>does</i> implement <b>Comparable</b>, but you decide you don&#146;t like the way it works and would rather have a different comparison method for the type. The solution is in contrast to hard-wiring the comparison code into each different object. Instead, the <a name="Index992"></a><i>strategy</i> design pattern<sup><a name="fnB54" href="#fn54">[54]</a></sup> is used. With a strategy, the part of the code that varies is encapsulated inside its own class (the strategy object). You hand a strategy object to the code that&#146;s always the same, which uses the strategy to fulfill its algorithm. That way, you can make different objects to express different ways of comparison and feed them to the same sorting code. Here, you create a strategy by defining a separate class that implements an interface called <a name="Index993"></a><b>Comparator</b>. This has two methods, <b>compare(&#160;)</b> and <b>equals(&#160;)</b>. However, you don&#146;t have to implement <b>equals(&#160;)</b> except for special performance needs, because anytime you create a class, it is implicitly inherited from <b>Object</b>, which has an <b>equals(&#160;)</b>. So you can just use the default <b>Object</b> <b>equals(&#160;)</b> and satisfy the contract imposed by the interface. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1286" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>Collections</b> class (which we&#146;ll look at more later) contains a single <b>Comparator</b> that reverses the natural sorting order. This can be applied easily to the <b>CompType</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1287" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Reverse.java</font>
<font color=#009900>// The Collecions.reverseOrder() Comparator</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Reverse {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, CompType.generator());
    System.out.println(
      <font color=#004488>"before sorting, a = "</font> + Arrays.asList(a));
    Arrays.sort(a, Collections.reverseOrder());
    System.out.println(
      <font color=#004488>"after sorting, a = "</font> + Arrays.asList(a));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><a name="Index994"></a>The call to <b>Collections.reverseOrder(&#160;)</b> produces the reference to the <b>Comparator</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1288" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As a second example, the following <b>Comparator</b> compares <b>CompType</b> objects based on their <b>j</b> values rather than their <b>i</b> values:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ComparatorTest.java</font>
<font color=#009900>// Implementing a Comparator for a class.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> CompTypeComparator <font color=#0000ff>implements</font> Comparator {
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compare(Object o1, Object o2) {
    <font color=#0000ff>int</font> j1 = ((CompType)o1).j;
    <font color=#0000ff>int</font> j2 = ((CompType)o2).j;
    <font color=#0000ff>return</font> (j1 &lt; j2 ? -1 : (j1 == j2 ? 0 : 1));
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ComparatorTest {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, CompType.generator());
    System.out.println(
      <font color=#004488>"before sorting, a = "</font> + Arrays.asList(a));
    Arrays.sort(a, <font color=#0000ff>new</font> CompTypeComparator());
    System.out.println(
      <font color=#004488>"after sorting, a = "</font> + Arrays.asList(a));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>compare(&#160;)</b> method must return a negative integer, zero, or positive integer if the first argument is less than, equal to, or greater than the second, respectively. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1289" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775742"></a><a name="Heading10883"></a>Sorting an array</h3>
<p>With the built-in sorting methods, you can sort any array of primitives, or any array of objects that either implements <b>Comparable</b> or has an associated <b>Comparator</b>. This fills a big hole in the Java libraries; believe it or not, there was no support in Java 1.0 or 1.1 for sorting <b>String</b>s! Here&#146;s an example that generates random <b>String</b> objects and sorts them:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:StringSorting.java</font>
<font color=#009900>// Sorting an array of Strings.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StringSorting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa, <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    System.out.println(
      <font color=#004488>"Before sorting: "</font> + Arrays.asList(sa));
    Arrays.sort(sa);
    System.out.println(
      <font color=#004488>"After sorting: "</font> + Arrays.asList(sa));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>One thing you&#146;ll notice about the output in the <b>String</b> sorting algorithm is that it&#146;s <a name="Index995"></a><a name="Index996"></a><a name="Index997"></a><i>lexicographic</i>, so it puts all the words starting with uppercase letters first, followed by all the words starting with lowercase letters. (Telephone books are typically sorted this way.) You may also want to group the words together regardless of case, and you can do this by defining a <b>Comparator </b>class, thereby overriding the default <b>String Comparable </b>behavior. For reuse, this will be added to the &#147;util&#148; package: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1290" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:AlphabeticComparator.java</font>
<font color=#009900>// Keeping upper and lowercase letters together.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticComparator <font color=#0000ff>implements</font> Comparator {
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compare(Object o1, Object o2) {
    String s1 = (String)o1;
    String s2 = (String)o2;
    <font color=#0000ff>return</font> s1.toLowerCase().compareTo(s2.toLowerCase());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>By casting to <b>String</b> at the beginning, you&#146;ll get an exception if you attempt to use this with the wrong type. Each <b>String</b> is converted to lowercase before the comparison. <b>String</b>&#146;s built-in <b>compareTo(&#160;)</b> method provides the desired functionality. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1291" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s a test using <b>AlphabeticComparator</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:AlphabeticSorting.java</font>
<font color=#009900>// Keeping upper and lowercase letters together.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticSorting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa, <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    System.out.println(
      <font color=#004488>"Before sorting: "</font> + Arrays.asList(sa));
    Arrays.sort(sa, <font color=#0000ff>new</font> AlphabeticComparator());
    System.out.println(
      <font color=#004488>"After sorting: "</font> + Arrays.asList(sa));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The sorting algorithm that&#146;s used in the Java standard library is designed to be optimal for the particular type you&#146;re sorting&#151;a Quicksort for primitives, and a stable merge sort for objects. So you shouldn&#146;t need to spend any time worrying about performance unless your profiler points you to the sorting process as a bottleneck. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1292" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775743"></a><a name="Heading10936"></a>Searching a sorted
array<br></h3>
<p><a name="Index998"></a>Once an array is sorted, you can perform a fast search for a particular item by using <a name="Index999"></a><b>Arrays.binarySearch(&#160;)</b>. However, it&#146;s very important that you do not try to use <a name="Index1000"></a><b>binarySearch(&#160;)</b> on an unsorted array; the results will be unpredictable. The following example uses a <b>RandIntGenerator</b> to fill an array, and then uses the same generator to produce values to search for: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1293" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ArraySearching.java</font>
<font color=#009900>// Using Arrays.binarySearch().</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArraySearching {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] a = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[100];
    Arrays2.RandIntGenerator gen =
      <font color=#0000ff>new</font> Arrays2.RandIntGenerator(1000);
    Arrays2.fill(a, gen);
    Arrays.sort(a);
    System.out.println(
      <font color=#004488>"Sorted array: "</font> + Arrays2.toString(a));
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>int</font> r = gen.next();
      <font color=#0000ff>int</font> location = Arrays.binarySearch(a, r);
      <font color=#0000ff>if</font>(location &gt;= 0) {
        System.out.println(<font color=#004488>"Location of "</font> + r +
          <font color=#004488>" is "</font> + location + <font color=#004488>", a["</font> +
          location + <font color=#004488>"] = "</font> + a[location]);
        <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
      }
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In the <b>while</b> loop, random values are generated as search items until one of them is found. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1294" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Arrays.binarySearch(&#160;)</b> produces a value greater than or equal to zero if the search item is found. Otherwise, it produces a negative value representing the place that the element should be inserted if you are maintaining the sorted array by hand. The value produced is <br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>-(insertion point) - 1</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The insertion point is the index of the first element greater than the key, or <b>a.size(&#160;)</b>, if all elements in the array are less than the specified key. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1295" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If the array contains duplicate elements, there is no guarantee which one will be found. The algorithm is thus not really designed to support duplicate elements, but rather to tolerate them. If you need a sorted list of nonduplicated elements, use a <b>TreeSet</b> (to maintain sorted order) or <b>LinkedHashSet</b> (to maintain insertion order), which will be introduced later in this chapter. These classes take care of all the details for you automatically. Only in cases of performance bottlenecks should you replace one of these classes with a hand-maintained array. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1296" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you have sorted an object array using a <b>Comparator</b> (primitive arrays do not allow sorting with a <b>Comparator</b>), you must include that same <b>Comparator</b> when you perform a <b>binarySearch(&#160;)</b> (using the overloaded version of the method that&#146;s provided). For example, the <b>AlphabeticSorting.java</b> program can be modified to perform a search:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:AlphabeticSearch.java</font>
<font color=#009900>// Searching with a Comparator.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticSearch {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa, <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    AlphabeticComparator comp = <font color=#0000ff>new</font> AlphabeticComparator();
    Arrays.sort(sa, comp);
    <font color=#0000ff>int</font> index = Arrays.binarySearch(sa, sa[10], comp);
    System.out.println(<font color=#004488>"Index = "</font> + index);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Index = 10"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>Comparator</b> must be passed to the overloaded <b>binarySearch(&#160;)</b> as the third argument. In this example, success is guaranteed because the search item is selected from the array itself. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1297" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775744"></a><a name="Heading10994"></a>Array summary</h3>
<p>To summarize what you&#146;ve seen so far, your first and most efficient choice to hold a group of objects should be an array, and you&#146;re forced into this choice if you want to hold a group of primitives. In the remainder of this chapter we&#146;ll look at the more general case, when you don&#146;t know at the time you&#146;re writing the program how many objects you&#146;re going to need, or if you need a more sophisticated way to store your objects. Java provides a library of <a name="Index1001"></a><i>container classes</i> to solve this problem, the basic types of which are <a name="Index1002"></a><b>List</b>, <a name="Index1003"></a><b>Set</b>,<b> </b>and <a name="Index1004"></a><b>Map</b>. You can solve a surprising number of problems by using these tools. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1298" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Among their other characteristics&#151;<b>Set</b>, for example, holds only one object of each value, and <b>Map</b> is an <a name="Index1005"></a><i>associative array</i> that lets you associate any object with any other object&#151;the Java container classes will automatically resize themselves. So, unlike arrays, you can put in any number of objects and you don&#146;t need to worry about how big to make the container while you&#146;re writing the program. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1299" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775745"></a><a name="Heading10997"></a>Introduction to
containers</h2>
<p>To me, container classes are one of the most powerful tools for raw development because they significantly increase your programming muscle. The Java 2 containers represent a thorough redesign<a name="Index1006"></a><sup><a name="fnB55" href="#fn55">[55]</a></sup> of the rather poor showings in Java 1.0 and 1.1. Some of the redesign makes things tighter and more sensible. It also fills out the functionality of the containers library, providing the behavior of linked lists, queues, and deques (double-ended queues, pronounced &#147;decks&#148;). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1300" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1007"></a><a name="Index1008"></a><a name="Index1009"></a>The design of a containers library is difficult (true of most library design problems). In C++, the container classes covered the bases with many different classes. This was better than what was available prior to the C++ container classes (nothing), but it didn&#146;t translate well into Java. At the other extreme, I&#146;ve seen a containers library that consists of a single class, &#147;container,&#148; which acts like both a linear sequence and an associative array at the same time. The Java 2 container library strikes a balance: the full functionality that you expect from a mature container library, but easier to learn and use than the C++ container classes and other similar container libraries. The result can seem a bit odd in places. Unlike some of the decisions made in the early Java libraries, these oddities were not accidents, but carefully considered decisions based on trade-offs in complexity. It might take you a little while to get comfortable with some aspects of the library, but I think you&#146;ll find yourself rapidly acquiring and using these new tools. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1301" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1010"></a><a name="Index1011"></a>The Java 2 container library takes the issue of &#147;holding your objects&#148; and divides it into two distinct concepts: <br></p>
<ol>
<li><a name="Index1012"></a><a name="Index1013"></a><a name="Index1014"></a><a name="Index1015"></a><a name="Index1016"></a><b></b><b>Collection</b>:
a group of individual elements, often with some rule applied to them. A
<b>List</b> must hold the elements in a particular sequence, and a <b>Set</b>
cannot have any duplicate elements. (A <i>bag</i>, which is not implemented in
the Java container library&#151;since <b>List</b>s provide you with enough of
that functionality&#151;has no such rules.)<b> </b><font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1302" title="Send BackTalk
Comment">Feedback</a></font></li>
<li><b>Map</b>: a group of key-value object pairs. At first glance, this might
seem like it ought to be a <b>Collection</b> of pairs, but when you try to
implement it that way the design gets awkward, so it&#146;s clearer to make it
a separate concept. On the other hand, it&#146;s convenient to look at portions
of a <b>Map</b> by creating a <b>Collection</b> to represent that portion. Thus,
a <b>Map</b> can return a <b>Set</b> of its keys, a <b>Collection </b>of its
values, or a <b>Set </b>of its pairs. <b>Map</b>s, like arrays, can easily be
expanded to multiple dimensions without adding new concepts; you simply make a
<b>Map</b> whose values are <b>Map</b>s (and the values of <i>those</i>
<b>Map</b>s can be <b>Map</b>s, etc.).<b> </b><font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1303" title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>We will first look at the general features of containers, then go into details, and finally learn why there are different versions of some containers and how to choose between them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1304" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Ref348399494"></a><a name="_Toc375545351"></a><a name="_Toc24775746"></a><a name="Heading11005"></a>Printing
containers</h3>
<p>Unlike arrays, the containers print nicely without any help. Here&#146;s an example that also introduces you to the basic types of containers:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:PrintingContainers.java</font>
<font color=#009900>// Containers print themselves automatically.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintingContainers {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>static</font> Collection fill(Collection c) {
    c.add(<font color=#004488>"dog"</font>);
    c.add(<font color=#004488>"dog"</font>);
    c.add(<font color=#004488>"cat"</font>);
    <font color=#0000ff>return</font> c;
  }
  <font color=#0000ff>static</font> Map fill(Map m) {
    m.put(<font color=#004488>"dog"</font>, <font color=#004488>"Bosco"</font>);
    m.put(<font color=#004488>"dog"</font>, <font color=#004488>"Spot"</font>);
    m.put(<font color=#004488>"cat"</font>, <font color=#004488>"Rags"</font>);
    <font color=#0000ff>return</font> m;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(fill(<font color=#0000ff>new</font> ArrayList()));
    System.out.println(fill(<font color=#0000ff>new</font> HashSet()));
    System.out.println(fill(<font color=#0000ff>new</font> HashMap()));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"[dog, dog, cat]"</font>,
      <font color=#004488>"[dog, cat]"</font>,
      <font color=#004488>"{dog=Spot, cat=Rags}"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>As mentioned before, there are two basic categories in the Java container library. The distinction is based on the number of items that are held in each location of the container. The <b>Collection</b> category only holds one item in each location (the name is a bit misleading, because entire container libraries are often called &#147;collections&#148;). It includes the <b>List</b>, which holds a group of items in a specified sequence, and the <b>Set</b>, which only allows the addition of one item of each type. The <b>ArrayList </b>is a type of <b>List</b>, and <b>HashSet </b>is a type of <b>Set</b>. To add items to any <b>Collection</b>, there&#146;s an <b>add(&#160;)</b> method. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1305" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>Map</b> holds key-value pairs, rather like a mini database. The preceding example uses one flavor of <b>Map</b>,<b> </b>the <b>HashMap</b>. If you have a <b>Map</b> that associates states with their capitals and you want to know the capital of Ohio, you look it up&#151;almost as if you were indexing into an array. (Maps are also called <a name="Index1017"></a><a name="Index1018"></a><i>associative arrays</i>.) To add elements to a <b>Map</b>, there&#146;s a <b>put(&#160;)</b> method that takes a key and a value as arguments. The example only shows adding elements and does not look up the elements after they&#146;re added. That will be shown later. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1306" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The overloaded <b>fill(&#160;)</b> methods fill <b>Collection</b>s and <b>Map</b>s, respectively. If you look at the output, you can see that the default printing behavior (provided via the container&#146;s various <b>toString(&#160;)</b> methods) produces quite readable results, so no additional printing support is necessary as it was with arrays. A <b>Collection</b> is printed surrounded by square brackets, with each element separated by a comma. A <b>Map</b> is surrounded by curly braces, with each key and value associated with an equal sign (keys on the left, values on the right). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1307" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can also immediately see the basic behavior of the different containers. The <b>List</b> holds the objects exactly as they are entered, without any reordering or editing. The <b>Set</b>, however, only accepts one of each object, and it uses its own internal ordering method (in general, you are only concerned with whether or not something is a member of the <b>Set</b>, not the order in which it appears&#151;for that you&#146;d use a <b>List</b>). And the <b>Map</b> also only accepts one of each type of item, based on the key, and it also has its own internal ordering and does not care about the order in which you enter the items. If maintaining the insertion sequence is important, you can use a <b>LinkedHashSet</b> or <a name="Index1019"></a><b>LinkedHashMap</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1308" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775747"></a><a name="Heading11042"></a>Filling containers</h3>
<p>Although the problem of printing the containers is taken care of, filling containers suffers from the same deficiency as <b>java.util.Arrays</b>. Just like <b>Arrays</b>, there is a companion class called <b>Collections</b> containing <b>static</b> utility methods, including one called <a name="Index1020"></a><b>fill(&#160;)</b>. This <b>fill(&#160;)</b> also just duplicates a single object reference throughout the container, and also only works for <b>List</b> objects and not <b>Set</b>s or <b>Map</b>s:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:FillingLists.java</font>
<font color=#009900>// The Collections.fill() method.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillingLists {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      list.add(<font color=#004488>""</font>);
    Collections.fill(list, <font color=#004488>"Hello"</font>);
    System.out.println(list);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"[Hello, Hello, Hello, Hello, Hello, "</font> +
        <font color=#004488>"Hello, Hello, Hello, Hello, Hello]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This method is made even less useful by the fact that it can only replace elements that are already in the <b>List</b> and will not add new elements. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1309" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To be able to create interesting examples, here is a complementary <b>Collections2</b> library (part of <b>com.bruceeckel.util </b>for convenience) with a <b>fill(&#160;)</b> method that uses a generator to add elements and allows you to specify the number of elements you want to <a name="Index1021"></a><b>add(&#160;)</b>. The <b>Generator interface</b> defined previously will work for <b>Collection</b>s, but the <b>Map</b> requires its own generator <b>interface</b> since a pair of objects (one key and one value) must be produced by each call to <b>next(&#160;)</b>. Here is the <b>Pair</b> class:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Pair.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Pair {
  <font color=#0000ff>public</font> Object key, value;
  <font color=#0000ff>public</font> Pair(Object k, Object v) {
    key = k;
    value = v;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Next, the generator <b>interface</b> that produces the <b>Pair</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:MapGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> MapGenerator { Pair next(); } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>With these, a set of utilities for working with the container classes can be developed:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Collections2.java</font>
<font color=#009900>// To fill any type of container using a generator object.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Collections2 {
  <font color=#009900>// Fill an array using a generator:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(Collection c, Generator gen, <font color=#0000ff>int</font> count) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; count; i++)
      c.add(gen.next());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  fill(Map m, MapGenerator gen, <font color=#0000ff>int</font> count) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; count; i++) {
      Pair p = gen.next();
      m.put(p.key, p.value);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  RandStringPairGenerator <font color=#0000ff>implements</font> MapGenerator {
    <font color=#0000ff>private</font> Arrays2.RandStringGenerator gen;
    <font color=#0000ff>public</font> RandStringPairGenerator(<font color=#0000ff>int</font> len) {
      gen = <font color=#0000ff>new</font> Arrays2.RandStringGenerator(len);
    }
    <font color=#0000ff>public</font> Pair next() {
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Pair(gen.next(), gen.next());
    }
  }
  <font color=#009900>// Default object so you don't have to create your own:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> RandStringPairGenerator rsp =
    <font color=#0000ff>new</font> RandStringPairGenerator(10);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  StringPairGenerator <font color=#0000ff>implements</font> MapGenerator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> index = -1;
    <font color=#0000ff>private</font> String[][] d;
    <font color=#0000ff>public</font> StringPairGenerator(String[][] data) {
      d = data;
    }
    <font color=#0000ff>public</font> Pair next() {
      <font color=#009900>// Force the index to wrap:</font>
      index = (index + 1) % d.length;
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Pair(d[index][0], d[index][1]);
    }
    <font color=#0000ff>public</font> StringPairGenerator reset() {
      index = -1;
      <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
    }
  }
  <font color=#009900>// Use a predefined dataset:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringPairGenerator geography =
    <font color=#0000ff>new</font> StringPairGenerator(CountryCapitals.pairs);
  <font color=#009900>// Produce a sequence from a 2D array:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> StringGenerator <font color=#0000ff>implements</font> Generator{
    <font color=#0000ff>private</font> String[][] d;
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> position;
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> index = -1;
    <font color=#0000ff>public</font> StringGenerator(String[][] data, <font color=#0000ff>int</font> pos) {
      d = data;
      position = pos;
    }
    <font color=#0000ff>public</font> Object next() {
      <font color=#009900>// Force the index to wrap:</font>
      index = (index + 1) % d.length;
      <font color=#0000ff>return</font> d[index][position];
    }
    <font color=#0000ff>public</font> StringGenerator reset() {
      index = -1;
      <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
    }
  }
  <font color=#009900>// Use a predefined dataset:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringGenerator countries =
    <font color=#0000ff>new</font> StringGenerator(CountryCapitals.pairs, 0);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringGenerator capitals =
    <font color=#0000ff>new</font> StringGenerator(CountryCapitals.pairs, 1);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Both versions of <b>fill(&#160;)</b> take an argument that determines the number of items to add to the container. In addition, there are two generators for the map: <b>RandStringPairGenerator</b>, which creates any number of pairs of gibberish <b>String</b>s with length determined by the constructor argument; and <b>StringPairGenerator</b>, which produces pairs of <b>String</b>s given a two-dimensional array of <b>String</b>. The <b>StringGenerator</b> also takes a two-dimensional array of <b>String </b>but generates single items rather than <b>Pair</b>s.<b> </b>The <b>static rsp</b>, <b>geography</b>,<b> countries</b>, and <b>capitals</b> objects provide prebuilt generators, the last three using<b> </b>all the countries of the world and their capitals. Note that if you try to create more pairs than are available, the generators will loop around to the beginning, and if you are putting the pairs into a <b>Map</b>, the duplicates will just be ignored. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1310" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here is the predefined dataset, which consists of country names and their capitals:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:CountryCapitals.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CountryCapitals {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> String[][] pairs = {
    <font color=#009900>// Africa</font>
    {<font color=#004488>"ALGERIA"</font>,<font color=#004488>"Algiers"</font>}, {<font color=#004488>"ANGOLA"</font>,<font color=#004488>"Luanda"</font>},
    {<font color=#004488>"BENIN"</font>,<font color=#004488>"Porto-Novo"</font>}, {<font color=#004488>"BOTSWANA"</font>,<font color=#004488>"Gaberone"</font>},
    {<font color=#004488>"BURKINA FASO"</font>,<font color=#004488>"Ouagadougou"</font>},
    {<font color=#004488>"BURUNDI"</font>,<font color=#004488>"Bujumbura"</font>},
    {<font color=#004488>"CAMEROON"</font>,<font color=#004488>"Yaounde"</font>}, {<font color=#004488>"CAPE VERDE"</font>,<font color=#004488>"Praia"</font>},
    {<font color=#004488>"CENTRAL AFRICAN REPUBLIC"</font>,<font color=#004488>"Bangui"</font>},
    {<font color=#004488>"CHAD"</font>,<font color=#004488>"N'djamena"</font>},  {<font color=#004488>"COMOROS"</font>,<font color=#004488>"Moroni"</font>},
    {<font color=#004488>"CONGO"</font>,<font color=#004488>"Brazzaville"</font>}, {<font color=#004488>"DJIBOUTI"</font>,<font color=#004488>"Dijibouti"</font>},
    {<font color=#004488>"EGYPT"</font>,<font color=#004488>"Cairo"</font>}, {<font color=#004488>"EQUATORIAL GUINEA"</font>,<font color=#004488>"Malabo"</font>},
    {<font color=#004488>"ERITREA"</font>,<font color=#004488>"Asmara"</font>}, {<font color=#004488>"ETHIOPIA"</font>,<font color=#004488>"Addis Ababa"</font>},
    {<font color=#004488>"GABON"</font>,<font color=#004488>"Libreville"</font>}, {<font color=#004488>"THE GAMBIA"</font>,<font color=#004488>"Banjul"</font>},
    {<font color=#004488>"GHANA"</font>,<font color=#004488>"Accra"</font>}, {<font color=#004488>"GUINEA"</font>,<font color=#004488>"Conakry"</font>},
    {<font color=#004488>"GUINEA"</font>,<font color=#004488>"-"</font>}, {<font color=#004488>"BISSAU"</font>,<font color=#004488>"Bissau"</font>},
    {<font color=#004488>"COTE D'IVOIR (IVORY COAST)"</font>,<font color=#004488>"Yamoussoukro"</font>},
    {<font color=#004488>"KENYA"</font>,<font color=#004488>"Nairobi"</font>}, {<font color=#004488>"LESOTHO"</font>,<font color=#004488>"Maseru"</font>},
    {<font color=#004488>"LIBERIA"</font>,<font color=#004488>"Monrovia"</font>}, {<font color=#004488>"LIBYA"</font>,<font color=#004488>"Tripoli"</font>},
    {<font color=#004488>"MADAGASCAR"</font>,<font color=#004488>"Antananarivo"</font>}, {<font color=#004488>"MALAWI"</font>,<font color=#004488>"Lilongwe"</font>},
    {<font color=#004488>"MALI"</font>,<font color=#004488>"Bamako"</font>}, {<font color=#004488>"MAURITANIA"</font>,<font color=#004488>"Nouakchott"</font>},
    {<font color=#004488>"MAURITIUS"</font>,<font color=#004488>"Port Louis"</font>}, {<font color=#004488>"MOROCCO"</font>,<font color=#004488>"Rabat"</font>},
    {<font color=#004488>"MOZAMBIQUE"</font>,<font color=#004488>"Maputo"</font>}, {<font color=#004488>"NAMIBIA"</font>,<font color=#004488>"Windhoek"</font>},
    {<font color=#004488>"NIGER"</font>,<font color=#004488>"Niamey"</font>}, {<font color=#004488>"NIGERIA"</font>,<font color=#004488>"Abuja"</font>},
    {<font color=#004488>"RWANDA"</font>,<font color=#004488>"Kigali"</font>},
    {<font color=#004488>"SAO TOME E PRINCIPE"</font>,<font color=#004488>"Sao Tome"</font>},
    {<font color=#004488>"SENEGAL"</font>,<font color=#004488>"Dakar"</font>}, {<font color=#004488>"SEYCHELLES"</font>,<font color=#004488>"Victoria"</font>},
    {<font color=#004488>"SIERRA LEONE"</font>,<font color=#004488>"Freetown"</font>}, {<font color=#004488>"SOMALIA"</font>,<font color=#004488>"Mogadishu"</font>},
    {<font color=#004488>"SOUTH AFRICA"</font>,<font color=#004488>"Pretoria</font><font color=#004488>/Cape Town"</font>},
    {<font color=#004488>"SUDAN"</font>,<font color=#004488>"Khartoum"</font>},
    {<font color=#004488>"SWAZILAND"</font>,<font color=#004488>"Mbabane"</font>}, {<font color=#004488>"TANZANIA"</font>,<font color=#004488>"Dodoma"</font>},
    {<font color=#004488>"TOGO"</font>,<font color=#004488>"Lome"</font>}, {<font color=#004488>"TUNISIA"</font>,<font color=#004488>"Tunis"</font>},
    {<font color=#004488>"UGANDA"</font>,<font color=#004488>"Kampala"</font>},
    {<font color=#004488>"DEMOCRATIC REPUBLIC OF THE CONGO (ZAIRE)"</font>,
     <font color=#004488>"Kinshasa"</font>},
    {<font color=#004488>"ZAMBIA"</font>,<font color=#004488>"Lusaka"</font>}, {<font color=#004488>"ZIMBABWE"</font>,<font color=#004488>"Harare"</font>},
    <font color=#009900>// Asia</font>
    {<font color=#004488>"AFGHANISTAN"</font>,<font color=#004488>"Kabul"</font>}, {<font color=#004488>"BAHRAIN"</font>,<font color=#004488>"Manama"</font>},
    {<font color=#004488>"BANGLADESH"</font>,<font color=#004488>"Dhaka"</font>}, {<font color=#004488>"BHUTAN"</font>,<font color=#004488>"Thimphu"</font>},
    {<font color=#004488>"BRUNEI"</font>,<font color=#004488>"Bandar Seri Begawan"</font>},
    {<font color=#004488>"CAMBODIA"</font>,<font color=#004488>"Phnom Penh"</font>},
    {<font color=#004488>"CHINA"</font>,<font color=#004488>"Beijing"</font>}, {<font color=#004488>"CYPRUS"</font>,<font color=#004488>"Nicosia"</font>},
    {<font color=#004488>"INDIA"</font>,<font color=#004488>"New Delhi"</font>}, {<font color=#004488>"INDONESIA"</font>,<font color=#004488>"Jakarta"</font>},
    {<font color=#004488>"IRAN"</font>,<font color=#004488>"Tehran"</font>}, {<font color=#004488>"IRAQ"</font>,<font color=#004488>"Baghdad"</font>},
    {<font color=#004488>"ISRAEL"</font>,<font color=#004488>"Tel Aviv"</font>}, {<font color=#004488>"JAPAN"</font>,<font color=#004488>"Tokyo"</font>},
    {<font color=#004488>"JORDAN"</font>,<font color=#004488>"Amman"</font>}, {<font color=#004488>"KUWAIT"</font>,<font color=#004488>"Kuwait City"</font>},
    {<font color=#004488>"LAOS"</font>,<font color=#004488>"Vientiane"</font>}, {<font color=#004488>"LEBANON"</font>,<font color=#004488>"Beirut"</font>},
    {<font color=#004488>"MALAYSIA"</font>,<font color=#004488>"Kuala Lumpur"</font>}, {<font color=#004488>"THE MALDIVES"</font>,<font color=#004488>"Male"</font>},
    {<font color=#004488>"MONGOLIA"</font>,<font color=#004488>"Ulan Bator"</font>},
    {<font color=#004488>"MYANMAR (BURMA)"</font>,<font color=#004488>"Rangoon"</font>},
    {<font color=#004488>"NEPAL"</font>,<font color=#004488>"Katmandu"</font>}, {<font color=#004488>"NORTH KOREA"</font>,<font color=#004488>"P'yongyang"</font>},
    {<font color=#004488>"OMAN"</font>,<font color=#004488>"Muscat"</font>}, {<font color=#004488>"PAKISTAN"</font>,<font color=#004488>"Islamabad"</font>},
    {<font color=#004488>"PHILIPPINES"</font>,<font color=#004488>"Manila"</font>}, {<font color=#004488>"QATAR"</font>,<font color=#004488>"Doha"</font>},
    {<font color=#004488>"SAUDI ARABIA"</font>,<font color=#004488>"Riyadh"</font>}, {<font color=#004488>"SINGAPORE"</font>,<font color=#004488>"Singapore"</font>},
    {<font color=#004488>"SOUTH KOREA"</font>,<font color=#004488>"Seoul"</font>}, {<font color=#004488>"SRI LANKA"</font>,<font color=#004488>"Colombo"</font>},
    {<font color=#004488>"SYRIA"</font>,<font color=#004488>"Damascus"</font>},
    {<font color=#004488>"TAIWAN (REPUBLIC OF CHINA)"</font>,<font color=#004488>"Taipei"</font>},
    {<font color=#004488>"THAILAND"</font>,<font color=#004488>"Bangkok"</font>}, {<font color=#004488>"TURKEY"</font>,<font color=#004488>"Ankara"</font>},
    {<font color=#004488>"UNITED ARAB EMIRATES"</font>,<font color=#004488>"Abu Dhabi"</font>},
    {<font color=#004488>"VIETNAM"</font>,<font color=#004488>"Hanoi"</font>}, {<font color=#004488>"YEMEN"</font>,<font color=#004488>"Sana'a"</font>},
    <font color=#009900>// Australia and Oceania</font>
    {<font color=#004488>"AUSTRALIA"</font>,<font color=#004488>"Canberra"</font>}, {<font color=#004488>"FIJI"</font>,<font color=#004488>"Suva"</font>},
    {<font color=#004488>"KIRIBATI"</font>,<font color=#004488>"Bairiki"</font>},
    {<font color=#004488>"MARSHALL ISLANDS"</font>,<font color=#004488>"Dalap-Uliga-Darrit"</font>},
    {<font color=#004488>"MICRONESIA"</font>,<font color=#004488>"Palikir"</font>}, {<font color=#004488>"NAURU"</font>,<font color=#004488>"Yaren"</font>},
    {<font color=#004488>"NEW ZEALAND"</font>,<font color=#004488>"Wellington"</font>}, {<font color=#004488>"PALAU"</font>,<font color=#004488>"Koror"</font>},
    {<font color=#004488>"PAPUA NEW GUINEA"</font>,<font color=#004488>"Port Moresby"</font>},
    {<font color=#004488>"SOLOMON ISLANDS"</font>,<font color=#004488>"Honaira"</font>}, {<font color=#004488>"TONGA"</font>,<font color=#004488>"Nuku'alofa"</font>},
    {<font color=#004488>"TUVALU"</font>,<font color=#004488>"Fongafale"</font>}, {<font color=#004488>"VANUATU"</font>,<font color=#004488>"&lt; Port-Vila"</font>},
    {<font color=#004488>"WESTERN SAMOA"</font>,<font color=#004488>"Apia"</font>},
    <font color=#009900>// Eastern Europe and former USSR</font>
    {<font color=#004488>"ARMENIA"</font>,<font color=#004488>"Yerevan"</font>}, {<font color=#004488>"AZERBAIJAN"</font>,<font color=#004488>"Baku"</font>},
    {<font color=#004488>"BELARUS (BYELORUSSIA)"</font>,<font color=#004488>"Minsk"</font>},
    {<font color=#004488>"GEORGIA"</font>,<font color=#004488>"Tbilisi"</font>},
    {<font color=#004488>"KAZAKSTAN"</font>,<font color=#004488>"Almaty"</font>}, {<font color=#004488>"KYRGYZSTAN"</font>,<font color=#004488>"Alma-Ata"</font>},
    {<font color=#004488>"MOLDOVA"</font>,<font color=#004488>"Chisinau"</font>}, {<font color=#004488>"RUSSIA"</font>,<font color=#004488>"Moscow"</font>},
    {<font color=#004488>"TAJIKISTAN"</font>,<font color=#004488>"Dushanbe"</font>}, {<font color=#004488>"TURKMENISTAN"</font>,<font color=#004488>"Ashkabad"</font>},
    {<font color=#004488>"UKRAINE"</font>,<font color=#004488>"Kyiv"</font>}, {<font color=#004488>"UZBEKISTAN"</font>,<font color=#004488>"Tashkent"</font>},
    <font color=#009900>// Europe</font>
    {<font color=#004488>"ALBANIA"</font>,<font color=#004488>"Tirana"</font>}, {<font color=#004488>"ANDORRA"</font>,<font color=#004488>"Andorra la Vella"</font>},
    {<font color=#004488>"AUSTRIA"</font>,<font color=#004488>"Vienna"</font>}, {<font color=#004488>"BELGIUM"</font>,<font color=#004488>"Brussels"</font>},
    {<font color=#004488>"BOSNIA"</font>,<font color=#004488>"-"</font>}, {<font color=#004488>"HERZEGOVINA"</font>,<font color=#004488>"Sarajevo"</font>},
    {<font color=#004488>"CROATIA"</font>,<font color=#004488>"Zagreb"</font>}, {<font color=#004488>"CZECH REPUBLIC"</font>,<font color=#004488>"Prague"</font>},
    {<font color=#004488>"DENMARK"</font>,<font color=#004488>"Copenhagen"</font>}, {<font color=#004488>"ESTONIA"</font>,<font color=#004488>"Tallinn"</font>},
    {<font color=#004488>"FINLAND"</font>,<font color=#004488>"Helsinki"</font>}, {<font color=#004488>"FRANCE"</font>,<font color=#004488>"Paris"</font>},
    {<font color=#004488>"GERMANY"</font>,<font color=#004488>"Berlin"</font>}, {<font color=#004488>"GREECE"</font>,<font color=#004488>"Athens"</font>},
    {<font color=#004488>"HUNGARY"</font>,<font color=#004488>"Budapest"</font>}, {<font color=#004488>"ICELAND"</font>,<font color=#004488>"Reykjavik"</font>},
    {<font color=#004488>"IRELAND"</font>,<font color=#004488>"Dublin"</font>}, {<font color=#004488>"ITALY"</font>,<font color=#004488>"Rome"</font>},
    {<font color=#004488>"LATVIA"</font>,<font color=#004488>"Riga"</font>}, {<font color=#004488>"LIECHTENSTEIN"</font>,<font color=#004488>"Vaduz"</font>},
    {<font color=#004488>"LITHUANIA"</font>,<font color=#004488>"Vilnius"</font>}, {<font color=#004488>"LUXEMBOURG"</font>,<font color=#004488>"Luxembourg"</font>},
    {<font color=#004488>"MACEDONIA"</font>,<font color=#004488>"Skopje"</font>}, {<font color=#004488>"MALTA"</font>,<font color=#004488>"Valletta"</font>},
    {<font color=#004488>"MONACO"</font>,<font color=#004488>"Monaco"</font>}, {<font color=#004488>"MONTENEGRO"</font>,<font color=#004488>"Podgorica"</font>},
    {<font color=#004488>"THE NETHERLANDS"</font>,<font color=#004488>"Amsterdam"</font>}, {<font color=#004488>"NORWAY"</font>,<font color=#004488>"Oslo"</font>},
    {<font color=#004488>"POLAND"</font>,<font color=#004488>"Warsaw"</font>}, {<font color=#004488>"PORTUGAL"</font>,<font color=#004488>"Lisbon"</font>},
    {<font color=#004488>"ROMANIA"</font>,<font color=#004488>"Bucharest"</font>}, {<font color=#004488>"SAN MARINO"</font>,<font color=#004488>"San Marino"</font>},
    {<font color=#004488>"SERBIA"</font>,<font color=#004488>"Belgrade"</font>}, {<font color=#004488>"SLOVAKIA"</font>,<font color=#004488>"Bratislava"</font>},
    {<font color=#004488>"SLOVENIA"</font>,<font color=#004488>"Ljujiana"</font>}, {<font color=#004488>"SPAIN"</font>,<font color=#004488>"Madrid"</font>},
    {<font color=#004488>"SWEDEN"</font>,<font color=#004488>"Stockholm"</font>}, {<font color=#004488>"SWITZERLAND"</font>,<font color=#004488>"Berne"</font>},
    {<font color=#004488>"UNITED KINGDOM"</font>,<font color=#004488>"London"</font>}, {<font color=#004488>"VATICAN CITY"</font>,<font color=#004488>"---"</font>},
    <font color=#009900>// North and Central America</font>
    {<font color=#004488>"ANTIGUA AND BARBUDA"</font>,<font color=#004488>"Saint John's"</font>},
    {<font color=#004488>"BAHAMAS"</font>,<font color=#004488>"Nassau"</font>},
    {<font color=#004488>"BARBADOS"</font>,<font color=#004488>"Bridgetown"</font>}, {<font color=#004488>"BELIZE"</font>,<font color=#004488>"Belmopan"</font>},
    {<font color=#004488>"CANADA"</font>,<font color=#004488>"Ottawa"</font>}, {<font color=#004488>"COSTA RICA"</font>,<font color=#004488>"San Jose"</font>},
    {<font color=#004488>"CUBA"</font>,<font color=#004488>"Havana"</font>}, {<font color=#004488>"DOMINICA"</font>,<font color=#004488>"Roseau"</font>},
    {<font color=#004488>"DOMINICAN REPUBLIC"</font>,<font color=#004488>"Santo Domingo"</font>},
    {<font color=#004488>"EL SALVADOR"</font>,<font color=#004488>"San Salvador"</font>},
    {<font color=#004488>"GRENADA"</font>,<font color=#004488>"Saint George's"</font>},
    {<font color=#004488>"GUATEMALA"</font>,<font color=#004488>"Guatemala City"</font>},
    {<font color=#004488>"HAITI"</font>,<font color=#004488>"Port-au-Prince"</font>},
    {<font color=#004488>"HONDURAS"</font>,<font color=#004488>"Tegucigalpa"</font>}, {<font color=#004488>"JAMAICA"</font>,<font color=#004488>"Kingston"</font>},
    {<font color=#004488>"MEXICO"</font>,<font color=#004488>"Mexico City"</font>}, {<font color=#004488>"NICARAGUA"</font>,<font color=#004488>"Managua"</font>},
    {<font color=#004488>"PANAMA"</font>,<font color=#004488>"Panama City"</font>}, {<font color=#004488>"ST. KITTS"</font>,<font color=#004488>"-"</font>},
    {<font color=#004488>"NEVIS"</font>,<font color=#004488>"Basseterre"</font>}, {<font color=#004488>"ST. LUCIA"</font>,<font color=#004488>"Castries"</font>},
    {<font color=#004488>"ST. VINCENT AND THE GRENADINES"</font>,<font color=#004488>"Kingstown"</font>},
    {<font color=#004488>"UNITED STATES OF AMERICA"</font>,<font color=#004488>"Washington, D.C."</font>},
    <font color=#009900>// South America</font>
    {<font color=#004488>"ARGENTINA"</font>,<font color=#004488>"Buenos Aires"</font>},
    {<font color=#004488>"BOLIVIA"</font>,<font color=#004488>"Sucre (legal)</font><font color=#004488>/La Paz(administrative)"</font>},
    {<font color=#004488>"BRAZIL"</font>,<font color=#004488>"Brasilia"</font>}, {<font color=#004488>"CHILE"</font>,<font color=#004488>"Santiago"</font>},
    {<font color=#004488>"COLOMBIA"</font>,<font color=#004488>"Bogota"</font>}, {<font color=#004488>"ECUADOR"</font>,<font color=#004488>"Quito"</font>},
    {<font color=#004488>"GUYANA"</font>,<font color=#004488>"Georgetown"</font>}, {<font color=#004488>"PARAGUAY"</font>,<font color=#004488>"Asuncion"</font>},
    {<font color=#004488>"PERU"</font>,<font color=#004488>"Lima"</font>}, {<font color=#004488>"SURINAME"</font>,<font color=#004488>"Paramaribo"</font>},
    {<font color=#004488>"TRINIDAD AND TOBAGO"</font>,<font color=#004488>"Port of Spain"</font>},
    {<font color=#004488>"URUGUAY"</font>,<font color=#004488>"Montevideo"</font>}, {<font color=#004488>"VENEZUELA"</font>,<font color=#004488>"Caracas"</font>},
  };
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This is simply a two-dimensional array of <b>String</b> data.<sup><a name="fnB56" href="#fn56">[56]</a></sup> Here&#146;s a simple test using the <b>fill(&#160;)</b> methods and generators:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:FillTest.java</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillTest {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Generator sg =
    <font color=#0000ff>new</font> Arrays2.RandStringGenerator(7);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list, sg, 25);
    System.out.println(list + <font color=#004488>"\n"</font>);
    List list2 = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list2, Collections2.capitals, 25);
    System.out.println(list2 + <font color=#004488>"\n"</font>);
    Set set = <font color=#0000ff>new</font> HashSet();
    Collections2.fill(set, sg, 25);
    System.out.println(set + <font color=#004488>"\n"</font>);
    Map m = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m, Collections2.rsp, 25);
    System.out.println(m + <font color=#004488>"\n"</font>);
    Map m2 = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m2, Collections2.geography, 25);
    System.out.println(m2);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>With these tools you can easily test the various containers by filling them with interesting data. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1311" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775748"></a><a name="Heading11323"></a>Container disadvantage:
<br>unknown type</h2>
<p>The &#147;disadvantage&#148; to using the Java containers is that you lose type information when you put an object into a container. This happens because the programmer of that container class had no idea what specific type you wanted to put in the container, and making the container hold only your type would prevent it from being a general-purpose tool. So instead, the container holds references to <b>Object</b>, which is the root of all the classes, so it holds any type. (Of course, this doesn&#146;t include primitive types, since they aren&#146;t real objects, and thus, are not inherited from anything.) This is a great solution, except:  <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1312" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li><a name="Index1023"></a>Because the type information is thrown away when you
put an object reference into a container, there&#146;s no restriction on the
type of object that can be put into your container, even if you mean it to hold
only, say, cats. Someone could just as easily put a dog into the container.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1313"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>Because the type information is lost, the only thing the container knows
that it holds is a reference to an object. You must perform a cast to the
correct type before you use it. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1314" title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>On the up side, Java won&#146;t let you <i>misuse</i> the objects that you put into a container. If you throw a dog into a container of cats and then try to treat everything in the container as a cat, you&#146;ll get a <b>RuntimeException</b> when you pull the dog reference out of the cat container and try to cast it to a cat. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1315" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example using the basic workhorse container, <b>ArrayList</b>. For starters, you can think of <b>ArrayList</b> as &#147;an array that automatically expands itself.&#148; Using an <b>ArrayList</b> is straightforward: create one, put objects in using <a name="Index1024"></a><a name="Index1025"></a><b>add(&#160;),</b> and later get them out with <a name="Index1026"></a><a name="Index1027"></a><b>get(&#160;) </b>using an index&#151;just like you would with an array, but without the square brackets.<sup><a name="fnB57" href="#fn57">[57]</a></sup> <b>ArrayList</b> also has a method <a name="Index1028"></a><a name="Index1029"></a><b>size(&#160;)</b> to let you know how many elements have been added so you don&#146;t inadvertently run off the end and cause an exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1316" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>First, <b>Cat</b> and <b>Dog</b> classes are created:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Cat.java</font>
<font color=#0000ff>package</font> c11;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Cat {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> catNumber;
  <font color=#0000ff>public</font> Cat(<font color=#0000ff>int</font> i) { catNumber = i; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> id() {
    System.out.println(<font color=#004488>"Cat #"</font> + catNumber);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Dog.java</font>
<font color=#0000ff>package</font> c11;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Dog {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> dogNumber;
  <font color=#0000ff>public</font> Dog(<font color=#0000ff>int</font> i) { dogNumber = i; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> id() {
    System.out.println(<font color=#004488>"Dog #"</font> + dogNumber);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>Cat</b>s and <b>Dog</b>s are placed into the container, then pulled out:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:CatsAndDogs.java</font>
<font color=#009900>// Simple container example.</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>package</font> c11;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CatsAndDogs {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List cats = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++)
      cats.add(<font color=#0000ff>new</font> Cat(i));
    <font color=#009900>// Not a problem to add a dog to cats:</font>
    cats.add(<font color=#0000ff>new</font> Dog(7));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cats.size(); i++)
      ((Cat)cats.get(i)).id();
      <font color=#009900>// Dog is detected only at run time</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The classes <b>Cat</b> and <b>Dog</b> are distinct; they have nothing in common except that they are <b>Object</b>s. (If you don&#146;t explicitly say what class you&#146;re inheriting from, you automatically inherit from <b>Object</b>.) Since <b>ArrayList</b> holds <b>Object</b>s, you can not only put <b>Cat</b> objects into this container using the <b>ArrayList </b>method <b>add(&#160;)</b>, but you can also add <b>Dog</b> objects without complaint at either compile time or run time. When you go to fetch out what you think are <b>Cat</b> objects using the <b>ArrayList</b> method <b>get(&#160;)</b>, you get back a reference to an object that you must cast to a <b>Cat</b>. Then you need to surround the entire expression with parentheses to force the evaluation of the cast before calling the <b>id(&#160;)</b> method for <b>Cat</b>; otherwise, you&#146;ll get a syntax error. Then, at run time, when you try to cast the <b>Dog</b> object to a <b>Cat</b>, you&#146;ll get an exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1317" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This is more than just an annoyance. It&#146;s something that can create difficult-to-find bugs. If one part (or several parts) of a program inserts objects into a container, and you discover only in a separate part of the program through an exception that a bad object was placed in the container, then you must find out where the bad insert occurred. Most of the time this isn&#146;t a problem, but you should be aware of the possibility. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1318" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775749"></a><a name="Heading11375"></a>Sometimes it works
anyway</h3>
<p>It turns out that in some cases things seem to work correctly without casting back to your original type. One case is quite special: The <b>String</b> class has some extra help from the compiler to make it work smoothly. Whenever the compiler expects a <b>String</b> object and it hasn&#146;t got one, it will automatically call the <a name="Index1030"></a><a name="Index1031"></a><b>toString(&#160;)</b> method that&#146;s defined in <b>Object</b> and can be overridden by any Java class. This method produces the desired <b>String</b> object, which is then used wherever it is wanted. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1319" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Thus, all you need to do to make objects of your class print is to override the <b>toString(&#160;)</b> method, as shown in the following example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Mouse.java</font>
<font color=#009900>// Overriding toString().</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Mouse {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> mouseNumber;
  <font color=#0000ff>public</font> Mouse(<font color=#0000ff>int</font> i) { mouseNumber = i; }
  <font color=#009900>// Override Object.toString():</font>
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"This is Mouse #"</font> + mouseNumber;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getNumber() { <font color=#0000ff>return</font> mouseNumber; }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:MouseTrap.java</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseTrap {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> caughtYa(Object m) {
    Mouse mouse = (Mouse)m; <font color=#009900>// Cast from Object</font>
    System.out.println(<font color=#004488>"Mouse: "</font> + mouse.getNumber());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:WorksAnyway.java</font>
<font color=#009900>// In special cases, things just seem to work correctly.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WorksAnyway {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List mice = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      mice.add(<font color=#0000ff>new</font> Mouse(i));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; mice.size(); i++) {
      <font color=#009900>// No cast necessary, automatic</font>
      <font color=#009900>// call to Object.toString():</font>
      System.out.println(<font color=#004488>"Free mouse: "</font> + mice.get(i));
      MouseTrap.caughtYa(mice.get(i));
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Free mouse: This is Mouse #0"</font>,
      <font color=#004488>"Mouse: 0"</font>,
      <font color=#004488>"Free mouse: This is Mouse #1"</font>,
      <font color=#004488>"Mouse: 1"</font>,
      <font color=#004488>"Free mouse: This is Mouse #2"</font>,
      <font color=#004488>"Mouse: 2"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see <b>toString(&#160;)</b> overridden in <b>Mouse</b>. In the second <b>for</b> loop in <b>main(&#160;)</b> you find the statement:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println(<font color=#004488>"Free mouse: "</font> + mice.get(i));</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>After the &#145;<b>+</b>&#146; sign the compiler expects to see a <a name="Index1032"></a><a name="Index1033"></a><b>String</b> object. <b>get(&#160;)</b> produces an <b>Object</b>, so to get the desired <b>String</b>, the compiler implicitly calls <b>toString(&#160;)</b>. Unfortunately, you can work this kind of magic only with <b>String</b>; it isn&#146;t available for any other type. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1320" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A second approach to hiding the cast has been placed inside <b>MouseTrap</b>. The <b>caughtYa(&#160;)</b> method accepts not a <b>Mouse</b>, but an <b>Object,</b> which it then casts to a <b>Mouse</b>. This is quite presumptuous, of course, since by accepting an <b>Object</b>, anything could be passed to the method. However, if the cast is incorrect&#151;if you passed the wrong type&#151;you&#146;ll get an exception at run time. This is not as good as compile-time checking, but it&#146;s still robust. Note that in the use of this method:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MouseTrap.caughtYa(mice.get(i));</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>no cast is necessary. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1321" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775750"></a><a name="Heading11436"></a>Making a type-conscious
<b>ArrayList</b><br></h3>
<p><a name="Index1034"></a><a name="Index1035"></a>You might not want to give up on this issue just yet. A more ironclad solution is to create a new class using the <b>ArrayList</b>, such that it will accept only your type and produce only your type:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:MouseList.java</font>
<font color=#009900>// A type-conscious List.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseList {
  <font color=#0000ff>private</font> List list = <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> add(Mouse m) { list.add(m); }
  <font color=#0000ff>public</font> Mouse get(<font color=#0000ff>int</font> index) {
    <font color=#0000ff>return</font> (Mouse)list.get(index);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> size() { <font color=#0000ff>return</font> list.size(); }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Here&#146;s a test for the new container:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:MouseListTest.java</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseListTest {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    MouseList mice = <font color=#0000ff>new</font> MouseList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      mice.add(<font color=#0000ff>new</font> Mouse(i));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; mice.size(); i++)
      MouseTrap.caughtYa(mice.get(i));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Mouse: 0"</font>,
      <font color=#004488>"Mouse: 1"</font>,
      <font color=#004488>"Mouse: 2"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This is similar to the previous example, except that the new <b>MouseList</b> class has a <b>private </b>member of type <b>ArrayList</b> and methods just like <b>ArrayList</b>. However, it doesn&#146;t accept and produce generic <b>Object</b>s, only <b>Mouse</b> objects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1322" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that if <b>MouseList</b> had instead been <i>inherited</i> from <b>ArrayList</b>, the <b>add(Mouse)</b> method would simply overload the existing <b>add(Object)</b>, and there would still be no restriction on what type of objects could be added, and you wouldn&#146;t get the desired results. Using composition, the <b>MouseList</b> simply uses the <b>ArrayList</b>, performing some activities before passing the responsibility for the rest of the operation on to the <b>ArrayList</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1323" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Because a <b>MouseList</b> will accept only a <b>Mouse</b>, if you say:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>mice.add(<font color=#0000ff>new</font> Pigeon());</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>you will get an error message <i>at compile time</i>. This approach, while more tedious from a coding standpoint, will tell you immediately if you&#146;re using a type improperly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1324" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that no cast is necessary when using <b>get(&#160;)</b>; it&#146;s always a <b>Mouse</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1325" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading11478"></a>Parameterized types</h4>
<p>This kind of problem isn&#146;t isolated. There are numerous cases in which you need to create new types based on other types, and in which it is useful to have specific type information at compile time. This is the concept of a <a name="Index1036"></a><a name="Index1037"></a><i>parameterized type</i>. In C++, this is directly supported by the language using <a name="Index1038"></a><a name="Index1039"></a><i>templates</i>. It is likely that Java JDK 1.5 will provide <i>generics</i>, the Java version of parameterized types. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1326" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545352"></a><a name="_Toc24775751"></a><a name="Heading11480"></a>Iterators</h2>
<p>In any container class, you must have a way to put things in and a way to get things out. After all, that&#146;s the primary job of a container&#151;to hold things. In the <a name="Index1040"></a><b>ArrayList</b>, <b>add(&#160;)</b> is the way that you insert objects, and <b>get(&#160;)</b> is <i>one</i> way to get things out. <b>ArrayList</b> is quite flexible; you can select anything at any time, and select multiple elements at once using different indexes. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1327" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1041"></a><a name="Index1042"></a>If you want to start thinking at a higher level, there&#146;s a drawback: You need to know the exact type of the container in order to use it. This might not seem bad at first, but what if you start out using an <b>ArrayList</b>, and later on you discover that because of the features you need in the container you actually need to use a <b>Set</b> instead? Or suppose you&#146;d like to write a piece of generic code that doesn&#146;t know or care what type of container it&#146;s working with, so that it could be used on different types of containers without rewriting that code? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1328" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The concept of an <a name="Index1043"></a><i>iterator</i> (yet another design pattern) can be used to achieve this abstraction. An iterator is an object whose job is to move through a sequence of objects and select each object in that sequence without the client programmer knowing or caring about the underlying structure of that sequence. In addition, an iterator is usually what&#146;s called a &#147;light-weight&#148; object: one that&#146;s cheap to create. For that reason, you&#146;ll often find seemingly strange constraints for iterators; for example, some iterators can move in only one direction. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1329" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The Java <b>Iterator</b> is an example of an iterator with these kinds of constraints. There&#146;s not much you can do with one except: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1330" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>Ask a container to hand you an <b>Iterator</b> using a method called
<b>iterator(&#160;)</b>.<b> </b>This <b>Iterator </b>will be ready to return the
first element in the sequence on your first call to its <b>next(&#160;)</b>
method.</li>
<li>Get the next object in the sequence with <b>next(&#160;)</b>.</li>
<li>See if there <i>are</i> any more objects in the sequence with
<b>hasNext(&#160;)</b>.</li>
<li>Remove the last element returned by the iterator with
<b>remove(&#160;)</b>.</li></ol><p>That&#146;s all. It&#146;s a simple implementation of an iterator, but still powerful (and there&#146;s a more sophisticated <b>ListIterator</b> for <b>List</b>s). To see how it works, let&#146;s revisit the <b>CatsAndDogs.java</b> program from earlier in this chapter. In the original version, the method <b>get(&#160;)</b> was used to select each element, but in the following modified version, an <b>Iterator</b> is used: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1331" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:CatsAndDogs2.java</font>
<font color=#009900>// Simple container with Iterator.</font>
<font color=#0000ff>package</font> c11;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CatsAndDogs2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List cats = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++)
      cats.add(<font color=#0000ff>new</font> Cat(i));
    Iterator e = cats.iterator();
    <font color=#0000ff>while</font>(e.hasNext())
      ((Cat)e.next()).id();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that the last few lines now use an <b>Iterator</b> to step through the sequence instead of a <b>for</b> loop. With the <b>Iterator</b>, you don&#146;t need to worry about the number of elements in the container. That&#146;s taken care of for you by <a name="Index1044"></a><a name="Index1045"></a><b>hasNext(&#160;)</b> and <a name="Index1046"></a><a name="Index1047"></a><b>next(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1332" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As another example, consider the creation of a general-purpose printing method:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Printer.java</font>
<font color=#009900>// Using an Iterator.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Printer {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printAll(Iterator e) {
    <font color=#0000ff>while</font>(e.hasNext())
      System.out.println(e.next());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Look closely at <b>printAll(&#160;)</b>. Note that there&#146;s no information about the type of sequence. All you have is an <b>Iterator</b>, and that&#146;s all you need to know about the sequence: that you can get the next object, and that you can know when you&#146;re at the end. This idea of taking a container of objects and passing through it to perform an operation on each one is powerful and will be seen throughout this book. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1333" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1048"></a><a name="Index1049"></a><a name="Index1050"></a>The example is even more generic, since it implicitly uses the <b>Object.toString(&#160;)</b> method. The <b>println(&#160;)</b> method is overloaded for all the primitive types as well as <b>Object</b>; in each case, a <b>String</b> is automatically produced by calling the appropriate <b>toString(&#160;)</b> method. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1334" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Although it&#146;s unnecessary, you can be more explicit using a cast, which has the effect of calling <b>toString(&#160;)</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println((String)e.next());</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In general, however, you&#146;ll want to do something more than call <b>Object</b> methods, so you&#146;ll run up against the type-casting issue again. You must assume you&#146;ve gotten an <b>Iterator</b> to a sequence of the particular type you&#146;re interested in, and cast the resulting objects to that type (getting a run-time exception if you&#146;re wrong). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1335" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>We can test it by printing <b>Hamster</b>s:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Hamster.java</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Hamster {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> hamsterNumber;
  <font color=#0000ff>public</font> Hamster(<font color=#0000ff>int</font> hamsterNumber) {
    <font color=#0000ff>this</font>.hamsterNumber = hamsterNumber;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"This is Hamster #"</font> + hamsterNumber;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:HamsterMaze.java</font>
<font color=#009900>// Using an Iterator.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> HamsterMaze {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      list.add(<font color=#0000ff>new</font> Hamster(i));
    Printer.printAll(list.iterator());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"This is Hamster #0"</font>,
      <font color=#004488>"This is Hamster #1"</font>,
      <font color=#004488>"This is Hamster #2"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You could write <b>printAll(&#160;) </b>to accept a <b>Collection</b> object instead of an <b>Iterator</b>, but the latter provides better decoupling. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0499" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading11561"></a>Unintended recursion</h4>
<p>Because (like every other class) the Java standard containers are inherited from <a name="Index1051"></a><b>Object</b>, they<b> </b>contain a <b>toString(&#160;)</b> method. This has been overridden so that they can produce a <b>String</b> representation of themselves, including the objects they hold. Inside <b>ArrayList</b>, for example, the <b>toString(&#160;)</b> steps through the elements of the <b>ArrayList</b> and calls <b>toString(&#160;)</b> for each one. Suppose you&#146;d like to print the address of your class. It seems to make sense to simply refer to <b>this </b>(in particular, C++ programmers are prone to this approach):<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:InfiniteRecursion.java</font>
<font color=#009900>// Accidental recursion.</font>
<font color=#009900>// {RunByHand}</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InfiniteRecursion {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>" InfiniteRecursion address: "</font> + <font color=#0000ff>this</font> + <font color=#004488>"\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List v = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      v.add(<font color=#0000ff>new</font> InfiniteRecursion());
    System.out.println(v);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>If you simply create an <b>InfiniteRecursion</b> object and then print it, you&#146;ll get an endless sequence of exceptions. This is also true if you place the <b>InfiniteRecursion</b> objects in an <b>ArrayList</b> and print that <b>ArrayList</b> as shown here. What&#146;s happening is automatic type conversion for <b>String</b>s. When you say: <br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#004488>"InfiniteRecursion address: "</font> + <font color=#0000ff>this</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The compiler sees a <b>String</b> followed by a &#145;<b>+</b>&#146; and<b> </b>something that&#146;s not a <b>String</b>, so it tries to convert <b>this</b> to a <b>String</b>. It does this conversion by calling <b>toString(&#160;)</b>, which produces a recursive call. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1336" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1052"></a>If you really do want to print the address of the object in this case, the solution is to call the <b>Object</b> <b>toString(&#160;)</b> method, which does just that. So instead of saying <b>this</b>, you&#146;d say <b>super.toString(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1337" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545359"></a><a name="_Toc24775752"></a><a name="Heading11585"></a>Container
taxonomy</h2>
<p><b>Collection</b>s and <b>Map</b>s may be implemented in different ways according to your programming needs. It&#146;s helpful to look at a diagram of the Java containers (as of JDK 1.4):<br></p>
<p align="center"><img src="TIJ325.png" 	alt="TIJ325.png" border="0" ><br></p>
<p>This diagram can be a bit overwhelming at first, but you&#146;ll see that there are really only three container components&#151;<b>Map</b>, <b>List</b>, and <b>Set</b>&#151;and only two or three implementations of each one. The containers that you will generally use most of the time have heavy black lines around them. When you see this, the containers are not so daunting. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]CHAP09_1338" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The dotted boxes represent <b>interface</b>s, the dashed boxes represent <b>abstract</b> classes, and the solid boxes are regular (concrete) classes. The dotted-line arrows indicate that a particular class is implementing an <b>interface</b> (or in the case of an <b>abstract</b> class, partially implementing that <b>interface</b>). The solid arrows show that a class can produce objects of the class the arrow is pointing to. For example, any <b>Collection</b> can produce an <b>Iterator</b> and a <b>List</b> can produce a <b>ListIterator</b> (as well as an ordinary <b>Iterator</b>, since <b>List</b> is inherited from <b>Collection</b>). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1339" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The interfaces that are concerned with holding objects are <b>Collection</b>, <b>List</b>, <b>Set</b>, and <b>Map</b>.<b> </b>Ideally, you&#146;ll write most of your code to talk to these interfaces, and the only place where you&#146;ll specify the precise type you&#146;re using is at the point of creation. So you can create a <b>List</b> like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1340" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>List x = <font color=#0000ff>new</font> LinkedList();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Of course, you can also decide to make <b>x </b>a <b>LinkedList </b>(instead of a generic <b>List</b>)<b> </b>and carry the precise type information around with <b>x</b>. The beauty (and the intent) of using the <b>interface</b> is that if you decide you want to change your implementation, all you need to do is change it at the point of creation, like this:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>List x = <font color=#0000ff>new</font> ArrayList();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The rest of your code can remain untouched (some of this genericity can also be achieved with iterators). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1341" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the class hierarchy, you can see a number of classes whose names begin with &#147;<b>Abstract</b>,&#148; and these can seem a bit confusing at first. They are simply tools that partially implement a particular interface. If you were making your own <b>Set</b>, for example, you wouldn&#146;t start with the <b>Set</b> interface and implement all the methods; instead, you&#146;d inherit from <a name="Index1053"></a><b>AbstractSet</b> and do the minimal necessary work to make your new class. However, the containers library contains enough functionality to satisfy your needs virtually all the time. So for our purposes, you can ignore any class that begins with &#147;<b>Abstract</b>.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1342" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Therefore, when you look at the diagram, you&#146;re really concerned with only those <b>interface</b>s at the top of the diagram and the concrete classes (those with solid boxes around them). You&#146;ll typically make an object of a concrete class, upcast it to the corresponding <b>interface</b>, and then use the <b>interface</b> throughout the rest of your code. In addition, you do not need to consider the legacy elements when writing new code. Therefore, the diagram can be greatly simplified to look like this:<br></p>
<p align="center"><img src="TIJ326.png" 	alt="TIJ326.png" border="0" ><br></p>
<p>Now it only includes the interfaces and classes that you will encounter on a regular basis, and also the elements that we will focus on in this chapter. Note that the <b>WeakHashMap </b>and the JDK 1.4 <b>IdentityHashMap </b>are not included on this diagram, because they are special-purpose tools that you will rarely use. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1343" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s a simple example that fills a <b>Collection</b> (represented here with an <b>ArrayList</b>) with <b>String</b> objects and then prints each element in the <b>Collection</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SimpleCollection.java</font>
<font color=#009900>// A simple example using Java 2 Collections.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleCollection {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Upcast because we just want to</font>
    <font color=#009900>// work with Collection features</font>
    Collection c = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      c.add(Integer.toString(i));
    Iterator it = c.iterator();
    <font color=#0000ff>while</font>(it.hasNext())
      System.out.println(it.next());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"0"</font>,
      <font color=#004488>"1"</font>,
      <font color=#004488>"2"</font>,
      <font color=#004488>"3"</font>,
      <font color=#004488>"4"</font>,
      <font color=#004488>"5"</font>,
      <font color=#004488>"6"</font>,
      <font color=#004488>"7"</font>,
      <font color=#004488>"8"</font>,
      <font color=#004488>"9"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The first line in <b>main(&#160;)</b> creates an <a name="Index1054"></a><b>ArrayList</b> object and then upcasts it to a <b>Collection</b>. Since this example uses only the <b>Collection </b>methods, any object of a class inherited from <b>Collection</b> would work, but <b>ArrayList</b> is the typical workhorse <b>Collection</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1344" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>add(&#160;)</b> method, as its name suggests, puts a new element in the <b>Collection</b>. However, the documentation carefully states that <b>add(&#160;)</b> &#147;ensures that this Container contains the specified element.&#148; This is to allow for the meaning of <b>Set</b>, which adds the element only if it isn&#146;t already there. With an <b>ArrayList</b>, or any sort of <b>List</b>, <b>add(&#160;)</b> always means &#147;put it in,&#148; because <b>List</b>s don&#146;t care if there are duplicates. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1345" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>All <b>Collection</b>s can produce an <a name="Index1055"></a><b>Iterator</b> via their <b>iterator(&#160;)</b> method. Here, an <b>Iterator</b> is created and used to traverse the <b>Collection</b>, printing each element. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1346" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775753"></a><a name="Heading11636"></a><b>Collection</b>
functionality</h2>
<p>The following table shows everything you can do with a <b>Collection</b> (not including the methods that automatically come through with <b>Object</b>), and thus, everything you can do with a <b>Set</b> or a <b>List</b>. (<b>List</b> also has additional functionality.) <b>Map</b>s are not inherited from <b>Collection</b> and will be treated separately.<br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>boolean add(Object)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Ensures that the container holds the argument. Returns false if it doesn&#146;t add the argument. (This is an &#147;optional&#148; method, described later in this chapter.)<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>boolean </b><br><b>addAll(Collection)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Adds all the elements in the argument. Returns <b>true</b> if any elements were added. (&#147;Optional.&#148;)<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>void clear(&#160;)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Removes all the elements in the container. (&#147;Optional.&#148;)<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>boolean </b><br><b>contains(Object)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>true</b> if the container holds the argument. <br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>boolean containsAll(Collection)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>true</b> if the container holds all the elements in the argument. <br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>boolean isEmpty(&#160;)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>true</b> if the container has no elements. <br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Iterator iterator(&#160;)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Returns an <b>Iterator</b> that you can use to move through the elements in the container. <br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>boolean </b><br><b>remove(Object)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">If the argument is in the container, one instance of that element is removed. Returns <b>true</b> if a removal occurred. (&#147;Optional.&#148;)<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>boolean removeAll(Collection)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Removes all the elements that are contained in the argument. Returns <b>true</b> if any removals occurred. (&#147;Optional.&#148;)<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>boolean retainAll(Collection)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Retains only elements that are contained in the argument (an &#147;intersection&#148; from set theory). Returns <b>true</b> if any changes occurred. (&#147;Optional.&#148;)<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>int size(&#160;)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Returns the number of elements in the container. <br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Object[] toArray(&#160;)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Returns an array containing all the elements in the container.<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Object[] </b><br><b>toArray(Object[] a)</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Returns an array containing all the elements in the container, whose type is that of the array a rather than plain <b>Object</b> (you must cast the array to the right type).<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">Notice that there&#146;s no <b>get(&#160;)</b> method for random-access element selection. That&#146;s because <b>Collection</b> also includes <b>Set</b>, which maintains its own internal ordering (and thus makes random-access lookup meaningless). Thus, if you want to examine the elements of a <b>Collection</b>, you must use an iterator.<br></p>
<p>The following example demonstrates all of these methods. Again, these work with anything that implements <b>Collection</b>, but an <b>ArrayList</b> is used as a kind of &#147;least-common denominator&#148;: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1347" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Collection1.java</font>
<font color=#009900>// Things you can do with all Collections.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Collection1 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, Collections2.countries, 5);
    c.add(<font color=#004488>"ten"</font>);
    c.add(<font color=#004488>"eleven"</font>);
    System.out.println(c);
    <font color=#009900>// Make an array from the List:</font>
    Object[] array = c.toArray();
    <font color=#009900>// Make a String array from the List:</font>
    String[] str = (String[])c.toArray(<font color=#0000ff>new</font> String[1]);
    <font color=#009900>// Find max and min elements; this means</font>
    <font color=#009900>// different things depending on the way</font>
    <font color=#009900>// the Comparable interface is implemented:</font>
    System.out.println(<font color=#004488>"Collections.max(c) = "</font> +
      Collections.max(c));
    System.out.println(<font color=#004488>"Collections.min(c) = "</font> +
      Collections.min(c));
    <font color=#009900>// Add a Collection to another Collection</font>
    Collection c2 = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c2, Collections2.countries, 5);
    c.addAll(c2);
    System.out.println(c);
    c.remove(CountryCapitals.pairs[0][0]);
    System.out.println(c);
    c.remove(CountryCapitals.pairs[1][0]);
    System.out.println(c);
    <font color=#009900>// Remove all components that are</font>
    <font color=#009900>//  in the argument collection:</font>
    c.removeAll(c2);
    System.out.println(c);
    c.addAll(c2);
    System.out.println(c);
    <font color=#009900>// Is an element in this Collection?</font>
    String val = CountryCapitals.pairs[3][0];
    System.out.println(<font color=#004488>"c.contains("</font> + val  + <font color=#004488>") = "</font>
      + c.contains(val));
    <font color=#009900>// Is a Collection in this Collection?</font>
    System.out.println(
      <font color=#004488>"c.containsAll(c2) = "</font> + c.containsAll(c2));
    Collection c3 = ((List)c).subList(3, 5);
    <font color=#009900>// Keep all the elements that are in both</font>
    <font color=#009900>// c2 and c3 (an intersection of sets):</font>
    c2.retainAll(c3);
    System.out.println(c);
    <font color=#009900>// Throw away all the elements</font>
    <font color=#009900>// in c2 that also appear in c3:</font>
    c2.removeAll(c3);
    System.out.println(<font color=#004488>"c.isEmpty() = "</font> +  c.isEmpty());
    c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, Collections2.countries, 5);
    System.out.println(c);
    c.clear(); <font color=#009900>// Remove all elements</font>
    System.out.println(<font color=#004488>"after c.clear():"</font>);
    System.out.println(c);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"[ALGERIA, ANGOLA, BENIN, BOTSWANA, BURKINA FASO, "</font> +
        <font color=#004488>"ten, eleven]"</font>,
      <font color=#004488>"Collections.max(c) = ten"</font>,
      <font color=#004488>"Collections.min(c) = ALGERIA"</font>,
      <font color=#004488>"[ALGERIA, ANGOLA, BENIN, BOTSWANA, BURKINA FASO, "</font> +
      <font color=#004488>"ten, eleven, BURUNDI, CAMEROON, CAPE VERDE, "</font> +
      <font color=#004488>"CENTRAL AFRICAN REPUBLIC, CHAD]"</font>,
      <font color=#004488>"[ANGOLA, BENIN, BOTSWANA, BURKINA FASO, ten, "</font> +
      <font color=#004488>"eleven, BURUNDI, CAMEROON, CAPE VERDE, "</font> +
      <font color=#004488>"CENTRAL AFRICAN REPUBLIC, CHAD]"</font>,
      <font color=#004488>"[BENIN, BOTSWANA, BURKINA FASO, ten, eleven, "</font> +
      <font color=#004488>"BURUNDI, CAMEROON, CAPE VERDE, "</font> +
      <font color=#004488>"CENTRAL AFRICAN REPUBLIC, CHAD]"</font>,
      <font color=#004488>"[BENIN, BOTSWANA, BURKINA FASO, ten, eleven]"</font>,
      <font color=#004488>"[BENIN, BOTSWANA, BURKINA FASO, ten, eleven, "</font> +
      <font color=#004488>"BURUNDI, CAMEROON, CAPE VERDE, "</font> +
      <font color=#004488>"CENTRAL AFRICAN REPUBLIC, CHAD]"</font>,
      <font color=#004488>"c.contains(BOTSWANA) = true"</font>,
      <font color=#004488>"c.containsAll(c2) = true"</font>,
      <font color=#004488>"[BENIN, BOTSWANA, BURKINA FASO, ten, eleven, "</font> +
      <font color=#004488>"BURUNDI, CAMEROON, CAPE VERDE, "</font> +
      <font color=#004488>"CENTRAL AFRICAN REPUBLIC, CHAD]"</font>,
      <font color=#004488>"c.isEmpty() = false"</font>,
      <font color=#004488>"[COMOROS, CONGO, DJIBOUTI, EGYPT, "</font> +
      <font color=#004488>"EQUATORIAL GUINEA]"</font>,
      <font color=#004488>"after c.clear():"</font>,
      <font color=#004488>"[]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>ArrayList</b>s are created containing different sets of data and upcast to <b>Collection</b> objects, so it&#146;s clear that nothing other than the <b>Collection</b> interface is being used. <b>main(&#160;)</b> uses simple exercises to show all of the methods in <b>Collection</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1348" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The following sections describe the various implementations of <b>List</b>, <b>Set,</b> and <b>Map</b> and indicate in each case (with an asterisk) which one should be your default choice. You&#146;ll notice that the legacy classes <b>Vector</b>, <b>Stack</b>, and <b>Hashtable</b> are <i>not</i> included, because in all cases there are preferred classes within the Java 2 Containers. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1349" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775754"></a><a name="Heading11762"></a><b>List</b>
functionality<br></h2>
<p><a name="Index1056"></a><a name="Index1057"></a><a name="Index1058"></a><a name="Index1059"></a>The basic <b>List</b> is quite simple to use, as you&#146;ve seen so far with <b>ArrayList</b>. Although most of the time you&#146;ll just use <b>add(&#160;)</b> to insert objects, <b>get(&#160;)</b> to get them out one at a time, and <b>iterator(&#160;)</b> to get an <b>Iterator</b> for the sequence, there&#146;s also a set of other methods that can be useful. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1350" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In addition, there are actually two types of <b>List</b>: the basic <b>ArrayList</b>, which excels at randomly accessing elements, and the much more powerful <b>LinkedList</b>, which is not designed for fast random access, but has a much more general set of methods.<br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="107.999973" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>List</b> (interface)<br></p>
</td>
<td width="359.999910" colspan="1" rowspan="1" valign="top">
<p class="Table">Order is the most important feature of a <b>List</b>; it promises to maintain elements in a particular sequence. <b>List</b> adds a number of methods to <b>Collection</b> that allow insertion and removal of elements in the middle of a <b>List</b>. (This is recommended only for a <b>LinkedList</b>.) A <b>List</b> will produce a <b>ListIterator</b>, and by using this you can traverse the <b>List</b> in both directions, as well as insert and remove elements in the middle of the <b>List</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="107.999973" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>ArrayList</b>*<br></p>
</td>
<td width="359.999910" colspan="1" rowspan="1" valign="top">
<p class="Table">A <b>List</b> implemented with an array. Allows rapid random access to elements, but is slow when inserting and removing elements from the middle of a list. <b>ListIterator</b> should be used only for back-and-forth traversal of an <b>ArrayList</b>, but not for inserting and removing elements, which is expensive compared to <b>LinkedList</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="107.999973" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>LinkedList</b><br></p>
</td>
<td width="359.999910" colspan="1" rowspan="1" valign="top">
<p class="Table">Provides optimal sequential access, with inexpensive insertions and deletions from the middle of the <b>List</b>. Relatively slow for random access. (Use <b>ArrayList</b> instead.) Also has <b>addFirst(&#160;)</b>, <b>addLast(&#160;)</b>, <b>getFirst(&#160;)</b>, <b>getLast(&#160;)</b>, <b>removeFirst(&#160;)</b>, and <b>removeLast(&#160;)</b> (which are not defined in any interfaces or base classes) to allow it to be used as a stack, a queue, and a deque.<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">The methods in the following example each cover a different group of activities: things that every list can do (<b>basicTest(&#160;)</b>), moving around with an <b>Iterator</b> (<b>iterMotion(&#160;)</b>)<b> </b>versus changing things with an <b>Iterator</b> (<b>iterManipulation(&#160;)</b>), seeing the effects of <b>List</b> manipulation (<b>testVisual(&#160;)</b>), and operations available only to <b>LinkedList</b>s. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0127" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:List1.java</font>
<font color=#009900>// Things you can do with Lists.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> List1 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> List fill(List a) {
    Collections2.countries.reset();
    Collections2.fill(a, Collections2.countries, 10);
    <font color=#0000ff>return</font> a;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> b;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Object o;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Iterator it;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> ListIterator lit;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> basicTest(List a) {
    a.add(1, <font color=#004488>"x"</font>); <font color=#009900>// Add at location 1</font>
    a.add(<font color=#004488>"x"</font>); <font color=#009900>// Add at end</font>
    <font color=#009900>// Add a collection:</font>
    a.addAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Add a collection starting at location 3:</font>
    a.addAll(3, fill(<font color=#0000ff>new</font> ArrayList()));
    b = a.contains(<font color=#004488>"1"</font>); <font color=#009900>// Is it in there?</font>
    <font color=#009900>// Is the entire collection in there?</font>
    b = a.containsAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Lists allow random access, which is cheap</font>
    <font color=#009900>// for ArrayList, expensive for LinkedList:</font>
    o = a.get(1); <font color=#009900>// Get object at location 1</font>
    i = a.indexOf(<font color=#004488>"1"</font>); <font color=#009900>// Tell index of object</font>
    b = a.isEmpty(); <font color=#009900>// Any elements inside?</font>
    it = a.iterator(); <font color=#009900>// Ordinary Iterator</font>
    lit = a.listIterator(); <font color=#009900>// ListIterator</font>
    lit = a.listIterator(3); <font color=#009900>// Start at loc 3</font>
    i = a.lastIndexOf(<font color=#004488>"1"</font>); <font color=#009900>// Last match</font>
    a.remove(1); <font color=#009900>// Remove location 1</font>
    a.remove(<font color=#004488>"3"</font>); <font color=#009900>// Remove this object</font>
    a.set(1, <font color=#004488>"y"</font>); <font color=#009900>// Set location 1 to "y"</font>
    <font color=#009900>// Keep everything that's in the argument</font>
    <font color=#009900>// (the intersection of the two sets):</font>
    a.retainAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Remove everything that's in the argument:</font>
    a.removeAll(fill(<font color=#0000ff>new</font> ArrayList()));
    i = a.size(); <font color=#009900>// How big is it?</font>
    a.clear(); <font color=#009900>// Remove all elements</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> iterMotion(List a) {
    ListIterator it = a.listIterator();
    b = it.hasNext();
    b = it.hasPrevious();
    o = it.next();
    i = it.nextIndex();
    o = it.previous();
    i = it.previousIndex();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> iterManipulation(List a) {
    ListIterator it = a.listIterator();
    it.add(<font color=#004488>"47"</font>);
    <font color=#009900>// Must move to an element after add():</font>
    it.next();
    <font color=#009900>// Remove the element that was just produced:</font>
    it.remove();
    <font color=#009900>// Must move to an element after remove():</font>
    it.next();
    <font color=#009900>// Change the element that was just produced:</font>
    it.set(<font color=#004488>"47"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testVisual(List a) {
    System.out.println(a);
    List b = <font color=#0000ff>new</font> ArrayList();
    fill(b);
    System.out.print(<font color=#004488>"b = "</font>);
    System.out.println(b);
    a.addAll(b);
    a.addAll(fill(<font color=#0000ff>new</font> ArrayList()));
    System.out.println(a);
    <font color=#009900>// Insert, remove, and replace elements</font>
    <font color=#009900>// using a ListIterator:</font>
    ListIterator x = a.listIterator(a.size()/2);
    x.add(<font color=#004488>"one"</font>);
    System.out.println(a);
    System.out.println(x.next());
    x.remove();
    System.out.println(x.next());
    x.set(<font color=#004488>"47"</font>);
    System.out.println(a);
    <font color=#009900>// Traverse the list backwards:</font>
    x = a.listIterator(a.size());
    <font color=#0000ff>while</font>(x.hasPrevious())
      System.out.print(x.previous() + <font color=#004488>" "</font>);
    System.out.println();
    System.out.println(<font color=#004488>"testVisual finished"</font>);
  }
  <font color=#009900>// There are some things that only LinkedLists can do:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testLinkedList() {
    LinkedList ll = <font color=#0000ff>new</font> LinkedList();
    fill(ll);
    System.out.println(ll);
    <font color=#009900>// Treat it like a stack, pushing:</font>
    ll.addFirst(<font color=#004488>"one"</font>);
    ll.addFirst(<font color=#004488>"two"</font>);
    System.out.println(ll);
    <font color=#009900>// Like "peeking" at the top of a stack:</font>
    System.out.println(ll.getFirst());
    <font color=#009900>// Like popping a stack:</font>
    System.out.println(ll.removeFirst());
    System.out.println(ll.removeFirst());
    <font color=#009900>// Treat it like a queue, pulling elements</font>
    <font color=#009900>// off the tail end:</font>
    System.out.println(ll.removeLast());
    <font color=#009900>// With the above operations, it's a dequeue!</font>
    System.out.println(ll);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Make and fill a new list each time:</font>
    basicTest(fill(<font color=#0000ff>new</font> LinkedList()));
    basicTest(fill(<font color=#0000ff>new</font> ArrayList()));
    iterMotion(fill(<font color=#0000ff>new</font> LinkedList()));
    iterMotion(fill(<font color=#0000ff>new</font> ArrayList()));
    iterManipulation(fill(<font color=#0000ff>new</font> LinkedList()));
    iterManipulation(fill(<font color=#0000ff>new</font> ArrayList()));
    testVisual(fill(<font color=#0000ff>new</font> LinkedList()));
    testLinkedList();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In <b>basicTest(&#160;)</b> and <b>iterMotion(&#160;)</b> the calls are made in order to show the proper syntax, and although the return value is captured, it is not used. In some cases, the return value isn&#146;t captured at all. You should look up the full usage of each of these methods in the JDK documentation from <i>java.sun.com</i> before you use them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1351" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Remember that a container is only a storage cabinet to hold objects. If that cabinet solves all of your needs, it doesn&#146;t really matter how it is implemented (a basic concept with most types of objects). If you&#146;re working in a programming environment that has built-in overhead due to other factors, then the cost difference between an <b>ArrayList</b> and a <b>LinkedList</b> might not matter. You might need only one type of sequence. You can even imagine the &#147;perfect&#148; container abstraction, which can automatically change its underlying implementation according to the way it is used. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_185" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775755"></a><a name="Heading11900"></a>Making a stack from a
<b>LinkedList</b></h3>
<p>A stack is sometimes referred to as a &#147;last-in, first-out&#148; (LIFO) container. That is, whatever you &#147;push&#148; on the stack last is the first item you can &#147;pop&#148; out. Like all of the other containers in Java, what you push and pop are <a name="Index1060"></a><a name="Index1061"></a><b>Object</b>s, so you must cast what you pop, unless you&#146;re just using <b>Object</b> behavior. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1352" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>LinkedList</b> has methods that directly implement stack functionality, so you can also just use a <b>LinkedList</b> rather than making a stack class. However, a stack class can sometimes tell the story better: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1353" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:StackL.java</font>
<font color=#009900>// Making a stack from a LinkedList.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StackL {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> LinkedList list = <font color=#0000ff>new</font> LinkedList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> push(Object v) { list.addFirst(v); }
  <font color=#0000ff>public</font> Object top() { <font color=#0000ff>return</font> list.getFirst(); }
  <font color=#0000ff>public</font> Object pop() { <font color=#0000ff>return</font> list.removeFirst(); }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    StackL stack = <font color=#0000ff>new</font> StackL();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      stack.push(Collections2.countries.next());
    System.out.println(stack.top());
    System.out.println(stack.top());
    System.out.println(stack.pop());
    System.out.println(stack.pop());
    System.out.println(stack.pop());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"CHAD"</font>,
      <font color=#004488>"CHAD"</font>,
      <font color=#004488>"CHAD"</font>,
      <font color=#004488>"CENTRAL AFRICAN REPUBLIC"</font>,
      <font color=#004488>"CAPE VERDE"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>If you want only stack behavior, inheritance is inappropriate here because it would produce a class with all the rest of the <b>LinkedList</b> methods (you&#146;ll see later that this very mistake was made by the Java 1.0 library designers with <b>Stack</b>). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1354" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775756"></a><a name="Heading11935"></a>Making a queue from a
<b>LinkedList</b></h3>
<p>A <a name="Index1062"></a><i>queue</i> is a &#147;<i>first-in, first-out</i>&#148; (FIFO) container. That is, you put things in at one end and pull them out at the other. So the order in which you put them in will be the same order that they come out. <a name="Index1063"></a><a name="Index1064"></a><b>LinkedList</b> has methods to support queue behavior, so these can be used in a <b>Queue</b> class: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0128" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Queue.java</font>
<font color=#009900>// Making a queue from a LinkedList.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Queue {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> LinkedList list = <font color=#0000ff>new</font> LinkedList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> put(Object v) { list.addFirst(v); }
  <font color=#0000ff>public</font> Object get() { <font color=#0000ff>return</font> list.removeLast(); }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isEmpty() { <font color=#0000ff>return</font> list.isEmpty(); }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Queue queue = <font color=#0000ff>new</font> Queue();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      queue.put(Integer.toString(i));
    <font color=#0000ff>while</font>(!queue.isEmpty())
      System.out.println(queue.get());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"0"</font>,
      <font color=#004488>"1"</font>,
      <font color=#004488>"2"</font>,
      <font color=#004488>"3"</font>,
      <font color=#004488>"4"</font>,
      <font color=#004488>"5"</font>,
      <font color=#004488>"6"</font>,
      <font color=#004488>"7"</font>,
      <font color=#004488>"8"</font>,
      <font color=#004488>"9"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can also easily create a <i>deque</i> (double-ended queue) from a <b>LinkedList</b>. This is like a queue, but you can add and remove elements from either end. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1355" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775757"></a><a name="Heading11970"></a><b>Set</b>
functionality<br></h2>
<p><a name="Index1065"></a><b>Set</b> has exactly the same interface as <b>Collection</b>, so there isn&#146;t any extra functionality like there is with the two different <b>List</b>s. Instead, the <b>Set</b> is exactly a <b>Collection</b>&#151;it just has different behavior. (This is the ideal use of inheritance and polymorphism: to express different behavior.) A <b>Set</b> refuses to hold more than one instance of each object value (what constitutes the &#147;value&#148; of an object is more complex, as you shall see). <br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="137.333299" colspan="1" rowspan="1" valign="top">
<p class="Table"><a name="Index1066"></a><a name="Index1067"></a><a name="Index1068"></a><a name="Index1069"></a><a name="Index1070"></a><b>Set</b> (interface)<br></p>
</td>
<td width="329.333251" colspan="1" rowspan="1" valign="top">
<p class="Table">Each element that you add to the <b>Set</b> must be unique; otherwise, the <b>Set</b> doesn&#146;t add the duplicate element. <b>Object</b>s added to a <b>Set</b> must define <b>equals(&#160;)</b> to establish object uniqueness. <b>Set</b> has exactly the same interface as <b>Collection</b>. The <b>Set</b> interface does not guarantee that it will maintain its elements in any particular order.<br></p>
</td>
</tr>
<tr valign="top">
<td width="137.333299" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>HashSet</b>*<br></p>
</td>
<td width="329.333251" colspan="1" rowspan="1" valign="top">
<p class="Table">For <b>Set</b>s where fast lookup time is important. <b>Object</b>s must also define <b>hashCode(&#160;)</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="137.333299" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>TreeSet</b><br></p>
</td>
<td width="329.333251" colspan="1" rowspan="1" valign="top">
<p class="Table">An ordered <b>Set</b> backed by a tree. This way, you can extract an ordered sequence from a <b>Set</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="137.333299" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>LinkedHashSet</b><br>(JDK 1.4)<br></p>
</td>
<td width="329.333251" colspan="1" rowspan="1" valign="top">
<p class="Table">Has the lookup speed of a <b>HashSet</b>, but maintains the order in which you add the elements (the insertion order), internally using a linked list. Thus, when you iterate through the <b>Set</b>, the results appear in insertion order.<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">The following example does <i>not</i> show everything you can do with a <b>Set</b>, since the interface is the same as <b>Collection</b>, and so was exercised in the previous example. Instead, this demonstrates the behavior that makes a <b>Set</b> unique: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0129" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Set1.java</font>
<font color=#009900>// Things you can do with Sets.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Set1 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> fill(Set s) {
    s.addAll(Arrays.asList(
      <font color=#004488>"one two three four five six seven"</font>.split(<font color=#004488>" "</font>)));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Set s) {
    <font color=#009900>// Strip qualifiers from class name:</font>
    System.out.println(
      s.getClass().getName().replaceAll(<font color=#004488>"\\w+\\."</font>, <font color=#004488>""</font>));
    fill(s); fill(s); fill(s);
    System.out.println(s); <font color=#009900>// No duplicates!</font>
    <font color=#009900>// Add another set to this one:</font>
    s.addAll(s);
    s.add(<font color=#004488>"one"</font>);
    s.add(<font color=#004488>"one"</font>);
    s.add(<font color=#004488>"one"</font>);
    System.out.println(s);
    <font color=#009900>// Look something up:</font>
    System.out.println(<font color=#004488>"s.contains(\"</font>one\<font color=#004488>"): "</font> +
      s.contains(<font color=#004488>"one"</font>));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    test(<font color=#0000ff>new</font> HashSet());
    test(<font color=#0000ff>new</font> TreeSet());
    test(<font color=#0000ff>new</font> LinkedHashSet());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"HashSet"</font>,
      <font color=#004488>"[one, two, five, four, three, seven, six]"</font>,
      <font color=#004488>"[one, two, five, four, three, seven, six]"</font>,
      <font color=#004488>"s.contains(\"</font>one\<font color=#004488>"): true"</font>,
      <font color=#004488>"TreeSet"</font>,
      <font color=#004488>"[five, four, one, seven, six, three, two]"</font>,
      <font color=#004488>"[five, four, one, seven, six, three, two]"</font>,
      <font color=#004488>"s.contains(\"</font>one\<font color=#004488>"): true"</font>,
      <font color=#004488>"LinkedHashSet"</font>,
      <font color=#004488>"[one, two, three, four, five, six, seven]"</font>,
      <font color=#004488>"[one, two, three, four, five, six, seven]"</font>,
      <font color=#004488>"s.contains(\"</font>one\<font color=#004488>"): true"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Duplicate values are added to the <b>Set</b>, but when it is printed, you&#146;ll see that the <b>Set</b> has accepted only one instance of each value. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1356" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When you run this program, you&#146;ll notice that the order maintained by the <b>HashSet</b> is different from <b>TreeSet</b> and <b>LinkedHashSet</b>, since each has a different way of storing elements so they can be located later. (<b>TreeSet</b> keeps elements sorted into a red-black tree data structure, whereas <b>HashSet</b> uses a hashing function, which is designed specifically for rapid lookups. <b>LinkedHashSet</b> uses hashing internally for lookup speed, but <i>appears</i> to maintain elements in insertion order using a linked list.) When creating your own types, be aware that a <b>Set</b> needs a way to maintain a storage order, which means that you must implement the <b>Comparable </b>interface and define the <b>compareTo(&#160;) </b>method. Here&#146;s an example: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0130" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Set2.java</font>
<font color=#009900>// Putting your own type in a Set.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Set2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Set fill(Set a, <font color=#0000ff>int</font> size) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
      a.add(<font color=#0000ff>new</font> MyType(i));
    <font color=#0000ff>return</font> a;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Set a) {
    fill(a, 10);
    fill(a, 10); <font color=#009900>// Try to add duplicates</font>
    fill(a, 10);
    a.addAll(fill(<font color=#0000ff>new</font> TreeSet(), 10));
    System.out.println(a);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    test(<font color=#0000ff>new</font> HashSet());
    test(<font color=#0000ff>new</font> TreeSet());
    test(<font color=#0000ff>new</font> LinkedHashSet());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"[2 , 4 , 9 , 8 , 6 , 1 , 3 , 7 , 5 , 0 ]"</font>,
      <font color=#004488>"[9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]"</font>,
      <font color=#004488>"[0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><a name="Index1071"></a><a name="Index1072"></a>The form for the definitions for <a name="Index1073"></a><b>equals(&#160;)</b> and <b>hashCode(&#160;)</b> will be described later in this chapter. You must define an <b>equals(&#160;)</b> in both cases, but the <b>hashCode(&#160;)</b> is absolutely necessary only if the class will be placed in a <b>HashSet</b> (which is likely, since that should generally be your first choice as a <b>Set</b> implementation). However, as a programming style, you should always override <b>hashCode(&#160;)</b> when you override <b>equals(&#160;)</b>. This process will be fully detailed later in this chapter. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1357" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the <b>compareTo(&#160;)</b>, note that I did <i>not</i> use the &#147;simple and obvious&#148; form <b>return i-i2</b>. Although this is a common programming error, it would only work properly if <b>i</b> and <b>i2</b> were &#147;unsigned&#148;<b> int</b>s (if Java <i>had </i>an &#147;unsigned&#148; keyword, which it does not). It breaks for Java&#146;s signed <b>int</b>, which is not big enough to represent the difference of two signed <b>int</b>s. If <b>i</b> is a large positive integer and <b>j</b> is a large negative integer, <b>i-j</b> will overflow and return a negative value, which will not work. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1358" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775758"></a><a name="Heading12064"></a><b>SortedSet</b></h3>
<p>If you have a <b>SortedSet</b> (of which <b>TreeSet</b> is the only one available), the elements are guaranteed to be in sorted order, which allows additional functionality to be provided with these methods in the <b>SortedSet</b> interface: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1359" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p class="TabularText"><b>Comparator comparator(&#160;):</b> Produces the <b>Comparator</b> used for this <b>Set</b>, or <b>null</b> for natural ordering. <br></p>
<p class="TabularText"><b>Object first(&#160;):</b> Produces the lowest element. <br></p>
<p class="TabularText"><b>Object last(&#160;):</b> Produces the highest element. <br></p>
<p class="TabularText"><b>SortedSet subSet(fromElement, toElement):</b> Produces a view of this <b>Set</b> with elements from <b>fromElement</b>, inclusive, to <b>toElement</b>, exclusive. <br></p>
<p class="TabularText"><b>SortedSet headSet(toElement):</b> Produces a view of this <b>Set</b> with elements less than <b>toElement</b>. <br></p>
<p class="TabularText"><b>SortedSet tailSet(fromElement):</b> Produces a view of this <b>Set</b> with elements greater than or equal to <b>fromElement</b>.<br></p>
<p>Here&#146;s a simple demonstration:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SortedSetDemo.java</font>
<font color=#009900>// What you can do with a TreeSet.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SortedSetDemo {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SortedSet sortedSet = <font color=#0000ff>new</font> TreeSet(Arrays.asList(
    <font color=#004488>"one two three four five six seven eight"</font>.split(<font color=#004488>" "</font>)));
    System.out.println(sortedSet);
    Object
      low = sortedSet.first(),
      high = sortedSet.last();
    System.out.println(low);
    System.out.println(high);
    Iterator it = sortedSet.iterator();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt;= 6; i++) {
      <font color=#0000ff>if</font>(i == 3) low = it.next();
      <font color=#0000ff>if</font>(i == 6) high = it.next();
      <font color=#0000ff>else</font> it.next();
    }
    System.out.println(low);
    System.out.println(high);
    System.out.println(sortedSet.subSet(low, high));
    System.out.println(sortedSet.headSet(high));
    System.out.println(sortedSet.tailSet(low));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"[eight, five, four, one, seven, six, three, two]"</font>,
      <font color=#004488>"eight"</font>,
      <font color=#004488>"two"</font>,
      <font color=#004488>"one"</font>,
      <font color=#004488>"two"</font>,
      <font color=#004488>"[one, seven, six, three]"</font>,
      <font color=#004488>"[eight, five, four, one, seven, six, three]"</font>,
      <font color=#004488>"[one, seven, six, three, two]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Note that <b>SortedSet</b> means &#147;sorted according to the comparison function of the object,&#148; not &#147;insertion order.&#148;<br></p>
<h2>
<a name="_Toc24775759"></a><a name="Heading12114"></a><b>Map</b>
functionality<br></h2>
<p><a name="Index1074"></a><a name="Index1075"></a><a name="Index1076"></a>An <b>ArrayList</b> allows you to select from a sequence of objects using a number, so in a sense it associates numbers to objects. But what if you&#146;d like to select from a sequence of objects using some other criterion? A stack is an example. Its selection criterion is &#147;the last thing pushed on the stack.&#148; A powerful twist on this idea of &#147;selecting from a sequence&#148; is termed a <i>map</i>, a <a name="Index1077"></a><i>dictionary,</i> or an <a name="Index1078"></a><a name="Index1079"></a><i>associative array </i>(you saw a simple example of this in <b>AssociativeArray.java</b> in the previous chapter). Conceptually, it seems like an <b>ArrayList</b>, but instead of looking up objects using a number, you look them up using another object! This is a key technique in programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1360" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The concept shows up in Java as the <b>Map </b>interface. The <b>put(Object key, Object value)</b> method adds a value (the thing you want) and associates it with a key (the thing you look it up with). <b>get(Object key)</b> produces the value given the corresponding key. You can also test a <b>Map</b> to see if it contains a key or a value with <b>containsKey(&#160;)</b> and <b>containsValue(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1361" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The standard Java library contains different types of <b>Map</b>s: <b>HashMap</b>, <b>TreeMap</b>, <a name="Index1080"></a><b>LinkedHashMap</b>, <b>WeakHashMap</b>, and <b>IdentityHashMap</b>. The all have the same basic <b>Map </b>interface, but they differ in behaviors including efficiency, order in which the pairs are held and presented, how long the objects are held by the map, and how key equality is determined. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0500" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A big issue with maps is performance. If you look at what must be done for a <b>get(&#160;)</b>, it seems pretty slow to search through (for example) an <b>ArrayList</b> for the key. This is where <b>HashMap</b> speeds things up. Instead of a slow search for the key, it uses a special value called a <i>hash code</i>.<i> </i>The hash code is a way to take some information in the object in question and turn it into a &#147;relatively unique&#148; <b>int</b> for that object. All Java objects can produce a hash code, and <a name="Index1081"></a><b>hashCode(&#160;)</b> is a method in the root class <a name="Index1082"></a><b>Object</b>. A <b>HashMap </b>takes the <b>hashCode(&#160;)</b> of the object and uses it to quickly hunt for the key. This results in a dramatic performance improvement.<sup><a name="fnB58" href="#fn58">[58]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0131" title="Send BackTalk Comment">Feedback</a></font><br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="158.666627" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Map</b> (interface)<br></p>
</td>
<td width="302.666591" colspan="1" rowspan="1" valign="top">
<p class="Table">Maintains key-value associations (pairs) so you can look up a value using a key.<br></p>
</td>
</tr>
<tr valign="top">
<td width="158.666627" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>HashMap</b>*<br></p>
</td>
<td width="302.666591" colspan="1" rowspan="1" valign="top">
<p class="Table">Implementation based on a hash table. (Use this instead of <b>Hashtable</b>.) Provides constant-time performance for inserting and locating pairs. Performance can be adjusted via constructors that allow you to set the <i>capacity</i> and <i>load factor</i> of the hash table.<br></p>
</td>
</tr>
<tr valign="top">
<td width="158.666627" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>LinkedHashMap</b><br>(JDK 1.4)<br></p>
</td>
<td width="302.666591" colspan="1" rowspan="1" valign="top">
<p class="Table">Like a <b>HashMap</b>, but when you iterate through it, you get the pairs in insertion order, or in least-recently-used (LRU) order. Only slightly slower than a <b>HashMap</b>, except when iterating, where it is faster due to the linked list used to maintain the internal ordering.<br></p>
</td>
</tr>
<tr valign="top">
<td width="158.666627" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>TreeMap</b><br></p>
</td>
<td width="302.666591" colspan="1" rowspan="1" valign="top">
<p class="Table">Implementation based on a red-black tree. When you view the keys or the pairs, they will be in sorted order (determined by <b>Comparable</b> or <b>Comparator</b>, discussed later). The point of a <b>TreeMap</b> is that you get the results in sorted order. <b>TreeMap</b> is the only <b>Map</b> with the <b>subMap(&#160;)</b> method, which allows you to return a portion of the tree.<br></p>
</td>
</tr>
<tr valign="top">
<td width="158.666627" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>WeakHashMap</b><br></p>
</td>
<td width="302.666591" colspan="1" rowspan="1" valign="top">
<p class="Table">A map of <i>weak keys</i> that allow objects referred to by the map to be released; designed to solve certain types of problems. If no references outside the map are held to a particular key, it may be garbage collected.<br></p>
</td>
</tr>
<tr valign="top">
<td width="158.666627" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>IdentityHashMap</b><br>(JDK 1.4)<br></p>
</td>
<td width="302.666591" colspan="1" rowspan="1" valign="top">
<p class="Table">A hash map that uses <b>==</b> instead of <b>equals(&#160;)</b> to compare keys. Only for solving special types of problems; not for general use.<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">Hashing is the most commonly used way to store elements in a map. Sometimes you&#146;ll need to know the details of how hashing works, so we&#146;ll look at that a little later.<br></p>
<p>The following example uses the <b>Collections2.fill(&#160;)</b> method and the test data sets that were previously defined: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1362" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Map1.java</font>
<font color=#009900>// Things you can do with Maps.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Map1 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Collections2.StringPairGenerator geo =
    Collections2.geography;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Collections2.RandStringPairGenerator
    rsp = Collections2.rsp;
  <font color=#009900>// Producing a Set of the keys:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> printKeys(Map map) {
    System.out.print(<font color=#004488>"Size = "</font> + map.size() + <font color=#004488>", "</font>);
    System.out.print(<font color=#004488>"Keys: "</font>);
    System.out.println(map.keySet());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Map map) {
    <font color=#009900>// Strip qualifiers from class name:</font>
    System.out.println(
      map.getClass().getName().replaceAll(<font color=#004488>"\\w+\\."</font>, <font color=#004488>""</font>));
    Collections2.fill(map, geo, 25);
    <font color=#009900>// Map has 'Set' behavior for keys:</font>
    Collections2.fill(map, geo.reset(), 25);
    printKeys(map);
    <font color=#009900>// Producing a Collection of the values:</font>
    System.out.print(<font color=#004488>"Values: "</font>);
    System.out.println(map.values());
    System.out.println(map);
    String key = CountryCapitals.pairs[4][0];
    String value = CountryCapitals.pairs[4][1];
    System.out.println(<font color=#004488>"map.containsKey(\"</font>" + key +
      <font color=#004488>"\"</font>): " + map.containsKey(key));
    System.out.println(<font color=#004488>"map.get(\"</font><font color=#004488>" + key + "</font>\<font color=#004488>"): "</font>
      + map.get(key));
    System.out.println(<font color=#004488>"map.containsValue(\"</font>"
      + value + <font color=#004488>"\"</font>): " + map.containsValue(value));
    Map map2 = <font color=#0000ff>new</font> TreeMap();
    Collections2.fill(map2, rsp, 25);
    map.putAll(map2);
    printKeys(map);
    key = map.keySet().iterator().next().toString();
    System.out.println(<font color=#004488>"First key in map: "</font> + key);
    map.remove(key);
    printKeys(map);
    map.clear();
    System.out.println(<font color=#004488>"map.isEmpty(): "</font> + map.isEmpty());
    Collections2.fill(map, geo.reset(), 25);
    <font color=#009900>// Operations on the Set change the Map:</font>
    map.keySet().removeAll(map.keySet());
    System.out.println(<font color=#004488>"map.isEmpty(): "</font> + map.isEmpty());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    test(<font color=#0000ff>new</font> HashMap());
    test(<font color=#0000ff>new</font> TreeMap());
    test(<font color=#0000ff>new</font> LinkedHashMap());
    test(<font color=#0000ff>new</font> IdentityHashMap());
    test(<font color=#0000ff>new</font> WeakHashMap());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>printKeys(&#160;)</b> and <b>printValues(&#160;)</b> methods are not only useful utilities, they also demonstrate how to produce <b>Collection</b> views of a <b>Map</b>. The <b>keySet(&#160;)</b> method produces a <b>Set</b> backed by the keys in the <b>Map</b>. Similar treatment is given to <b>values(&#160;)</b>, which produces a <b>Collection</b> containing all the values in the <b>Map.</b> (Note that keys must be unique, but values may contain duplicates.) Since these <b>Collection</b>s are backed by the <b>Map</b>, any changes in a <b>Collection</b> will be reflected in the associated <b>Map</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1363" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The rest of the program provides simple examples of each <b>Map</b> operation and tests each type of <b>Map</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1364" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As an example of the use of a <b>HashMap</b>, consider a program to check the randomness of Java&#146;s <a name="Index1083"></a><a name="Index1084"></a><b>Random</b> class. Ideally, it would produce a perfect distribution of random numbers, but to test this you need to generate a bunch of random numbers and count the ones that fall in the various ranges. A <b>HashMap</b> is perfect for this, since it associates objects with objects (in this case, the value object contains the number produced by <b>Math.random(&#160;)</b> along with the number of times that number appears):<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Statistics.java</font>
<font color=#009900>// Simple demonstration of HashMap.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Counter {
  <font color=#0000ff>int</font> i = 1;
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> Integer.toString(i); }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Statistics {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random rand = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Map hm = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10000; i++) {
      <font color=#009900>// Produce a number between 0 and 20:</font>
      Integer r = <font color=#0000ff>new</font> Integer(rand.nextInt(20));
      <font color=#0000ff>if</font>(hm.containsKey(r))
        ((Counter)hm.get(r)).i++;
      <font color=#0000ff>else</font>
        hm.put(r, <font color=#0000ff>new</font> Counter());
    }
    System.out.println(hm);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In <b>main(&#160;)</b>, each time a random number is generated it is wrapped inside an <b>Integer</b> object so that reference can be used with the <b>HashMap</b>. (You can&#146;t use a primitive with a container&#151;only an object reference.) The <b>containsKey(&#160;)</b> method checks to see if this key is already in the container (that is, has the number been found already?). If so, the <a name="Index1085"></a><b>get(&#160;)</b> method produces the associated value for the key, which in this case is a <b>Counter</b> object. The value <b>i</b> inside the counter is incremented to indicate that one more of this particular random number has been found. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1365" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If the key has not been found yet, the method <a name="Index1086"></a><b>put(&#160;)</b> will place a new key-value pair into the <b>HashMap</b>. Since <b>Counter</b> automatically initializes its variable <b>i</b> to one when it&#146;s created, it indicates the first occurrence of this particular random number. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1366" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To display the <b>HashMap</b>, it is simply printed. The <b>HashMap</b> <b>toString(&#160;)</b> method moves through all the key-value pairs and calls the <b>toString(&#160;)</b> for each one. The <b>Integer.toString(&#160;)</b> is predefined, and you can see the <b>toString(&#160;)</b> for <b>Counter</b>. The output from one run (with some line breaks added) is:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>{15=529, 4=488, 19=518, 8=487, 11=501, 16=487, 18=507, 3=524, 7=474, 12=485, 17=493, 2=490, 13=540, 9=453, 6=512, 1=466, 14=522, 10=471, 5=522, 0=531} </PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You might wonder at the necessity of the class <b>Counter,</b> which seems like it doesn&#146;t even have the functionality of the wrapper class <b>Integer</b>. Why not use <b>int</b> or <b>Integer</b>? Well, you can&#146;t use an <b>int</b> because all of the containers can hold only<b> Object </b>references. After you&#146;ve seen containers, the wrapper classes might begin to make a little more sense to you, since you can&#146;t put any of the primitive types in containers. However, the only thing you <i>can</i> do with the Java wrappers is initialize them to a particular value and read that value. That is, there&#146;s no way to change a value once a wrapper object has been created. This makes the <a name="Index1087"></a><b>Integer</b> wrapper immediately useless to solve the problem, so we&#146;re forced to create a new class that does satisfy the need. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1367" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775760"></a><a name="Heading12228"></a><b>SortedMap</b></h3>
<p>If you have a <b>SortedMap</b> (of which <b>TreeMap</b> is the only one available), the keys are guaranteed to be in sorted order, which allows additional functionality to be provided with these methods in the <b>SortedMap</b> interface: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1368" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p class="TabularText"><b>Comparator comparator(&#160;):</b> Produces the comparator used for this <b>Map</b>, or <b>null</b> for natural ordering. <br></p>
<p class="TabularText"><b>Object firstKey(&#160;):</b> Produces the lowest key. <br></p>
<p class="TabularText"><b>Object lastKey(&#160;):</b> Produces the highest key. <br></p>
<p class="TabularText"><b>SortedMap subMap(fromKey, toKey):</b> Produces a view of this <b>Map</b> with keys from <b>fromKey</b>, inclusive, to <b>toKey</b>, exclusive. <br></p>
<p class="TabularText"><b>SortedMap headMap(toKey):</b> Produces a view of this <b>Map</b> with keys less than <b>toKey</b>. <br></p>
<p class="TabularText"><b>SortedMap tailMap(fromKey):</b> Produces a view of this <b>Map</b> with keys greater than or equal to <b>fromKey</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0132" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example that&#146;s similar to <b>SortedSetDemo.java</b> and shows this additional behavior of <b>TreeMap</b>s:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SimplePairGenerator.java</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#009900>//import java.util.*;</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimplePairGenerator <font color=#0000ff>implements</font> MapGenerator {
  <font color=#0000ff>public</font> Pair[] items = {
    <font color=#0000ff>new</font> Pair(<font color=#004488>"one"</font>, <font color=#004488>"A"</font>), <font color=#0000ff>new</font> Pair(<font color=#004488>"two"</font>, <font color=#004488>"B"</font>),
    <font color=#0000ff>new</font> Pair(<font color=#004488>"three"</font>, <font color=#004488>"C"</font>), <font color=#0000ff>new</font> Pair(<font color=#004488>"four"</font>, <font color=#004488>"D"</font>),
    <font color=#0000ff>new</font> Pair(<font color=#004488>"five"</font>, <font color=#004488>"E"</font>), <font color=#0000ff>new</font> Pair(<font color=#004488>"six"</font>, <font color=#004488>"F"</font>),
    <font color=#0000ff>new</font> Pair(<font color=#004488>"seven"</font>, <font color=#004488>"G"</font>), <font color=#0000ff>new</font> Pair(<font color=#004488>"eight"</font>, <font color=#004488>"H"</font>),
    <font color=#0000ff>new</font> Pair(<font color=#004488>"nine"</font>, <font color=#004488>"I"</font>), <font color=#0000ff>new</font> Pair(<font color=#004488>"ten"</font>, <font color=#004488>"J"</font>)
  };
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> index = -1;
  <font color=#0000ff>public</font> Pair next() {
    index = (index + 1) % items.length;
    <font color=#0000ff>return</font> items[index];
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> SimplePairGenerator gen =
    <font color=#0000ff>new</font> SimplePairGenerator();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SortedMapDemo.java</font>
<font color=#009900>// What you can do with a TreeMap.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SortedMapDemo {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    TreeMap sortedMap = <font color=#0000ff>new</font> TreeMap();
    Collections2.fill(
      sortedMap, SimplePairGenerator.gen, 10);
    System.out.println(sortedMap);
    Object
      low = sortedMap.firstKey(),
      high = sortedMap.lastKey();
    System.out.println(low);
    System.out.println(high);
    Iterator it = sortedMap.keySet().iterator();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt;= 6; i++) {
      <font color=#0000ff>if</font>(i == 3) low = it.next();
      <font color=#0000ff>if</font>(i == 6) high = it.next();
      <font color=#0000ff>else</font> it.next();
    }
    System.out.println(low);
    System.out.println(high);
    System.out.println(sortedMap.subMap(low, high));
    System.out.println(sortedMap.headMap(high));
    System.out.println(sortedMap.tailMap(low));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"{eight=H, five=E, four=D, nine=I, one=A, seven=G,"</font> +
      <font color=#004488>" six=F, ten=J, three=C, two=B}"</font>,
      <font color=#004488>"eight"</font>,
      <font color=#004488>"two"</font>,
      <font color=#004488>"nine"</font>,
      <font color=#004488>"ten"</font>,
      <font color=#004488>"{nine=I, one=A, seven=G, six=F}"</font>,
      <font color=#004488>"{eight=H, five=E, four=D, nine=I, "</font> +
      <font color=#004488>"one=A, seven=G, six=F}"</font>,
      <font color=#004488>"{nine=I, one=A, seven=G, six=F, "</font> +
      <font color=#004488>"ten=J, three=C, two=B}"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Here, the pairs are stored by key-sorted order. Because there is a sense of order in the <b>TreeMap</b>, the concept of &#147;location&#148; makes sense, so you can have first and last elements and submaps. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0501" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775761"></a><a name="Heading12304"></a><b>LinkedHashMap</b></h3>
<p>The <a name="Index1088"></a><a name="Index1089"></a><b>LinkedHashMap</b> hashes everything for speed, but also produces the pairs in insertion order during a traversal (<b>println(&#160;)</b> iterates through the map, so you see the results of traversal). In addition, a <b>LinkedHashMap</b> can be configured in the constructor to use a <i>least-recently-used</i> (LRU) algorithm based on accesses, so elements that haven&#146;t been accessed (and thus are candidates for removal) appear at the front of the list. This allows easy creation of programs that do periodic cleanup in order to save space. Here&#146;s a simple example showing both features: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0502" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:LinkedHashMapDemo.java</font>
<font color=#009900>// What you can do with a LinkedHashMap.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LinkedHashMapDemo {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    LinkedHashMap linkedMap = <font color=#0000ff>new</font> LinkedHashMap();
    Collections2.fill(
      linkedMap, SimplePairGenerator.gen, 10);
    System.out.println(linkedMap);
    <font color=#009900>// Least-recently used order:</font>
    linkedMap = <font color=#0000ff>new</font> LinkedHashMap(16, 0.75f, <font color=#0000ff>true</font>);
    Collections2.fill(
      linkedMap, SimplePairGenerator.gen, 10);
    System.out.println(linkedMap);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++) <font color=#009900>// Cause accesses:</font>
      linkedMap.get(SimplePairGenerator.gen.items[i].key);
    System.out.println(linkedMap);
    linkedMap.get(SimplePairGenerator.gen.items[0].key);
    System.out.println(linkedMap);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"{one=A, two=B, three=C, four=D, five=E, "</font> +
       <font color=#004488>"six=F, seven=G, eight=H, nine=I, ten=J}"</font>,
      <font color=#004488>"{one=A, two=B, three=C, four=D, five=E, "</font> +
       <font color=#004488>"six=F, seven=G, eight=H, nine=I, ten=J}"</font>,
      <font color=#004488>"{eight=H, nine=I, ten=J, one=A, two=B, "</font> +
       <font color=#004488>"three=C, four=D, five=E, six=F, seven=G}"</font>,
      <font color=#004488>"{eight=H, nine=I, ten=J, two=B, three=C, "</font> +
       <font color=#004488>"four=D, five=E, six=F, seven=G, one=A}"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see from the output that the pairs are indeed traversed in insertion order, even for the LRU version. However, after the first seven items (only) are accessed, the last three items move to the front of the list. Then, when &#147;<b>one</b>&#148; is accessed again, it moves to the back of the list. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0503" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775762"></a><a name="Heading12343"></a>Hashing and hash
codes<br></h3>
<p><a name="Index1090"></a><a name="Index1091"></a>In <b>Statistics.java</b>, a standard library class (<b>Integer</b>) was used as a key for the <b>HashMap</b>. It worked because it has all the necessary wiring to make it behave correctly as a key. But a common pitfall occurs with <b>HashMap</b>s when you create your own classes to be used as keys. For example, consider a weather predicting system that matches <b>Groundhog</b> objects to <b>Prediction</b> objects. It seems fairly straightforward&#151;you create the two classes, and use <b>Groundhog</b> as the key and <b>Prediction</b> as the value: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1369" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Groundhog.java</font>
<font color=#009900>// Looks plausible, but doesn't work as a HashMap key.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Groundhog {
  <font color=#0000ff>protected</font> <font color=#0000ff>int</font> number;
  <font color=#0000ff>public</font> Groundhog(<font color=#0000ff>int</font> n) { number = n; }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"Groundhog #"</font> + number;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Prediction.java</font>
<font color=#009900>// Predicting the weather with groundhogs.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Prediction {
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> shadow = Math.random() &gt; 0.5;
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>if</font>(shadow)
      <font color=#0000ff>return</font> <font color=#004488>"Six more weeks of Winter!"</font>;
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> <font color=#004488>"Early Spring!"</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SpringDetector.java</font>
<font color=#009900>// What will the weather be?</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.lang.reflect.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SpringDetector {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#009900>// Uses a Groundhog or class derived from Groundhog:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  detectSpring(Class groundHogClass) <font color=#0000ff>throws</font> Exception {
    Constructor ghog = groundHogClass.getConstructor(
      <font color=#0000ff>new</font> Class[] {<font color=#0000ff>int</font>.<font color=#0000ff>class</font>});
    Map map = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      map.put(ghog.newInstance(
        <font color=#0000ff>new</font> Object[]{ <font color=#0000ff>new</font> Integer(i) }), <font color=#0000ff>new</font> Prediction());
    System.out.println(<font color=#004488>"map = "</font> + map + <font color=#004488>"\n"</font>);
    Groundhog gh = (Groundhog)
      ghog.newInstance(<font color=#0000ff>new</font> Object[]{ <font color=#0000ff>new</font> Integer(3) });
    System.out.println(<font color=#004488>"Looking up prediction for "</font> + gh);
    <font color=#0000ff>if</font>(map.containsKey(gh))
      System.out.println((Prediction)map.get(gh));
    <font color=#0000ff>else</font>
      System.out.println(<font color=#004488>"Key not found: "</font> + gh);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    detectSpring(Groundhog.<font color=#0000ff>class</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% map = \\{(Groundhog #\\d="</font> +
      <font color=#004488>"(Early Spring!|Six more weeks of Winter!)"</font> +
      <font color=#004488>"(, )?){10}\\}"</font>,
      <font color=#004488>""</font>,
      <font color=#004488>"Looking up prediction for Groundhog #3"</font>,
      <font color=#004488>"Key not found: Groundhog #3"</font>
    });
    }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Each <b>Groundhog</b> is given an identity number, so you can look up a <b>Prediction</b> in the <b>HashMap</b> by saying, &#147;Give me the <b>Prediction </b>associated with <b>Groundhog</b> #3.&#148; The <b>Prediction</b> class contains a <b>boolean</b> that is initialized using <b>Math.random(&#160;)</b> and a <b>toString(&#160;)</b> that interprets the result for you. The <b>detectSpring(&#160;) </b>method is created using reflection to instantiate and use the <b>Class Groundhog</b> or any derived class. This will come in handy when we inherit a new type of <b>Groundhog</b> to solve the problem demonstrated here. A <b>HashMap</b> is filled with <b>Groundhog</b>s and their associated <b>Prediction</b>s. The <b>HashMap </b>is printed so that you can see it has been filled. Then a <b>Groundhog</b> with an identity number of 3 is used as a key to look up the prediction for <b>Groundhog</b> #3 (which you can see must be in the <b>Map</b>). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1370" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It seems simple enough, but it doesn&#146;t work. The problem is that <b>Groundhog</b> is inherited from the common root class <b>Object</b> (which is what happens if you don&#146;t specify a base class, thus all classes are ultimately inherited from <b>Object</b>). It is <b>Object</b>&#146;s <b>hashCode(&#160;)</b> method that is used to generate the hash code for each object, and by default it just uses the address of its object. Thus, the first instance of <b>Groundhog(3)</b> does <i>not</i> produce a hash code equal to the hash code for the second instance of <b>Groundhog(3)</b> that we tried to use as a lookup. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1371" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You might think that all you need to do is write an appropriate override for <a name="Index1092"></a><b>hashCode(&#160;)</b>. But it still won&#146;t work until you&#146;ve done one more thing: override the <a name="Index1093"></a><b>equals(&#160;)</b> that is also part of <b>Object</b>. <b>equals(&#160;)</b> is used by the <b>HashMap</b> when trying to determine if your key is equal to any of the keys in the table. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1372" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A proper <a name="Index1094"></a><b>equals(&#160;)</b> must satisfy the following five conditions: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0743" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>Reflexive: For any <b>x</b>, <b>x.equals(x)</b> should return <b>true</b>.
</li>
<li>Symmetric: For any <b>x</b> and <b>y</b>, <b>x.equals(y)</b> should return
<b>true</b> if and only if <b>y.equals(x)</b> returns <b>true</b>.</li>
<li>Transitive: For any <b>x</b>, <b>y</b>, and <b>z</b>, if <b>x.equals(y)</b>
returns <b>true</b> and <b>y.equals(z)</b> returns <b>true</b>, then
<b>x.equals(z)</b> should return <b>true</b>. </li>
<li>Consistent: For any <b>x</b> and <b>y</b>, multiple invocations of
<b>x.equals(y)</b> consistently return <b>true</b> or consistently return
<b>false</b>, provided no information used in equals comparisons on the object
is modified. </li>
<li>For any non-null <b>x</b>, <b>x.equals(null)</b> should return
<b>false</b>.</li></ol><p>Again, the default <b>Object.equals(&#160;)</b> simply compares object addresses, so one <b>Groundhog(3)</b> is not equal to another <b>Groundhog(3)</b>. Thus, to use your own classes as keys in a <b>HashMap</b>, you must override both <b>hashCode(&#160;)</b> and <b>equals(&#160;)</b>, as shown in the following solution to the groundhog problem:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Groundhog2.java</font>
<font color=#009900>// A class that's used as a key in a HashMap</font>
<font color=#009900>// must override hashCode() and equals().</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Groundhog2 <font color=#0000ff>extends</font> Groundhog {
  <font color=#0000ff>public</font> Groundhog2(<font color=#0000ff>int</font> n) { <font color=#0000ff>super</font>(n); }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { <font color=#0000ff>return</font> number; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> (o <font color=#0000ff>instanceof</font> Groundhog2)
      &amp;&amp; (number == ((Groundhog2)o).number);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SpringDetector2.java</font>
<font color=#009900>// A working key.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SpringDetector2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    SpringDetector.detectSpring(Groundhog2.<font color=#0000ff>class</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% map = \\{(Groundhog #\\d="</font> +
      <font color=#004488>"(Early Spring!|Six more weeks of Winter!)"</font> +
      <font color=#004488>"(, )?){10}\\}"</font>,
      <font color=#004488>""</font>,
      <font color=#004488>"Looking up prediction for Groundhog #3"</font>,
      <font color=#004488>"%% Early Spring!|Six more weeks of Winter!"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>Groundhog2.hashCode(&#160;)</b> returns the groundhog number as a hash value. In this example, the programmer is responsible for ensuring that no two groundhogs exist with the same ID number. The <b>hashCode(&#160;) </b>is not required to return a unique identifier (something you&#146;ll understand better later in this chapter), but the <b>equals(&#160;)</b> method must be able to strictly determine whether two objects are equivalent. Here, <b>equals(&#160;)</b> is based on the groundhog number, so if two <b>Groundhog2</b> objects exist as keys in the <b>HashMap </b>with the same groundhog number, it will fail. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1374" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Even though it appears that the <b>equals(&#160;)</b> method is only checking to see whether the argument is an instance of <b>Groundhog2</b> (using the <b>instanceof</b> keyword, which was explained in Chapter 10), the <b>instanceof</b> actually quietly does a second sanity check to see if the object is <b>null</b>, since <b>instanceof</b> produces <b>false</b> if the left-hand argument is <b>null</b>. Assuming it&#146;s the correct type and not <b>null</b>, the comparison is based on the actual <b>ghNumber</b>s. You can see from the output that the behavior is now correct. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1375" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When creating your own class to use in a <b>HashSet</b>, you must pay attention to the same issues as when it is used as a key in a <b>HashMap</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1376" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading12454"></a>Understanding <b>hashCode(&#160;)</b></h4>
<p>The preceding example is only a start toward solving the problem correctly. It shows that if you do not override <a name="Index1095"></a><b>hashCode(&#160;)</b> and <a name="Index1096"></a><b>equals(&#160;)</b> for your key, the hashed data structure (<b>HashSet</b>, <b>HashMap</b>, <b>LinkedHashSet</b>, or <b>LinkedHashMap</b>) will not be able to deal with your key properly. However, to get a good solution for the problem you need to understand what&#146;s going on inside the hashed data structure. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1377" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>First, consider the motivation behind hashing: you want to look up an object using another object. But you can accomplish this with a <a name="Index1097"></a><b>TreeSet</b> or <b>TreeMap</b>, too. It&#146;s also possible to implement your own <b>Map</b>. To do so, the <b>Map.entrySet(&#160;)</b> method must be supplied to produce a set of <b>Map.Entry</b> objects. <b>MPair</b> will be defined as the new type of <a name="Index1098"></a><b>Map.Entry</b>. In order for it to be placed in a <b>TreeSet</b>, it must implement <b>equals(&#160;)</b> and be <b>Comparable</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:MPair.java</font>
<font color=#009900>// A new type of Map.Entry.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MPair <font color=#0000ff>implements</font> Map.Entry, Comparable {
  <font color=#0000ff>private</font> Object key, value;
  <font color=#0000ff>public</font> MPair(Object k, Object v) {
    key = k;
    value = v;
  }
  <font color=#0000ff>public</font> Object getKey() { <font color=#0000ff>return</font> key; }
  <font color=#0000ff>public</font> Object getValue() { <font color=#0000ff>return</font> value; }
  <font color=#0000ff>public</font> Object setValue(Object v) {
    Object result = value;
    value = v;
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> key.equals(((MPair)o).key);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object rv) {
    <font color=#0000ff>return</font> ((Comparable)key).compareTo(((MPair)rv).key);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Notice that the comparisons are only interested in the keys, so duplicate values are perfectly acceptable. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0133" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The following example implements a <b>Map</b> using a pair of <b>ArrayLists</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1378" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SlowMap.java</font>
<font color=#009900>// A Map implemented with ArrayLists.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SlowMap <font color=#0000ff>extends</font> AbstractMap {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> List
    keys = <font color=#0000ff>new</font> ArrayList(),
    values = <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> Object put(Object key, Object value) {
    Object result = get(key);
    <font color=#0000ff>if</font>(!keys.contains(key)) {
      keys.add(key);
      values.add(value);
    } <font color=#0000ff>else</font>
      values.set(keys.indexOf(key), value);
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> Object get(Object key) {
    <font color=#0000ff>if</font>(!keys.contains(key))
      <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    <font color=#0000ff>return</font> values.get(keys.indexOf(key));
  }
  <font color=#0000ff>public</font> Set entrySet() {
    Set entries = <font color=#0000ff>new</font> HashSet();
    Iterator
      ki = keys.iterator(),
      vi = values.iterator();
    <font color=#0000ff>while</font>(ki.hasNext())
      entries.add(<font color=#0000ff>new</font> MPair(ki.next(), vi.next()));
    <font color=#0000ff>return</font> entries;
  }
  <font color=#0000ff>public</font> String toString() {
    StringBuffer s = <font color=#0000ff>new</font> StringBuffer(<font color=#004488>"{"</font>);
    Iterator
      ki = keys.iterator(),
      vi = values.iterator();
    <font color=#0000ff>while</font>(ki.hasNext()) {
      s.append(ki.next() + <font color=#004488>"="</font> + vi.next());
      <font color=#0000ff>if</font>(ki.hasNext()) s.append(<font color=#004488>", "</font>);
    }
    s.append(<font color=#004488>"}"</font>);
    <font color=#0000ff>return</font> s.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SlowMap m = <font color=#0000ff>new</font> SlowMap();
    Collections2.fill(m, Collections2.geography, 15);
    System.out.println(m);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"{ALGERIA=Algiers, ANGOLA=Luanda, BENIN=Porto-Novo,"</font>+
      <font color=#004488>" BOTSWANA=Gaberone, BURKINA FASO=Ouagadougou, "</font> +
      <font color=#004488>"BURUNDI=Bujumbura, CAMEROON=Yaounde, "</font> +
      <font color=#004488>"CAPE VERDE=Praia, CENTRAL AFRICAN REPUBLIC=Bangui,"</font>+
      <font color=#004488>" CHAD=N'djamena, COMOROS=Moroni, "</font> +
      <font color=#004488>"CONGO=Brazzaville, DJIBOUTI=Dijibouti, "</font> +
      <font color=#004488>"EGYPT=Cairo, EQUATORIAL GUINEA=Malabo}"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
The <b>put(&#160;)</b> method simply places the keys and values in corresponding <b>ArrayList</b>s. In <b>main(&#160;)</b>, a <b>SlowMap</b> is loaded and then printed to show that it works. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0134" title="Send BackTalk Comment">Feedback</a></font><p>This shows that it&#146;s not that hard to produce a new type of <b>Map</b>. But as the name suggests, a <b>SlowMap </b>isn&#146;t very fast, so you probably wouldn&#146;t use it if you had an alternative available. The problem is in the lookup of the key; there is no order, so a simple linear search is used, which is the slowest way to look something up. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1379" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The whole point of hashing is speed: Hashing allows the lookup to happen quickly. Since the bottleneck is in the speed of the key lookup, one of the solutions to the problem could be to keep the keys sorted and then use <b>Collections.binarySearch(&#160;)</b> to perform the lookup (an exercise at the end of this chapter will walk you through this process). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1380" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Hashing goes further by saying that all you want to do is to store the key <i>somewhere</i> so that it can be quickly found. As you&#146;ve seen in this chapter, the fastest structure in which to store a group of elements is an array, so that will be used for representing the key information (note carefully that I said &#147;key information,&#148; and not the key itself). Also seen in this chapter was the fact that an array, once allocated, cannot be resized, so we have a problem: We want to be able to store any number of values in the <b>Map</b>, but if the number of keys is fixed by the array size, how can this be? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1381" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The answer is that the array will not hold the keys. From the key object, a number will be derived that will index into the array. This number is the <a name="Index1099"></a><i>hash code</i>, produced by the <b>hashCode(&#160;)</b> method (in computer science parlance, this is the <a name="Index1100"></a><i>hash function</i>) defined in <b>Object</b> and presumably overridden by your class. To solve the problem of the fixed-size array, more than one key may produce the same index. That is, there may be <a name="Index1101"></a><i>collisions</i>. Because of this, it doesn&#146;t matter how big the array is; each key object will land somewhere in that array. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1382" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>So the process of looking up a value starts by computing the hash code and using it to index into the array. If you could guarantee that there were no collisions (which could be possible if you have a fixed number of values) then you&#146;d have a <a name="Index1102"></a><a name="Index1103"></a><i>perfect hashing function</i>, but that&#146;s a special case. In all other cases, collisions are handled by <a name="Index1104"></a><i>external chaining:</i> The array points not directly to a value, but instead to a list of values. These values are searched in a linear fashion using the <b>equals(&#160;)</b> method. Of course, this aspect of the search is much slower, but if the hash function is good, there will only be a few values in each slot. So instead of searching through the entire list, you quickly jump to a slot where you have to compare a few entries to find the value. This is much faster, which is why the <b>HashMap</b> is so quick. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1383" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Knowing the basics of hashing, it&#146;s possible to implement a simple hashed <b>Map</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SimpleHashMap.java</font>
<font color=#009900>// A demonstration hashed Map.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleHashMap <font color=#0000ff>extends</font> AbstractMap {
  <font color=#009900>// Choose a prime number for the hash table</font>
  <font color=#009900>// size, to achieve a uniform distribution:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> SZ = 997;
  <font color=#0000ff>private</font> LinkedList[] bucket = <font color=#0000ff>new</font> LinkedList[SZ];
  <font color=#0000ff>public</font> Object put(Object key, Object value) {
    Object result = <font color=#0000ff>null</font>;
    <font color=#0000ff>int</font> index = key.hashCode() % SZ;
    <font color=#0000ff>if</font>(index &lt; 0) index = -index;
    <font color=#0000ff>if</font>(bucket[index] == <font color=#0000ff>null</font>)
      bucket[index] = <font color=#0000ff>new</font> LinkedList();
    LinkedList pairs = bucket[index];
    MPair pair = <font color=#0000ff>new</font> MPair(key, value);
    ListIterator it = pairs.listIterator();
    <font color=#0000ff>boolean</font> found = <font color=#0000ff>false</font>;
    <font color=#0000ff>while</font>(it.hasNext()) {
      Object iPair = it.next();
      <font color=#0000ff>if</font>(iPair.equals(pair)) {
        result = ((MPair)iPair).getValue();
        it.set(pair); <font color=#009900>// Replace old with new</font>
        found = <font color=#0000ff>true</font>;
        <font color=#0000ff>break</font>;
      }
    }
    <font color=#0000ff>if</font>(!found)
      bucket[index].add(pair);
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> Object get(Object key) {
    <font color=#0000ff>int</font> index = key.hashCode() % SZ;
    <font color=#0000ff>if</font>(index &lt; 0) index = -index;
    <font color=#0000ff>if</font>(bucket[index] == <font color=#0000ff>null</font>) <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    LinkedList pairs = bucket[index];
    MPair match = <font color=#0000ff>new</font> MPair(key, <font color=#0000ff>null</font>);
    ListIterator it = pairs.listIterator();
    <font color=#0000ff>while</font>(it.hasNext()) {
      Object iPair = it.next();
      <font color=#0000ff>if</font>(iPair.equals(match))
        <font color=#0000ff>return</font> ((MPair)iPair).getValue();
    }
    <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
  }
  <font color=#0000ff>public</font> Set entrySet() {
    Set entries = <font color=#0000ff>new</font> HashSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; bucket.length; i++) {
      <font color=#0000ff>if</font>(bucket[i] == <font color=#0000ff>null</font>) <font color=#0000ff>continue</font>;
      Iterator it = bucket[i].iterator();
      <font color=#0000ff>while</font>(it.hasNext())
        entries.add(it.next());
    }
    <font color=#0000ff>return</font> entries;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SimpleHashMap m = <font color=#0000ff>new</font> SimpleHashMap();
    Collections2.fill(m, Collections2.geography, 25);
    System.out.println(m);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Because the &#147;slots&#148; in a hash table are often referred to as <i>buckets,</i> the array that represents the actual table is called <b>bucket</b>. To promote even distribution, the number of buckets is typically a prime number.<sup><a name="fnB59" href="#fn59">[59]</a></sup> Notice that it is an array of <b>LinkedList</b>, which automatically provides for collisions; each new item is simply added to the end of the list. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1384" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The return value of <b>put(&#160;)</b> is <b>null</b> or, if the key was already in the list, the old value associated with that key. The return value is <b>result</b>, which is initialized to <b>null</b>, but if a key is discovered in the list, then <b>result</b> is assigned to that key. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1385" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>For both <b>put(&#160;)</b> and <b>get(&#160;)</b>, the first thing that happens is that the <b>hashCode(&#160;)</b> is called for the key, and the result is forced to a positive number. Then it is forced to fit into the <b>bucket</b> array using the modulus operator and the size of the array. If that location is <b>null</b>, it means there are no elements that hash to that location, so a new <b>LinkedList</b> is created to hold the object that just did. However, the normal process is to look through the list to see if there are duplicates, and if there are, the old value is put into <b>result</b> and the new value replaces the old. The <b>found</b> flag keeps track of whether an old key-value pair was found and, if not, the new pair is appended to the end of the list. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1386" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In <b>get(&#160;)</b>, you&#146;ll see very similar code as that contained in <b>put(&#160;)</b>, but simpler. The index is calculated into the <b>bucket</b> array, and if a <b>LinkedList</b> exists, it is searched for a match. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1387" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>entrySet(&#160;)</b> must find and traverse all the lists, adding them to the result <b>Set</b>. Once this method has been created, the <b>Map</b> can be tested by filling it with values and then printing them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1388" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading12623"></a><b>HashMap</b> performance factors</h4>
<p>To understand the issues, some terminology is necessary:<br></p>
<p class="TabularText"><a name="Index1105"></a><b><i>Capacity</i></b><i>:</i> The number of buckets in the table.<br></p>
<p class="TabularText"><a name="Index1106"></a><b><i>Initial capacity</i></b><i>:</i> The number of buckets when the table is created. <b>HashMap</b> and <b>HashSet</b> have constructors that allow you to specify the initial capacity.<br></p>
<p class="TabularText"><a name="Index1107"></a><b><i>Size</i></b><i>:</i> The number of entries currently in the table.<br></p>
<p class="TabularText"><a name="Index1108"></a><b><i>Load factor</i></b><i>:</i> size/capacity. A load factor of 0 is an empty table, 0.5 is a half-full table, etc. A lightly loaded table will have few collisions and so is optimal for insertions and lookups (but will slow down the process of traversing with an iterator). <b>HashMap</b> and <b>HashSet</b> have constructors that allow you to specify the load factor, which means that when this load factor is reached, the container will automatically increase the capacity (the number of buckets) by roughly doubling it and will redistribute the existing objects into the new set of buckets (this is called <i>rehashing</i>). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0135" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The default load factor used by <b>HashMap </b>is 0.75 (it doesn&#146;t rehash until the table is &#190; full). This seems to be a good trade-off between time and space costs. A higher load factor decreases the space required by the table but increases the lookup cost, which is important because lookup is what you do most of the time (including both <b>get(&#160;)</b> and <b>put(&#160;)</b>). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1389" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you know that you&#146;ll be storing many entries in a <b>HashMap</b>, creating it with an appropriately large initial capacity will prevent the overhead of automatic rehashing.<sup><a name="fnB60" href="#fn60">[60]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1390" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775763"></a><a name="Heading12632"></a>Overriding
<b>hashCode(&#160;)</b></h3>
<p>Now that you understand what&#146;s involved in the function of the <b>HashMap</b>, the issues involved in writing a <a name="Index1109"></a><b>hashCode(&#160;)</b> will make more sense. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1391" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>First of all, you don&#146;t have control of the creation of the actual value that&#146;s used to index into the array of buckets. That is dependent on the capacity of the particular <b>HashMap</b> object, and that capacity changes depending on how full the container is, and what the load factor is. The value produced by your <b>hashCode(&#160;)</b> will be further processed in order to create the bucket index (in <b>SimpleHashMap</b>, the calculation is just a modulo by the size of the bucket array). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1392" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The most important factor in creating a <b>hashCode(&#160;)</b> is that, regardless of when <b>hashCode(&#160;)</b> is called, it produces the same value for a particular object every time it is called. If you end up with an object that produces one <b>hashCode(&#160;) </b>value when it is <b>put(&#160;)</b> into a <b>HashMap</b> and another during a <b>get(&#160;)</b>, you won&#146;t be able to retrieve the objects. So if your <b>hashCode(&#160;)</b> depends on mutable data in the object, the user must be made aware that changing the data will effectively produce a different key by generating a different <b>hashCode(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1393" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In addition, you will probably <i>not </i>want to generate a <b>hashCode(&#160;) </b>that is based on unique object information&#151;in particular, the value of <b>this</b> makes a bad <b>hashCode(&#160;) </b>because then you can&#146;t generate a new identical key to the one used to <b>put(&#160;) </b>the original key-value pair. This was the problem that occurred in <b>SpringDetector.java</b>, because the default implementation of <b>hashCode(&#160;) </b><i>does</i> use the object address. So you&#146;ll want to use information in the object that identifies the object in a meaningful way. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1394" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One example can be seen in the <b>String</b> class. <b>String</b>s have the special characteristic that if a program has several <b>String</b> objects that contain identical character sequences, then those <b>String</b> objects all map to the same memory (the mechanism for this is described in Appendix A). So it makes sense that the <b>hashCode(&#160;)</b> produced by two separate instances of <b>new String(&#147;hello&#148;)</b> should be identical. You can see this in the following program:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:StringHashCode.java</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StringHashCode {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Hello"</font>.hashCode());
    System.out.println(<font color=#004488>"Hello"</font>.hashCode());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"69609650"</font>,
      <font color=#004488>"69609650"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>hashCode(&#160;)</b> for <b>String</b> is clearly based on the contents of the <b>String</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1395" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>So for a <b>hashCode(&#160;)</b> to be effective, it must be fast and it must be meaningful; that is, it must generate a value based on the contents of the object. Remember that this value doesn&#146;t have to be unique&#151;you should lean toward speed rather than uniqueness&#151;but between <b>hashCode(&#160;)</b> and <b>equals(&#160;)</b>, the identity of the object must be completely resolved. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1396" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Because the <b>hashCode(&#160;)</b> is further processed before the bucket index is produced, the range of values is not important; it just needs to generate an <b>int</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1397" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There&#146;s one other factor: A good <b>hashCode(&#160;)</b> should result in an even distribution of values. If the values tend to cluster, then the <b>HashMap</b> or <b>HashSet </b>will be more heavily loaded in some areas and will not be as fast as it could be with an evenly distributed hashing function. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1398" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In <i>Effective Java</i> (Addison-Wesley 2001), Joshua Bloch gives a basic recipe for generating a decent <a name="Index1110"></a><b>hashCode(&#160;)</b>:<br></p>
<ol>
<li>Store some constant nonzero value, say 17, in an <b>int</b> variable called
<b>result</b>.</li>
<li>For each significant field <b>f</b> in your object (each field taken into
account by the <b>equals(&#160;)</b>, that is), calculate an <b>int</b> hash
code <b>c</b> for the
field:</li></ol><div style="position:relative; left: 36"><table border="1">
<tr valign="top">
<td width="155.999961" colspan="1" rowspan="1" valign="top">
<p align="center"><b>Field type</b><br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p align="center"><b>Calculation</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="155.999961" colspan="1" rowspan="1" valign="top">
<p><b>boolean</b><br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p><b>c = (f ? 0 : 1)</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="155.999961" colspan="1" rowspan="1" valign="top">
<p><b>byte, char, short, </b>or<b> int</b><br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p><b>c = (int)f</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="155.999961" colspan="1" rowspan="1" valign="top">
<p><b>long</b><br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p><b>c = (int)(f ^ (f &gt;&gt;&gt;32))</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="155.999961" colspan="1" rowspan="1" valign="top">
<p><b>float</b><br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p><b>c = Float.floatToIntBits(f);</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="155.999961" colspan="1" rowspan="1" valign="top">
<p><b>double</b><br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p><b>long l = Double.doubleToLongBits(f);</b><br><b>c = (int)(l ^ (l &gt;&gt;&gt; 32))</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="155.999961" colspan="1" rowspan="1" valign="top">
<p><b>Object, </b>where<b> equals(&#160;) </b>calls<b> equals(&#160;) </b>for<b> </b>this<b> </b>field<br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p><b>c = f.hashCode(&#160;)</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="155.999961" colspan="1" rowspan="1" valign="top">
<p>Array<br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p>Apply above rules to each element<br></p>
</td>
</tr>
</table></div>
<ol>
<li>Combine the hash code(s) computed above:<br><b>result = 37 * result +
c;</b></li>
<li>Return <b>result</b>.</li>
<li>Look at the resulting <b>hashCode(&#160;)</b> and make sure that equal
instances have equal hash
codes.</li></ol><p>Here&#146;s an example that follows these guidelines:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:CountedString.java</font>
<font color=#009900>// Creating a good hashCode().</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CountedString {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> List created = <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>private</font> String s;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> id = 0;
  <font color=#0000ff>public</font> CountedString(String str) {
    s = str;
    created.add(s);
    Iterator it = created.iterator();
    <font color=#009900>// Id is the total number of instances</font>
    <font color=#009900>// of this string in use by CountedString:</font>
    <font color=#0000ff>while</font>(it.hasNext())
      <font color=#0000ff>if</font>(it.next().equals(s))
        id++;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"String: "</font> + s + <font color=#004488>" id: "</font> + id +
      <font color=#004488>" hashCode(): "</font> + hashCode();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() {
    <font color=#009900>// Very simple approach:</font>
    <font color=#009900>// return s.hashCode() * id;</font>
    <font color=#009900>// Using Joshua Bloch's recipe:</font>
    <font color=#0000ff>int</font> result = 17;
    result = 37*result + s.hashCode();
    result = 37*result + id;
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> (o <font color=#0000ff>instanceof</font> CountedString)
      &amp;&amp; s.equals(((CountedString)o).s)
      &amp;&amp; id == ((CountedString)o).id;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Map map = <font color=#0000ff>new</font> HashMap();
    CountedString[] cs = <font color=#0000ff>new</font> CountedString[10];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cs.length; i++) {
      cs[i] = <font color=#0000ff>new</font> CountedString(<font color=#004488>"hi"</font>);
      map.put(cs[i], <font color=#0000ff>new</font> Integer(i));
    }
    System.out.println(map);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cs.length; i++) {
      System.out.println(<font color=#004488>"Looking up "</font> + cs[i]);
      System.out.println(map.get(cs[i]));
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"{String: hi id: 4 hashCode(): 146450=3,"</font> +
      <font color=#004488>" String: hi id: 10 hashCode(): 146456=9,"</font> +
      <font color=#004488>" String: hi id: 6 hashCode(): 146452=5,"</font> +
      <font color=#004488>" String: hi id: 1 hashCode(): 146447=0,"</font> +
      <font color=#004488>" String: hi id: 9 hashCode(): 146455=8,"</font> +
      <font color=#004488>" String: hi id: 8 hashCode(): 146454=7,"</font> +
      <font color=#004488>" String: hi id: 3 hashCode(): 146449=2,"</font> +
      <font color=#004488>" String: hi id: 5 hashCode(): 146451=4,"</font> +
      <font color=#004488>" String: hi id: 7 hashCode(): 146453=6,"</font> +
      <font color=#004488>" String: hi id: 2 hashCode(): 146448=1}"</font>,
      <font color=#004488>"Looking up String: hi id: 1 hashCode(): 146447"</font>,
      <font color=#004488>"0"</font>,
      <font color=#004488>"Looking up String: hi id: 2 hashCode(): 146448"</font>,
      <font color=#004488>"1"</font>,
      <font color=#004488>"Looking up String: hi id: 3 hashCode(): 146449"</font>,
      <font color=#004488>"2"</font>,
      <font color=#004488>"Looking up String: hi id: 4 hashCode(): 146450"</font>,
      <font color=#004488>"3"</font>,
      <font color=#004488>"Looking up String: hi id: 5 hashCode(): 146451"</font>,
      <font color=#004488>"4"</font>,
      <font color=#004488>"Looking up String: hi id: 6 hashCode(): 146452"</font>,
      <font color=#004488>"5"</font>,
      <font color=#004488>"Looking up String: hi id: 7 hashCode(): 146453"</font>,
      <font color=#004488>"6"</font>,
      <font color=#004488>"Looking up String: hi id: 8 hashCode(): 146454"</font>,
      <font color=#004488>"7"</font>,
      <font color=#004488>"Looking up String: hi id: 9 hashCode(): 146455"</font>,
      <font color=#004488>"8"</font>,
      <font color=#004488>"Looking up String: hi id: 10 hashCode(): 146456"</font>,
      <font color=#004488>"9"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>CountedString</b> includes a <b>String</b> and an <b>id</b> that represents the number of <b>CountedString</b> objects that contain an identical <b>String</b>. The counting is accomplished in the constructor by iterating through the <b>static ArrayList</b> where all the <b>String</b>s are stored. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1399" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Both <b>hashCode(&#160;)</b> and <b>equals(&#160;)</b> produce results based on both fields; if they were just based on the <b>String</b> alone or the <b>id</b> alone, there would be duplicate matches for distinct values. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1400" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In <b>main(&#160;)</b>, a bunch of <b>CountedString</b> objects are created, using the same <b>String</b> to show that the duplicates create unique values because of the count <b>id</b>. The <b>HashMap</b> is displayed so that you can see how it is stored internally (no discernible orders), and then each key is looked up individually to demonstrate that the lookup mechanism is working properly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1402" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Writing a proper <b>hashCode(&#160;)</b> and <b>equals(&#160;)</b> for a new class can be tricky. You can find tools to help you do this in Apache&#146;s &#147;Jakarta Commons&#148; project at <i>jakarta.apache.org/commons</i>, under &#147;lang&#148; (this project also has many other potentially useful libraries, and appears to be the Java community&#146;s answer to the C++ community&#146;s <i>www.boost.org</i>).<br></p>
<h2>
<a name="_Toc24775764"></a><a name="Heading12769"></a>Holding references</h2>
<p>The <b>java.lang.ref</b> library contains a set of classes that allow greater flexibility in garbage collection. These classes are especially useful when you have large objects that may cause memory exhaustion. There are three classes inherited from the abstract class <a name="Index1111"></a><b>Reference</b>: <a name="Index1112"></a><b>SoftReference</b>,<b> </b><a name="Index1113"></a><b>WeakReference</b>, and<b> </b><a name="Index1114"></a><b>PhantomReference</b>. Each of these provides a different level of indirection for the garbage collector if the object in question is <i>only</i> reachable through one of these <b>Reference</b> objects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1403" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If an object is <a name="Index1115"></a><a name="Index1116"></a><i>reachable</i>, it means that somewhere in your program the object can be found. This could mean that you have an ordinary reference on the stack that goes right to the object, but you might also have a reference to an object that has a reference to the object in question; there could be many intermediate links. If an object is reachable, the garbage collector cannot release it because it&#146;s still in use by your program. If an object isn&#146;t reachable, there&#146;s no way for your program to use it, so it&#146;s safe to garbage collect that object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1404" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You use <b>Reference</b> objects when you want to continue to hold onto a reference to that object; you want to be able to reach that object, but you also want to allow the garbage collector to release that object. Thus, you have a way to go on using the object, but if memory exhaustion is imminent, you allow that object to be released. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1405" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1117"></a>You accomplish this by using a <b>Reference</b> object as an intermediary between you and the ordinary reference, <i>and</i> there must be no ordinary references to the object (ones that are not wrapped inside <b>Reference</b> objects). If the garbage collector discovers that an object is reachable through an ordinary reference, it will not release that object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1406" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the order of <b>SoftReference</b>,<b> WeakReference</b>, and<b> PhantomReference</b>, each one is &#147;weaker&#148; than the last and corresponds to a different level of reachability. Soft references are for implementing memory-sensitive caches. Weak references are for implementing &#147;canonicalizing mappings&#148;&#151;where instances of objects can be simultaneously used in multiple places in a program, to save storage&#151;that do not prevent their keys (or values) from being reclaimed. Phantom references are for scheduling premortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1407" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>With <b>SoftReference</b>s and<b> WeakReference</b>s, you have a choice about whether to place them on a <b>ReferenceQueue</b> (the device used for premortem cleanup actions), but a <b>PhantomReference</b> can only be built on a <b>ReferenceQueue</b>. Here&#146;s a simple demonstration: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0136" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:References.java</font>
<font color=#009900>// Demonstrates Reference objects</font>
<font color=#0000ff>import</font> java.lang.ref.*;

<font color=#0000ff>class</font> VeryBig {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> SZ = 10000;
  <font color=#0000ff>private</font> <font color=#0000ff>double</font>[] d = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[SZ];
  <font color=#0000ff>private</font> String ident;
  <font color=#0000ff>public</font> VeryBig(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing "</font> + ident);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> References {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> ReferenceQueue rq = <font color=#0000ff>new</font> ReferenceQueue();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> checkQueue() {
    Object inq = rq.poll();
    <font color=#0000ff>if</font>(inq != <font color=#0000ff>null</font>)
      System.out.println(<font color=#004488>"In queue: "</font> +
        (VeryBig)((Reference)inq).get());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 10;
    <font color=#009900>// Or, choose size via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      size = Integer.parseInt(args[0]);
    SoftReference[] sa = <font color=#0000ff>new</font> SoftReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sa.length; i++) {
      sa[i] = <font color=#0000ff>new</font> SoftReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Soft "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)sa[i].get());
      checkQueue();
    }
    WeakReference[] wa = <font color=#0000ff>new</font> WeakReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; wa.length; i++) {
      wa[i] = <font color=#0000ff>new</font> WeakReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Weak "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)wa[i].get());
      checkQueue();
    }
    SoftReference s =
      <font color=#0000ff>new</font> SoftReference(<font color=#0000ff>new</font> VeryBig(<font color=#004488>"Soft"</font>));
    WeakReference w =
      <font color=#0000ff>new</font> WeakReference(<font color=#0000ff>new</font> VeryBig(<font color=#004488>"Weak"</font>));
    System.gc();
    PhantomReference[] pa = <font color=#0000ff>new</font> PhantomReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pa.length; i++) {
      pa[i] = <font color=#0000ff>new</font> PhantomReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Phantom "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)pa[i].get());
      checkQueue();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>When you run this program (you&#146;ll want to pipe the output through a &#147;more&#148; utility so that you can view the output in pages), you&#146;ll see that the objects are garbage collected, even though you still have access to them through the <b>Reference</b> object (to get the actual object reference, you use <b>get(&#160;)</b>). You&#146;ll also see that the <b>ReferenceQueue</b> always produces a <b>Reference</b> containing a <b>null</b> object. To make use of this, you can inherit from the particular <b>Reference</b> class you&#146;re interested in and add more useful methods to the new type of <b>Reference</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1408" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775765"></a><a name="Heading12837"></a>The
<b>WeakHashMap</b></h3>
<p>The containers library has a special <b>Map</b> to hold weak references: the <a name="Index1118"></a><b>WeakHashMap</b>. This class is designed to make the creation of canonicalized mappings easier. In such a mapping, you are saving storage by making only one instance of a particular value. When the program needs that value, it looks up the existing object in the mapping and uses that (rather than creating one from scratch). The mapping may make the values as part of its initialization, but it&#146;s more likely that the values are made on demand. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1409" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Since this is a storage-saving technique, it&#146;s very convenient that the <b>WeakHashMap</b> allows the garbage collector to automatically clean up the keys and values. You don&#146;t have to do anything special to the keys and values you want to place in the <b>WeakHashMap</b>; these are automatically wrapped in <b>WeakReference</b>s by the map. The trigger to allow cleanup is if the key is no longer in use, as demonstrated here: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0137" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:CanonicalMapping.java</font>
<font color=#009900>// Demonstrates WeakHashMap.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.lang.ref.*;

<font color=#0000ff>class</font> Key {
  <font color=#0000ff>private</font> String ident;
  <font color=#0000ff>public</font> Key(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { <font color=#0000ff>return</font> ident.hashCode(); }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object r) {
    <font color=#0000ff>return</font> (r <font color=#0000ff>instanceof</font> Key)
      &amp;&amp; ident.equals(((Key)r).ident);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing Key "</font>+ ident);
  }
}

<font color=#0000ff>class</font> Value {
  <font color=#0000ff>private</font> String ident;
  <font color=#0000ff>public</font> Value(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing Value "</font> + ident);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CanonicalMapping {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 1000;
    <font color=#009900>// Or, choose size via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      size = Integer.parseInt(args[0]);
    Key[] keys = <font color=#0000ff>new</font> Key[size];
    WeakHashMap map = <font color=#0000ff>new</font> WeakHashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++) {
      Key k = <font color=#0000ff>new</font> Key(Integer.toString(i));
      Value v = <font color=#0000ff>new</font> Value(Integer.toString(i));
      <font color=#0000ff>if</font>(i % 3 == 0)
        keys[i] = k; <font color=#009900>// Save as "real" references</font>
      map.put(k, v);
    }
    System.gc();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>Key</b> class must have a <b>hashCode(&#160;)</b> and an <b>equals(&#160;)</b> since it is being used as a key in a hashed data structure, as described previously in this chapter. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1410" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When you run the program, you&#146;ll see that the garbage collector will skip every third key, because an ordinary reference to that key has also been placed in the <b>keys</b> array, and thus those objects cannot be garbage collected. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1411" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545358"></a><a name="_Toc24775766"></a><a name="Heading12889"></a>Iterators
revisited</h2>
<p>We can now demonstrate the true power of the <a name="Index1119"></a><b>Iterator</b>: the ability to separate the operation of traversing a sequence from the underlying structure of that sequence. The class <b>PrintData</b> (defined earlier in the chapter) uses an <b>Iterator</b> to move through a sequence and call the <a name="Index1120"></a><b>toString(&#160;)</b> method for every object. In the following example, two different types of containers are created&#151;an <a name="Index1121"></a><b>ArrayList</b> and a <a name="Index1122"></a><b>HashMap</b>&#151;and they are each filled with, respectively, <b>Mouse </b>and <b>Hamster </b>objects. (These classes are defined earlier in this chapter.) Because an <b>Iterator </b>hides the structure of the underlying container, <b>Printer.printAll(&#160;)</b> doesn&#146;t know or care what kind of container the <b>Iterator </b>comes from: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0138" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Iterators2.java</font>
<font color=#009900>// Revisiting Iterators.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Iterators2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      list.add(<font color=#0000ff>new</font> Mouse(i));
    Map m = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      m.put(<font color=#0000ff>new</font> Integer(i), <font color=#0000ff>new</font> Hamster(i));
    System.out.println(<font color=#004488>"List"</font>);
    Printer.printAll(list.iterator());
    System.out.println(<font color=#004488>"Map"</font>);
    Printer.printAll(m.entrySet().iterator());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"List"</font>,
      <font color=#004488>"This is Mouse #0"</font>,
      <font color=#004488>"This is Mouse #1"</font>,
      <font color=#004488>"This is Mouse #2"</font>,
      <font color=#004488>"This is Mouse #3"</font>,
      <font color=#004488>"This is Mouse #4"</font>,
      <font color=#004488>"Map"</font>,
      <font color=#004488>"4=This is Hamster #4"</font>,
      <font color=#004488>"3=This is Hamster #3"</font>,
      <font color=#004488>"2=This is Hamster #2"</font>,
      <font color=#004488>"1=This is Hamster #1"</font>,
      <font color=#004488>"0=This is Hamster #0"</font>
    }, Test.IGNORE_ORDER);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>For the <b>HashMap</b>, the <b>entrySet(&#160;)</b> method produces a <b>Set</b> of <b>Map.entry</b> objects, which contain both the key and the value for each entry, so you see both of them printed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1412" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that <b>PrintData.print(&#160;)</b> takes advantage of the fact that the objects in these containers are of class <b>Object</b> so the call <b>toString(&#160;)</b> by <b>System.out.println(&#160;) </b>is automatic. It&#146;s more likely that in your problem, you must make the assumption that your <b>Iterator</b> is walking through a container of some specific type. For example, you might assume that everything in the container is a <b>Shape</b> with a <b>draw(&#160;)</b> method. Then you must downcast from the <b>Object </b>that <b>Iterator.next(&#160;)</b> returns to produce a <b>Shape</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1413" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775767"></a><a name="Heading12928"></a>Choosing an
implementation</h2>
<p>By now you should understand that there are really only three container components: <b>Map</b>, <b>List</b>, and <b>Set</b>, but more than one implementation of each interface. If you need to use the functionality offered by a particular interface, how do you decide which implementation to use? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1414" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To understand the answer, you must be aware that each different implementation has its own features, strengths, and weaknesses. For example, you can see in the diagram that the &#147;feature&#148; of <b>Hashtable</b>, <b>Vector</b>, and <b>Stack</b> is that they are legacy classes, so that old code doesn&#146;t break. On the other hand, it&#146;s best if you don&#146;t use those for new code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1415" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The distinction between the other containers often comes down to what they are &#147;backed by&#148;; that is, the data structures that physically implement your desired <b>interface</b>. This means that, for example, <b>ArrayList</b> and<b> LinkedList </b>implement the <b>List</b> interface, so the basic operations are the same regardless of which one you use. However, <b>ArrayList</b> is backed by an array, and <b>LinkedList</b> is implemented in the usual way for a doubly linked list, as individual objects each containing data along with references to the previous and next elements in the list. Because of this, if you want to do many insertions and removals in the middle of a list, a <b>LinkedList</b> is the appropriate choice. (<b>LinkedList</b> also has additional functionality that is established in <a name="Index1123"></a><b>AbstractSequentialList</b>.) If not, an <b>ArrayList</b> is typically faster. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1416" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As another example, a <b>Set</b> can be implemented as either a <b>TreeSet</b>, a <b>HashSet</b>, or a <b>LinkedHashSet</b>. Each of these have different behaviors: <b>HashSet</b> is for typical use and provides raw speed on lookup, <b>LinkedHashSet</b> keeps pairs in insertion order, and <b>TreeSet</b> is backed by <b>TreeMap</b> and is designed to produce a constantly sorted set. The idea is that you can choose the implementation based on the behavior you need. Most of the time, the <b>HashSet </b>is all that&#146;s necessary and should be your default choice of <b>Set</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1417" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775768"></a><a name="Heading12933"></a>Choosing between
<b>List</b>s</h3>
<p>The most convincing way to see the differences between the implementations of <b>List</b> is with a performance test. The following code establishes an inner base class to use as a test framework, then creates an array of anonymous inner classes, one for each different test. Each of these inner classes is called by the <a name="Index1124"></a><a name="Index1125"></a><a name="Index1126"></a><b>test(&#160;)</b> method. This approach allows you to easily add and remove new kinds of tests. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0139" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ListPerformance.java</font>
<font color=#009900>// Demonstrates performance differences in Lists.</font>
<font color=#009900>// {Args: 500}</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> reps = 10000;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> quantity = reps / 10;
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    <font color=#0000ff>private</font> String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(List a);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"get"</font>) {
      <font color=#0000ff>void</font> test(List a) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; quantity; j++)
            a.get(j);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) {
      <font color=#0000ff>void</font> test(List a) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          Iterator it = a.iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"insert"</font>) {
      <font color=#0000ff>void</font> test(List a) {
        <font color=#0000ff>int</font> half = a.size()/2;
        String s = <font color=#004488>"test"</font>;
        ListIterator it = a.listIterator(half);
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps * 10; i++)
          it.add(s);
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"remove"</font>) {
      <font color=#0000ff>void</font> test(List a) {
        ListIterator it = a.listIterator(3);
        <font color=#0000ff>while</font>(it.hasNext()) {
          it.next();
          it.remove();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(List a) {
    <font color=#009900>// Strip qualifiers from class name:</font>
    System.out.println(<font color=#004488>"Testing "</font> +
      a.getClass().getName().replaceAll(<font color=#004488>"\\w+\\."</font>, <font color=#004488>""</font>));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      Collections2.fill(a, Collections2.countries.reset(),
        quantity);
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(a);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testArrayAsList(<font color=#0000ff>int</font> reps) {
    System.out.println(<font color=#004488>"Testing array as List"</font>);
    <font color=#009900>// Can only do first two tests on an array:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 2; i++) {
      String[] sa = <font color=#0000ff>new</font> String[quantity];
      Arrays2.fill(sa, Collections2.countries.reset());
      List a = Arrays.asList(sa);
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(a);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Choose a different number of</font>
    <font color=#009900>// repetitions via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    System.out.println(reps + <font color=#004488>" repetitions"</font>);
    testArrayAsList(reps);
    test(<font color=#0000ff>new</font> ArrayList());
    test(<font color=#0000ff>new</font> LinkedList());
    test(<font color=#0000ff>new</font> Vector());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>To provide a base class for the specific tests, the inner class <b>Tester</b> is <b>abstract</b>. It contains a <b>String</b> to be printed when the test starts and an <b>abstract</b> method <b>test(&#160;)</b> that does the work. All the different types of tests are collected in one place, the array <b>tests</b>, which is initialized with different anonymous inner classes that inherit from <b>Tester</b>. To add or remove tests, simply add or remove an inner class definition from the array, and everything else happens automatically. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1418" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To compare array access to container access (primarily against <b>ArrayList</b>), a special test is created for arrays by wrapping one as a <b>List</b> using <b>Arrays.asList(&#160;)</b>. Note that only the first two tests can be performed in this case, because you cannot insert or remove elements from an array. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1419" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>List</b> that&#146;s handed to <b>test(&#160;)</b> is first filled with elements, then each test in the <b>tests</b> array is timed. The results will vary from machine to machine; they are intended to give only an order of magnitude comparison between the performance of the different containers. Here is a summary of one run: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0140" title="Send BackTalk Comment">Feedback</a></font><br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="101.333308" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Type</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Get</b><br></p>
</td>
<td width="82.666646" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Iteration</b><br></p>
</td>
<td width="65.333317" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Insert</b><br></p>
</td>
<td width="77.333314" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Remove</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="101.333308" colspan="1" rowspan="1" valign="top">
<p class="Table">array<br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">172<br></p>
</td>
<td width="82.666646" colspan="1" rowspan="1" valign="top">
<p class="Table">516<br></p>
</td>
<td width="65.333317" colspan="1" rowspan="1" valign="top">
<p class="Table">na<br></p>
</td>
<td width="77.333314" colspan="1" rowspan="1" valign="top">
<p class="Table">na<br></p>
</td>
</tr>
<tr valign="top">
<td width="101.333308" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>ArrayList</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">281<br></p>
</td>
<td width="82.666646" colspan="1" rowspan="1" valign="top">
<p class="Table">1375<br></p>
</td>
<td width="65.333317" colspan="1" rowspan="1" valign="top">
<p class="Table">328<br></p>
</td>
<td width="77.333314" colspan="1" rowspan="1" valign="top">
<p class="Table">30484<br></p>
</td>
</tr>
<tr valign="top">
<td width="101.333308" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>LinkedList</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">5828<br></p>
</td>
<td width="82.666646" colspan="1" rowspan="1" valign="top">
<p class="Table">1047<br></p>
</td>
<td width="65.333317" colspan="1" rowspan="1" valign="top">
<p class="Table">109<br></p>
</td>
<td width="77.333314" colspan="1" rowspan="1" valign="top">
<p class="Table">16<br></p>
</td>
</tr>
<tr valign="top">
<td width="101.333308" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Vector</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">422<br></p>
</td>
<td width="82.666646" colspan="1" rowspan="1" valign="top">
<p class="Table">1890<br></p>
</td>
<td width="65.333317" colspan="1" rowspan="1" valign="top">
<p class="Table">360<br></p>
</td>
<td width="77.333314" colspan="1" rowspan="1" valign="top">
<p class="Table">30781<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">As expected, arrays are faster than any container for random-access lookups and iteration. You can see that random accesses (<b>get(&#160;)</b>) are cheap for <b>ArrayList</b>s and expensive for <b>LinkedList</b>s. (Oddly, iteration is <i>faster</i> for a <a name="Index1127"></a><b>LinkedList</b> than an <a name="Index1128"></a><b>ArrayList</b>, which is a bit counterintuitive.) On the other hand, insertions and removals from the middle of a list are dramatically cheaper for a <b>LinkedList</b> than for an <b>ArrayList</b>&#151;<i>especially</i> removals. <a name="Index1129"></a><b>Vector </b>is generally not as fast as <b>ArrayList</b>, and it should be avoided; it&#146;s only in the library for legacy code support (the only reason it works in this program is because it was adapted to be a <b>List</b> in Java 2).<b> </b>The best approach is probably to choose an <b>ArrayList</b> as your default and to change to a <b>LinkedList</b> if you discover performance problems due to many insertions and removals from the middle of the list. And of course, if you are working with a fixed-sized group of elements, use an array. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0141" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775769"></a><a name="Heading13056"></a>Choosing between
<b>Set</b>s</h3>
<p>You can choose a <a name="Index1130"></a><b>TreeSet</b>,<b> </b>a <a name="Index1131"></a><b>HashSet</b>, or a <b>LinkedHashSet </b>depending on the behavior you desire.<b> </b>The following test program gives an indication of the performance trade-off between the implementations: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1420" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SetPerformance.java</font>
<font color=#009900>// {Args: 500}</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SetPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> reps = 50000;
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"add"</font>) {
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          s.clear();
          Collections2.fill(s,
            Collections2.countries.reset(),size);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"contains"</font>) {
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++)
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; size; j++)
            s.contains(Integer.toString(j));
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) {
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps * 10; i++) {
          Iterator it = s.iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size) {
    <font color=#009900>// Strip qualifiers from class name:</font>
    System.out.println(<font color=#004488>"Testing "</font> +
      s.getClass().getName().replaceAll(<font color=#004488>"\\w+\\."</font>, <font color=#004488>""</font>) +
      <font color=#004488>" size "</font> + size);
    Collections2.fill(s,
      Collections2.countries.reset(), size);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(s, size);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> +
        ((<font color=#0000ff>double</font>)(t2 - t1)/(<font color=#0000ff>double</font>)size));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Choose a different number of</font>
    <font color=#009900>// repetitions via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    System.out.println(reps + <font color=#004488>" repetitions"</font>);
    <font color=#009900>// Small:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 10);
    test(<font color=#0000ff>new</font> HashSet(), 10);
    test(<font color=#0000ff>new</font> LinkedHashSet(), 10);
    <font color=#009900>// Medium:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 100);
    test(<font color=#0000ff>new</font> HashSet(), 100);
    test(<font color=#0000ff>new</font> LinkedHashSet(), 100);
    <font color=#009900>// Large:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 1000);
    test(<font color=#0000ff>new</font> HashSet(), 1000);
    test(<font color=#0000ff>new</font> LinkedHashSet(), 1000);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The following table shows the results of one run. (Of course, this will be different according to the computer and JVM you are using; you should run the test yourself as well):<br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Type</b><br></p>
</td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Test size</b><br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Add</b><br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Contains</b><br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Iteration</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">25.0<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">23.4<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">39.1<br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>TreeSet </b><br></p>
</td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">17.2<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">27.5<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">45.9<br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">26.0<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">30.2<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">9.0<br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">18.7<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">17.2<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">64.1<br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>HashSet </b><br></p>
</td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">17.2<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">19.1<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">65.2<br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">8.8<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">16.6<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">12.8<br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">20.3<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">18.7<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">64.1<br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>LinkedHashSet </b><br></p>
</td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">18.6<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">19.5<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">49.2<br></p>
</td>
</tr>
<tr valign="top">
<td width="130.666634" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="81.333313" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="49.333321" colspan="1" rowspan="1" valign="top">
<p class="Table">10.0<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">16.3<br></p>
</td>
<td width="83.999979" colspan="1" rowspan="1" valign="top">
<p class="Table">10.0<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">The performance of <b>HashSet</b> is generally superior to <b>TreeSet</b> for all operations (but in particular for addition and lookup, the two most important operations). The only reason <b>TreeSet</b> exists is because it maintains its elements in sorted order, so you use it only when you need a sorted <b>Set</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0142" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p class="TableFollower">Note that <a name="Index1132"></a><b>LinkedHashSet</b> is slightly more expensive for insertions than <b>HashSet</b>; this is because of the extra cost of maintaining the linked list along with the hashed container. However, traversal is cheaper with <b>LinkedHashSet</b> because of the linked list. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0504" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775770"></a><a name="Heading13187"></a>Choosing between
<b>Map</b>s</h3>
<p>When choosing between implementations of <a name="Index1133"></a><b>Map</b>, the size of the <b>Map</b> is what most strongly affects performance, and the following test program gives an indication of this trade-off: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1421" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:MapPerformance.java</font>
<font color=#009900>// Demonstrates performance differences in Maps.</font>
<font color=#009900>// {Args: 500}</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MapPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> reps = 50000;
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"put"</font>) {
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          m.clear();
          Collections2.fill(m,
            Collections2.geography.reset(), size);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"get"</font>) {
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++)
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; size; j++)
            m.get(Integer.toString(j));
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) {
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps * 10; i++) {
          Iterator it = m.entrySet().iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size) {
    <font color=#009900>// Strip qualifiers from class name:</font>
    System.out.println(<font color=#004488>"Testing "</font> +
      m.getClass().getName().replaceAll(<font color=#004488>"\\w+\\."</font>, <font color=#004488>""</font>) +
      <font color=#004488>" size "</font> + size);
    Collections2.fill(m,
      Collections2.geography.reset(), size);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(m, size);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> +
        ((<font color=#0000ff>double</font>)(t2 - t1)/(<font color=#0000ff>double</font>)size));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Choose a different number of</font>
    <font color=#009900>// repetitions via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    System.out.println(reps + <font color=#004488>" repetitions"</font>);
    <font color=#009900>// Small:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 10);
    test(<font color=#0000ff>new</font> HashMap(), 10);
    test(<font color=#0000ff>new</font> LinkedHashMap(), 10);
    test(<font color=#0000ff>new</font> IdentityHashMap(), 10);
    test(<font color=#0000ff>new</font> WeakHashMap(), 10);
    test(<font color=#0000ff>new</font> Hashtable(), 10);
    <font color=#009900>// Medium:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 100);
    test(<font color=#0000ff>new</font> HashMap(), 100);
    test(<font color=#0000ff>new</font> LinkedHashMap(), 100);
    test(<font color=#0000ff>new</font> IdentityHashMap(), 100);
    test(<font color=#0000ff>new</font> WeakHashMap(), 100);
    test(<font color=#0000ff>new</font> Hashtable(), 100);
    <font color=#009900>// Large:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 1000);
    test(<font color=#0000ff>new</font> HashMap(), 1000);
    test(<font color=#0000ff>new</font> LinkedHashMap(), 1000);
    test(<font color=#0000ff>new</font> IdentityHashMap(), 1000);
    test(<font color=#0000ff>new</font> WeakHashMap(), 1000);
    test(<font color=#0000ff>new</font> Hashtable(), 1000);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Because the size of the map is the issue, you&#146;ll see that the timing tests divide the time by the size to normalize each measurement. Here is one set of results. (Yours will probably be different.)<br></p>
<div align="center" style="position:relative; left: -25"><table border="1">
<tr valign="top">
<th width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Type </b><br></p>
</th>
<th width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Test size</b><br></p>
</th>
<th width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Put</b><br></p>
</th>
<th width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Get</b><br></p>
</th>
<th width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Iteration</b><br></p>
</th>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">26.6<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">20.3<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">43.7<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>TreeMap </b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">34.1<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">27.2<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">45.8<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">27.8<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">29.3<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">8.8<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b> </b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">21.9<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">18.8<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">60.9<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>HashMap</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">21.9<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">18.6<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">63.3<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">11.5<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">18.8<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">12.3<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b> </b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">23.4<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">18.8<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">59.4<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>LinkedHashMap</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">24.2<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">19.5<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">47.8<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">12.3<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">19.0<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">9.2<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b> </b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">20.3<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">25.0<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">71.9<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>IdentityHashMap</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">19.7<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">25.9<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">56.7<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">13.1<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">24.3<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">10.9<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b> </b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">26.6<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">18.8<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">76.5<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>WeakHashMap</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">26.1<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">21.6<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">64.4<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">14.7<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">19.2<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">12.4<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b> </b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">10<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">18.8<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">18.7<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">65.7<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Hashtable</b><br></p>
</td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">100<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">19.4<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">20.9<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">55.3<br></p>
</td>
</tr>
<tr valign="top">
<td width="153.333295" colspan="1" rowspan="1" valign="top">
<br></td>
<td width="59.999985" colspan="1" rowspan="1" valign="top">
<p class="Table">1000<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">13.1<br></p>
</td>
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p class="Table">19.9<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p class="Table">10.8<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">As you might expect, <a name="Index1134"></a><b>Hashtable</b> performance is roughly equivalent to <b>HashMap</b>. (You can also see that <b>HashMap</b> is generally a bit faster; <b>HashMap</b> is intended to replace <b>Hashtable</b>.) The <a name="Index1135"></a><b>TreeMap </b>is generally slower than the <b>HashMap</b>, so why would you use it? As a way to create an ordered list. The behavior of a tree is such that it&#146;s always in order and doesn&#146;t have to be specially sorted. Once you fill a <b>TreeMap</b>, you can call <a name="Index1136"></a><b>keySet(&#160;)</b> to get a <b>Set</b> view of the keys, then <a name="Index1137"></a><b>toArray(&#160;)</b> to produce an array of those keys. You can then use the <b>static </b>method <b>Arrays.binarySearch(&#160;)</b> (discussed later) to rapidly find objects in your sorted array. Of course, you would probably only do this if, for some reason, the behavior of a <b>HashMap</b> was unacceptable, since <b>HashMap </b>is designed to rapidly find things. Also, you can easily create a <b>HashMap </b>from a <b>TreeMap </b>with a single object creation. In the end, when you&#146;re using a <b>Map</b>,<b> </b>your first choice should be <b>HashMap</b>, and only if you need a constantly sorted <b>Map</b> will you need <b>TreeMap</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0143" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p class="TableFollower"><a name="Index1138"></a><b>LinkedHashMap</b> is slightly slower than <b>HashMap</b> because it maintains the linked list in addition to the hashed data structure. <b>IdentityHashMap</b> has different performance because it uses <b>==</b> rather than <b>equals(&#160;)</b> for comparisons. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0505" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775771"></a><a name="Heading13373"></a>Sorting and searching
<b>List</b>s<br></h2>
<p><a name="Index1139"></a><a name="Index1140"></a>Utilities to perform sorting and searching for <a name="Index1141"></a><b>List</b>s have the same names and signatures as those for sorting arrays of objects, but are <b>static </b>methods of <a name="Index1142"></a><b>Collections</b> instead of <b>Arrays</b>. Here&#146;s an example, modified from <b>ArraySearching.java</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ListSortSearch.java</font>
<font color=#009900>// Sorting and searching Lists with 'Collections.'</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListSortSearch {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list, Collections2.capitals, 25);
    System.out.println(list + <font color=#004488>"\n"</font>);
    Collections.shuffle(list);
    System.out.println(<font color=#004488>"After shuffling: "</font> + list);
    Collections.sort(list);
    System.out.println(list + <font color=#004488>"\n"</font>);
    Object key = list.get(12);
    <font color=#0000ff>int</font> index = Collections.binarySearch(list, key);
    System.out.println(<font color=#004488>"Location of "</font> + key +
      <font color=#004488>" is "</font> + index + <font color=#004488>", list.get("</font> +
      index + <font color=#004488>") = "</font> + list.get(index));
    AlphabeticComparator comp = <font color=#0000ff>new</font> AlphabeticComparator();
    Collections.sort(list, comp);
    System.out.println(list + <font color=#004488>"\n"</font>);
    key = list.get(12);
    index = Collections.binarySearch(list, key, comp);
    System.out.println(<font color=#004488>"Location of "</font> + key +
      <font color=#004488>" is "</font> + index + <font color=#004488>", list.get("</font> +
      index + <font color=#004488>") = "</font> + list.get(index));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The use of these methods is identical to the ones in <b>Arrays</b>, but you&#146;re using a <b>List</b> instead of an array. Just like searching and sorting with arrays, if you sort using a <b>Comparator</b>, you must <b>binarySearch(&#160;)</b> using the same <b>Comparator</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1422" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This program also demonstrates the <a name="Index1143"></a><b>shuffle(&#160;)</b> method in <b>Collections</b>, which randomizes the order of a <b>List</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1423" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775772"></a><a name="Heading13407"></a>Utilities</h2>
<p>There are a number of other useful utilities in the <b>Collections</b> class: <br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><a name="Index1144"></a><a name="Index1145"></a><b>max(Collection) </b><br></p>
<p class="Table"><b>min(Collection)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Produces the maximum or minimum element in the argument using the natural comparison method of the objects in the <b>Collection</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>max(Collection, Comparator) </b><br></p>
<p class="Table"><b>min(Collection, Comparator)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Produces the maximum or minimum element in the <b>Collection</b> using the <b>Comparator</b>. <br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>indexOfSubList(List source, List target)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Produces starting index of the <i>first</i> place where <b>target</b> appears inside <b>source</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>lastIndexOfSubList(List source, List target)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Produces starting index of the <i>last</i> place where <b>target</b> appears inside <b>source</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>replaceAll(List list, </b><br><b>Object oldVal, Object newVal)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Replace all <b>oldVal</b> with <b>newVal</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>reverse(&#160;)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Reverses all the elements in place.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>rotate(List list, int distance)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Moves all elements forward by <b>distance</b>, taking the ones off the end and placing them at the beginning.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>copy(List dest, List src)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Copies elements from <b>src</b> to <b>dest</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>swap(List list, int i, int j)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Swaps elements at locations <b>i</b> and <b>j</b> in <b>list</b>. Probably faster than what you&#146;d write by hand.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>fill(List list, Object o)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Replaces all the elements of list with <b>o</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>nCopies(int n, Object o) </b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Returns an immutable <b>List</b> of size n whose references all point to <b>o</b>. <br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>enumeration(Collection) </b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Produces an old-style <b>Enumeration</b> for the argument.<br></p>
</td>
</tr>
<tr valign="top">
<td width="245.333272" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>list(Enumeration e)</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Returns an <b>ArrayList</b> generated using the <b>Enumeration</b>. For converting from legacy code.<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">Note that <b>min(&#160;)</b> and <b>max(&#160;)</b> work with <b>Collection</b> objects, not with <b>List</b>s, so you don&#146;t need to worry about whether the <b>Collection</b> should be sorted or not. (As mentioned earlier, you <i>do</i> need to <b>sort(&#160;)</b> a <b>List</b> or an array before performing a <b>binarySearch(&#160;)</b>.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1424" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Utilities.java</font>
<font color=#009900>// Simple demonstrations of the Collections utilities.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Utilities {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = Arrays.asList(
      <font color=#004488>"one Two three Four five six one"</font>.split(<font color=#004488>" "</font>));
    System.out.println(list);
    System.out.println(<font color=#004488>"max: "</font> + Collections.max(list));
    System.out.println(<font color=#004488>"min: "</font> + Collections.min(list));
    AlphabeticComparator comp = <font color=#0000ff>new</font> AlphabeticComparator();
    System.out.println(<font color=#004488>"max w</font><font color=#004488>/ comparator: "</font> +
      Collections.max(list, comp));
    System.out.println(<font color=#004488>"min w</font><font color=#004488>/ comparator: "</font> +
      Collections.min(list, comp));
    List sublist =
      Arrays.asList(<font color=#004488>"Four five six"</font>.split(<font color=#004488>" "</font>));
    System.out.println(<font color=#004488>"indexOfSubList: "</font> +
      Collections.indexOfSubList(list, sublist));
    System.out.println(<font color=#004488>"lastIndexOfSubList: "</font> +
      Collections.lastIndexOfSubList(list, sublist));
    Collections.replaceAll(list, <font color=#004488>"one"</font>, <font color=#004488>"Yo"</font>);
    System.out.println(<font color=#004488>"replaceAll: "</font> + list);
    Collections.reverse(list);
    System.out.println(<font color=#004488>"reverse: "</font> + list);
    Collections.rotate(list, 3);
    System.out.println(<font color=#004488>"rotate: "</font> + list);
    List source =
      Arrays.asList(<font color=#004488>"in the matrix"</font>.split(<font color=#004488>" "</font>));
    Collections.copy(list, source);
    System.out.println(<font color=#004488>"copy: "</font> + list);
    Collections.swap(list, 0, list.size() - 1);
    System.out.println(<font color=#004488>"swap: "</font> + list);
    Collections.fill(list, <font color=#004488>"pop"</font>);
    System.out.println(<font color=#004488>"fill: "</font> + list);
    List dups = Collections.nCopies(3, <font color=#004488>"snap"</font>);
    System.out.println(<font color=#004488>"dups: "</font> + dups);
    <font color=#009900>// Getting an old-style Enumeration:</font>
    Enumeration e = Collections.enumeration(dups);
    Vector v = <font color=#0000ff>new</font> Vector();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      v.addElement(e.nextElement());
    <font color=#009900>// Converting an old-style Vector</font>
    <font color=#009900>// to a List via an Enumeration:</font>
    ArrayList arrayList = Collections.list(v.elements());
    System.out.println(<font color=#004488>"arrayList: "</font> + arrayList);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"[one, Two, three, Four, five, six, one]"</font>,
      <font color=#004488>"max: three"</font>,
      <font color=#004488>"min: Four"</font>,
      <font color=#004488>"max w</font><font color=#004488>/ comparator: Two"</font>,
      <font color=#004488>"min w</font><font color=#004488>/ comparator: five"</font>,
      <font color=#004488>"indexOfSubList: 3"</font>,
      <font color=#004488>"lastIndexOfSubList: 3"</font>,
      <font color=#004488>"replaceAll: [Yo, Two, three, Four, five, six, Yo]"</font>,
      <font color=#004488>"reverse: [Yo, six, five, Four, three, Two, Yo]"</font>,
      <font color=#004488>"rotate: [three, Two, Yo, Yo, six, five, Four]"</font>,
      <font color=#004488>"copy: [in, the, matrix, Yo, six, five, Four]"</font>,
      <font color=#004488>"swap: [Four, the, matrix, Yo, six, five, in]"</font>,
      <font color=#004488>"fill: [pop, pop, pop, pop, pop, pop, pop]"</font>,
      <font color=#004488>"dups: [snap, snap, snap]"</font>,
      <font color=#004488>"arrayList: [snap, snap, snap]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The output explains the behavior of each utility method. Note the difference in <b>min(&#160;)</b> and <b>max(&#160;)</b> with the <b>AlphabeticComparator</b> because of capitalization. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0506" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775773"></a><a name="Heading13509"></a>Making a <b>Collection</b>
or <b>Map</b> unmodifiable<br></h3>
<p><a name="Index1146"></a>Often it is convenient to create a read-only version of a <b>Collection</b> or <b>Map</b>. The <b>Collections</b> class allows you to do this by passing the original container into a method that hands back a read-only version. There are four variations on this method, one each for <b>Collection</b> (if you can&#146;t treat a <b>Collection </b>as a more specific type), <b>List</b>, <b>Set,</b> and <b>Map</b>. This example shows the proper way to build read-only versions of each:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ReadOnly.java</font>
<font color=#009900>// Using the Collections.unmodifiable methods.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ReadOnly {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Collections2.StringGenerator gen =
    Collections2.countries;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, gen, 25); <font color=#009900>// Insert data</font>
    c = Collections.unmodifiableCollection(c);
    System.out.println(c); <font color=#009900>// Reading is OK</font>
    <font color=#009900>//! c.add("one"); // Can't change it</font>

    List a = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(a, gen.reset(), 25);
    a = Collections.unmodifiableList(a);
    ListIterator lit = a.listIterator();
    System.out.println(lit.next()); <font color=#009900>// Reading is OK</font>
    <font color=#009900>//! lit.add("one"); // Can't change it</font>

    Set s = <font color=#0000ff>new</font> HashSet();
    Collections2.fill(s, gen.reset(), 25);
    s = Collections.unmodifiableSet(s);
    System.out.println(s); <font color=#009900>// Reading is OK</font>
    <font color=#009900>//! s.add("one"); // Can't change it</font>

    Map m = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m, Collections2.geography, 25);
    m = Collections.unmodifiableMap(m);
    System.out.println(m); <font color=#009900>// Reading is OK</font>
    <font color=#009900>//! m.put("Ralph", "Howdy!");</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Calling the &#147;unmodifiable&#148; method for a particular type does not cause compile-time checking, but once the transformation has occurred, any calls to methods that modify the contents of a particular container will produce an <b>UnsupportedOperationException</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1426" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In each case, you must fill the container with meaningful data <i>before</i> you make it read-only. Once it is loaded, the best approach is to replace the existing reference with the reference that is produced by the &#147;unmodifiable&#148; call. That way, you don&#146;t run the risk of accidentally trying to change the contents once you&#146;ve made it unmodifiable. On the other hand, this tool also allows you to keep a modifiable container as <b>private</b> within a class and to return a read-only reference to that container from a method call. So, you can change it from within the class, but everyone else can only read it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1425" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775774"></a><a name="Heading13549"></a>Synchronizing a
<b>Collection</b> or <b>Map</b></h3>
<p>The <a name="Index1147"></a><b>synchronized</b> keyword is an important part of the subject of <a name="Index1148"></a><i>multithreading</i>, a more complicated topic that will not be introduced until Chapter 13. Here, I shall note only that the <b>Collections</b> class contains a way to automatically synchronize an entire container. The syntax is similar to the &#147;unmodifiable&#148; methods:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Synchronization.java</font>
<font color=#009900>// Using the Collections.synchronized methods.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Synchronization {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c =
      Collections.synchronizedCollection(<font color=#0000ff>new</font> ArrayList());
    List list =
      Collections.synchronizedList(<font color=#0000ff>new</font> ArrayList());
    Set s = Collections.synchronizedSet(<font color=#0000ff>new</font> HashSet());
    Map m = Collections.synchronizedMap(<font color=#0000ff>new</font> HashMap());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In this case, you immediately pass the new container through the appropriate &#147;synchronized&#148; method; that way, there&#146;s no chance of accidentally exposing the unsynchronized version. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1427" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading13567"></a>Fail fast<br></h4>
<p><a name="Index1149"></a><a name="Index1150"></a>The Java containers also have a mechanism to prevent more than one process from modifying the contents of a container. The problem occurs if you&#146;re iterating through a container, and some other process steps in and inserts, removes, or changes an object in that container. Maybe you&#146;ve already passed that object, maybe it&#146;s ahead of you, maybe the size of the container shrinks after you call <b>size(&#160;)</b>&#151;there are many scenarios for disaster. The Java containers library incorporates a <i>fail-fast</i> mechanism that looks for any changes to the container other than the ones your process is personally responsible for. If it detects that someone else is modifying the container, it immediately produces a <b>ConcurrentModificationException</b>. This is the &#147;fail-fast&#148; aspect&#151;it doesn&#146;t try to detect a problem later on using a more complex algorithm. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1428" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s quite easy to see the fail-fast mechanism in operation&#151;all you have to do is create an iterator and then add something to the collection that the iterator is pointing to, like this:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:FailFast.java</font>
<font color=#009900>// Demonstrates the "fail fast" behavior.</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FailFast {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Iterator it = c.iterator();
    c.add(<font color=#004488>"An object"</font>);
    <font color=#009900>// Causes an exception:</font>
    String s = (String)it.next();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The exception happens because something is placed in the container <i>after</i> the iterator is acquired from the container. The possibility that two parts of the program could be modifying the same container produces an uncertain state, so the exception notifies you that you should change your code&#151;in this case, acquire the iterator <i>after</i> you have added all the elements to the container. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1429" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that you cannot benefit from this kind of monitoring when you&#146;re accessing the elements of a <b>List</b> using <b>get(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1430" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775775"></a><a name="Heading13587"></a>Unsupported
operations<br></h2>
<p><a name="Index1151"></a><a name="Index1152"></a><a name="Index1153"></a>It&#146;s possible to turn an array into a <b>List</b> with the <b>Arrays.asList(&#160;)</b> method:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Unsupported.java</font>
<font color=#009900>// Sometimes methods defined in the</font>
<font color=#009900>// Collection interfaces don't work!</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Unsupported {
  <font color=#0000ff>static</font> List a = Arrays.asList(
    <font color=#004488>"one two three four five six seven eight"</font>.split(<font color=#004488>" "</font>));
  <font color=#0000ff>static</font> List a2 = a.subList(3, 6);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(a);
    System.out.println(a2);
    System.out.println(<font color=#004488>"a.contains("</font> + a.get(0) + <font color=#004488>") = "</font> +
      a.contains(a.get(0)));
    System.out.println(<font color=#004488>"a.containsAll(a2) = "</font> +
      a.containsAll(a2));
    System.out.println(<font color=#004488>"a.isEmpty() = "</font> + a.isEmpty());
    System.out.println(<font color=#004488>"a.indexOf("</font> + a.get(5) + <font color=#004488>") = "</font> +
      a.indexOf(a.get(5)));
    <font color=#009900>// Traverse backwards:</font>
    ListIterator lit = a.listIterator(a.size());
    <font color=#0000ff>while</font>(lit.hasPrevious())
      System.out.print(lit.previous() + <font color=#004488>" "</font>);
    System.out.println();
    <font color=#009900>// Set the elements to different values:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.size(); i++)
      a.set(i, <font color=#004488>"47"</font>);
    System.out.println(a);
    <font color=#009900>// Compiles, but won't run:</font>
    lit.add(<font color=#004488>"X"</font>); <font color=#009900>// Unsupported operation</font>
    a.clear(); <font color=#009900>// Unsupported</font>
    a.add(<font color=#004488>"eleven"</font>); <font color=#009900>// Unsupported</font>
    a.addAll(a2); <font color=#009900>// Unsupported</font>
    a.retainAll(a2); <font color=#009900>// Unsupported</font>
    a.remove(a.get(0)); <font color=#009900>// Unsupported</font>
    a.removeAll(a2); <font color=#009900>// Unsupported</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You&#146;ll discover that only a portion of the <b>Collection</b> and <b>List </b>interfaces are actually implemented. The rest of the methods cause the unwelcome appearance of something called an <b>UnsupportedOperationException</b>. The <b>Collection</b> <b>interface</b>&#151;as well as some of the other <b>interface</b>s in the Java containers library&#151;contain &#147;optional&#148; methods, which might or might not be &#147;supported&#148; in the concrete class that <b>implements</b> that <b>interface</b>. Calling an unsupported method causes an <b>UnsupportedOperationException</b> to indicate a programming error. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1431" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>&#147;What?!?&#148; you say, incredulous. &#147;The whole point of <b>interface</b>s and base classes is that they promise these methods will do something meaningful! This breaks that promise; it says that not only will calling some methods <i>not</i> perform a meaningful behavior, but they will stop the program! Type safety was just thrown out the window!&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1432" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s not quite that bad. With a <b>Collection</b>, <b>List</b>, <b>Set</b>, or <b>Map</b>, the compiler still restricts you to calling only the methods in that <b>interface</b>, so it&#146;s not like Smalltalk (in which you can call any method for any object, and find out only when you run the program whether your call does anything). In addition, most methods that take a <b>Collection</b> as an argument only read from that <b>Collection</b>&#151;all the &#147;read&#148; methods of <b>Collection </b>are <i>not</i> optional. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1433" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This approach prevents an explosion of interfaces in the design. Other designs for container libraries always seem to end up with a confusing plethora of interfaces to describe each of the variations on the main theme, and are thus difficult to learn. It&#146;s not even possible to capture all of the special cases in <b>interface</b>s, because someone can always invent a new <b>interface</b>. The &#147;unsupported operation&#148; approach achieves an important goal of the Java containers library: The containers are simple to learn and use; unsupported operations are a special case that can be learned later. For this approach to work, however: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1434" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>The <b>UnsupportedOperationException</b> must be a rare event. That is, for
most classes all operations should work, and only in special cases should an
operation be unsupported. This is true in the Java containers library, since the
classes you&#146;ll use 99 percent of the time&#151;<b>ArrayList</b>,
<b>LinkedList</b>, <b>HashSet</b>, and <b>HashMap</b>, as well as the other
concrete implementations&#151;support all of the operations. The design does
provide a &#147;back door&#148; if you want to create a new <b>Collection</b>
without providing meaningful definitions for all the methods in the
<b>Collection</b> <b>interface</b>, and yet still fit it into the existing
library. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1435" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>When an operation <i>is</i> unsupported, there should be reasonable
likelihood that an <b>UnsupportedOperationException</b> will appear at
implementation time, rather than after you&#146;ve shipped the product to the
customer. After all, it indicates a programming error: You&#146;ve used an
implementation incorrectly. This point is less certain and is where the
experimental nature of this design comes into play. Only over time will we find
out how well it works. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1436" title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>In the preceding example, <a name="Index1154"></a><b>Arrays.asList(&#160;)</b> produces a <b>List</b> that is backed by a fixed-size array. Therefore, it makes sense that the only supported operations are the ones that don&#146;t change the size of the array. If, on the other hand, a new <b>interface</b> were required to express this different kind of behavior (called, perhaps, &#147;<b>FixedSizeList</b>&#148;), it would throw open the door to complexity, and soon you wouldn&#146;t know where to start when trying to use the library. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1437" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that you can always pass the result of <b>Arrays.asList(&#160;)</b> as a constructor argument to a <b>List</b> or <b>Set</b> in order to create a regular container that allows the use of all the methods. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0507" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The documentation for a method that takes a <b>Collection</b>, <b>List</b>, <b>Set</b>, or <b>Map</b> as an argument should specify which of the optional methods must be implemented. For example, sorting requires the <b>set(&#160;)</b> and <b>Iterator.set(&#160;) </b>methods, but not <b>add(&#160;)</b> and <b>remove(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1438" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775776"></a><a name="Heading13638"></a>Java 1.0/1.1
containers</h2>
<p>Unfortunately, a lot of code was written using the Java 1.0/1.1 containers, and even new code is sometimes written using these classes. So although you should never use the old containers when writing new code, you&#146;ll still need to be aware of them. However, the old containers were quite limited, so there&#146;s not that much to say about them. (Since they are in the past, I will try to refrain from overemphasizing some of the hideous design decisions.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1439" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545355"></a><a name="_Toc24775777"></a><a name="Heading13640"></a>Vector
&amp; Enumeration</h3>
<p>The only self-expanding sequence in Java 1.0/1.1 was the <a name="Index1155"></a><b>Vector</b>, so it saw a lot of use. Its flaws are too numerous to describe here (see the first edition of this book, available as a free download from <i>www.BruceEckel.com</i>). Basically, you can think of it as an <b>ArrayList</b> with long, awkward method names. In the Java 2 container library, <b>Vector</b> was adapted so that it could fit as a <b>Collection </b>and a <b>List</b>, so in the following example, the <b>Collections2.fill(&#160;)</b> method is successfully used. This turns out to be a bit perverse, as it may confuse some people into thinking that <b>Vector</b> has gotten better, when it is actually included only to support pre-Java 2 code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1440" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The Java 1.0/1.1 version of the iterator chose to invent a new name, &#147;enumeration,&#148; instead of using a term that everyone was already familiar with. The <a name="Index1156"></a><b>Enumeration</b> interface is smaller than <b>Iterator</b>, with only two methods, and it uses longer method names: <b>boolean</b> <b>hasMoreElements(&#160;)</b> produces <b>true</b> if this enumeration contains more elements, and <b>Object nextElement(&#160;) </b>returns the next element of this enumeration if there are any more (otherwise it throws an exception). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1441" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Enumeration</b> is only an interface, not an implementation, and even new libraries sometimes still use the old <b>Enumeration</b>, which is unfortunate but generally harmless. Even though you should always use <b>Iterator</b> when you can in your own code, you must be prepared for libraries that want to hand you an <b>Enumeration</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1442" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1157"></a>In addition, you can produce an <b>Enumeration</b> for any <b>Collection</b> by using the <b>Collections.enumeration(&#160;)</b> method, as seen in this example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Enumerations.java</font>
<font color=#009900>// Java 1.0/1.1 Vector and Enumeration.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Enumerations {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector v = <font color=#0000ff>new</font> Vector();
    Collections2.fill(v, Collections2.countries, 100);
    Enumeration e = v.elements();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      System.out.println(e.nextElement());
    <font color=#009900>// Produce an Enumeration from a Collection:</font>
    e = Collections.enumeration(<font color=#0000ff>new</font> ArrayList());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The Java 1.0/1.1 <b>Vector</b> has only an <b>addElement(&#160;)</b> method, but <b>fill(&#160;)</b> uses the <b>add(&#160;)</b> method that was pasted on while <b>Vector</b> was being turned into a <b>List</b>. To produce an <b>Enumeration</b>, you call <b>elements(&#160;)</b>, then you can use it to perform a forward iteration. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1443" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The last line creates an <b>ArrayList</b> and uses <b>enumeration(&#160;)</b> to adapt an <b>Enumeration</b> from the <b>ArrayList</b> <b>Iterator</b>. Thus, if you have old code that wants an <b>Enumeration</b>, you can still use the new containers. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1444" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775778"></a><a name="Heading13664"></a>Hashtable</h3>
<p>As you&#146;ve seen in the performance comparison in this chapter, the basic <a name="Index1158"></a><b>Hashtable</b> is very similar to the <b>HashMap</b>, even down to the method names. There&#146;s no reason to use <b>Hashtable</b> instead of <b>HashMap</b> in new code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1445" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545356"></a><a name="_Toc24775779"></a><a name="Heading13666"></a>Stack</h3>
<p>The concept of the stack was introduced earlier, with the <b>LinkedList</b>.<b> </b>What&#146;s rather odd about the Java 1.0/1.1 <b>Stack </b>is that instead of using a <a name="Index1159"></a><b>Vector</b> as a building block, <a name="Index1160"></a><b>Stack </b>is <i>inherited</i> from <b>Vector</b>. So it has all of the characteristics and behaviors of a <b>Vector</b> plus some extra <b>Stack</b> behaviors. It&#146;s difficult to know whether the designers consciously thought that this was an especially useful way of doing things, or whether it was just a na&iuml;ve design; in any event it was clearly not reviewed before it was rushed into distribution, so this bad design is <i>still</i> hanging around (but you should never use it). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1446" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s a simple demonstration of <b>Stack</b> that pushes each line from a <b>String</b> array:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Stacks.java</font>
<font color=#009900>// Demonstration of Stack Class.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> c08.Month;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Stacks {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Stack stack = <font color=#0000ff>new</font> Stack();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; Month.month.length; i++)
      stack.push(Month.month[i] + <font color=#004488>" "</font>);
    System.out.println(<font color=#004488>"stack = "</font> + stack);
    <font color=#009900>// Treating a stack as a Vector:</font>
    stack.addElement(<font color=#004488>"The last line"</font>);
    System.out.println(<font color=#004488>"element 5 = "</font> +
      stack.elementAt(5));
    System.out.println(<font color=#004488>"popping elements:"</font>);
    <font color=#0000ff>while</font>(!stack.empty())
      System.out.println(stack.pop());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"stack = [January , February , March , April , May "</font>+
        <font color=#004488>", June , July , August , September , October , "</font> +
        <font color=#004488>"November , December ]"</font>,
      <font color=#004488>"element 5 = June "</font>,
      <font color=#004488>"popping elements:"</font>,
      <font color=#004488>"The last line"</font>,
      <font color=#004488>"December "</font>,
      <font color=#004488>"November "</font>,
      <font color=#004488>"October "</font>,
      <font color=#004488>"September "</font>,
      <font color=#004488>"August "</font>,
      <font color=#004488>"July "</font>,
      <font color=#004488>"June "</font>,
      <font color=#004488>"May "</font>,
      <font color=#004488>"April "</font>,
      <font color=#004488>"March "</font>,
      <font color=#004488>"February "</font>,
      <font color=#004488>"January "</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Each line in the <b>months </b>array is inserted into the <b>Stack</b> with <b>push(&#160;)</b>, and later fetched from the top of the stack with a <b>pop(&#160;)</b>. To make a point, <b>Vector </b>operations are also performed on the <b>Stack</b> object. This is possible because, by virtue of inheritance, a <b>Stack</b> <i>is</i> a <b>Vector</b>. Thus, all operations that can be performed on a <b>Vector</b> can also be performed on a <b>Stack</b>, such as <b>elementAt(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1447" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As mentioned earlier, you should use a <b>LinkedList</b> when you want stack behavior. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1448" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775780"></a><a name="Heading13714"></a>BitSet</h3>
<p>A <a name="Index1161"></a><b>BitSet</b> is used if you want to efficiently store a lot of on-off information. It&#146;s efficient only from the standpoint of size; if you&#146;re looking for efficient access, it is slightly slower than using an array of some native type. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1449" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In addition, the minimum size of the <b>BitSet</b> is that of a <b>long</b>: 64 bits. This implies that if you&#146;re storing anything smaller, like 8 bits, a <b>BitSet</b> will be wasteful; you&#146;re better off creating your own class, or just an array, to hold your flags if size is an issue. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1450" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A normal container expands as you add more elements, and the <b>BitSet</b> does this as well. The following example shows how the <b>BitSet </b>works:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Bits.java</font>
<font color=#009900>// Demonstration of BitSet.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Bits {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> printBitSet(BitSet b) {
    System.out.println(<font color=#004488>"bits: "</font> + b);
    String bbits = <font color=#0000ff>new</font> String();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; b.size() ; j++)
      bbits += (b.get(j) ? <font color=#004488>"1"</font> : <font color=#004488>"0"</font>);
    System.out.println(<font color=#004488>"bit pattern: "</font> + bbits);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Random rand = <font color=#0000ff>new</font> Random();
    <font color=#009900>// Take the LSB of nextInt():</font>
    <font color=#0000ff>byte</font> bt = (<font color=#0000ff>byte</font>)rand.nextInt();
    BitSet bb = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 7; i &gt;= 0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  bt) != 0)
        bb.set(i);
      <font color=#0000ff>else</font>
        bb.clear(i);
    System.out.println(<font color=#004488>"byte value: "</font> + bt);
    printBitSet(bb);

    <font color=#0000ff>short</font> st = (<font color=#0000ff>short</font>)rand.nextInt();
    BitSet bs = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 15; i &gt;= 0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  st) != 0)
        bs.set(i);
      <font color=#0000ff>else</font>
        bs.clear(i);
    System.out.println(<font color=#004488>"short value: "</font> + st);
    printBitSet(bs);

    <font color=#0000ff>int</font> it = rand.nextInt();
    BitSet bi = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 31; i &gt;= 0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  it) != 0)
        bi.set(i);
      <font color=#0000ff>else</font>
        bi.clear(i);
    System.out.println(<font color=#004488>"int value: "</font> + it);
    printBitSet(bi);

    <font color=#009900>// Test bitsets &gt;= 64 bits:</font>
    BitSet b127 = <font color=#0000ff>new</font> BitSet();
    b127.set(127);
    System.out.println(<font color=#004488>"set bit 127: "</font> + b127);
    BitSet b255 = <font color=#0000ff>new</font> BitSet(65);
    b255.set(255);
    System.out.println(<font color=#004488>"set bit 255: "</font> + b255);
    BitSet b1023 = <font color=#0000ff>new</font> BitSet(512);
    b1023.set(1023);
    b1023.set(1024);
    System.out.println(<font color=#004488>"set bit 1023: "</font> + b1023);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The random number generator is used to create a random <b>byte</b>, <b>short</b>, and <b>int</b>, and each one is transformed into a corresponding bit pattern in a <b>BitSet</b>. This works fine because a <b>BitSet</b> is 64 bits, so none of these cause it to increase in size. Then a <b>BitSet</b> of 512 bits is created. The constructor allocates storage for twice that number of bits. However, you can still set bit 1024 or greater. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1451" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775781"></a><a name="Heading13778"></a>Summary</h2>
<p>To review the containers provided in the standard Java library: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1452" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>An array associates numerical indices to objects. It holds objects of a
known type so that you don&#146;t have to cast the result when you&#146;re
looking up an object. It can be multidimensional, and it can hold primitives.
However, its size cannot be changed once you create it. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1453" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>A <b>Collection</b> holds single elements, and a <b>Map</b> holds associated
pairs. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1454" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Like an array, a <b>List</b> also associates numerical indices to
objects&#151;you can think of arrays and <b>List</b>s as ordered containers.
The <b>List</b> automatically resizes itself as you add more elements. But a
<b>List</b> can hold only <b>Object reference</b>s, so it won&#146;t hold
primitives, and you must always cast the result when you pull an <b>Object
</b>reference out of a container. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1455" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Use an <b>ArrayList</b> if you&#146;re doing a lot of random accesses, but
a <b>LinkedList</b> if you will be doing a lot of insertions and removals in the
middle of the list. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1456" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>The behavior of queues, deques, and stacks is provided via the
<b>LinkedList</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1457" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>A <b>Map</b> is a way to associate not numbers, but <i>objects</i> with
other objects. The design of a <b>HashMap</b> is focused on rapid access,
whereas a <b>TreeMap</b> keeps its keys in sorted order, and thus is not as fast
as a <b>HashMap</b>. A <b>LinkedHashMap</b> keeps its elements in insertion
order, but may also reorder them with its LRU algorithm. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1458" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>A <b>Set</b> only accepts one of each type of object. <b>HashSet</b>s
provide maximally fast lookups, whereas <b>TreeSet</b>s keep the elements in
sorted order. <b>LinkedHashSet</b>s keep elements in insertion order. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1459"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>There&#146;s no need to use the legacy classes <b>Vector</b>,
<b>Hashtable</b>, and <b>Stack</b> in new code. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1460" title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>The containers are tools that you can use on a day-to-day basis to make your programs simpler, more powerful, and more effective. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1461" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545360"></a><a name="_Toc24775782"></a><a name="Heading13789"></a>Exercises</h2>
<p>Solutions to selected exercises can be found in the electronic document <i>The Thinking in Java Annotated Solution Guide</i>, available for a small fee from <i>www.BruceEckel.com</i>.<br></p>
<ol>
<li>	Create an array of <b>double</b> and <b>fill(&#160;)</b> it using
<b>RandDoubleGenerator</b>. Print the results. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1462" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create a new class called <b>Gerbil</b> with an <b>int gerbilNumber
</b>that&#146;s initialized in the constructor (similar to the <b>Mouse
</b>example in this chapter). Give it a method called <b>hop(&#160;)</b> that
prints out which gerbil number this is, and that it&#146;s hopping. Create an
<b>ArrayList</b> and add a bunch of <b>Gerbil</b> objects to the <b>List</b>.
Now use the <b>get(&#160;)</b> method to move through the <b>List</b> and call
<b>hop(&#160;)</b> for each <b>Gerbil</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1463" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify Exercise 2 so you use an <b>Iterator</b> to move through the
<b>List</b> while calling <b>hop(&#160;)</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1464" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Take the <b>Gerbil</b> class in Exercise 2 and put it into a <b>Map</b>
instead, associating the name of the <b>Gerbil</b> as a <b>String</b> (the key)
for each <b>Gerbil </b>(the value) you put in the table. Get an <b>Iterator</b>
for the <b>keySet(&#160;)</b> and use it to move through the <b>Map</b>, looking
up the <b>Gerbil</b> for each key and printing out the key and telling the
<b>gerbil</b> to <b>hop(&#160;)</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1465" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create a <b>List</b> (try both <b>ArrayList </b>and <b>LinkedList</b>)<b>
</b>and fill it using <b>Collections2.countries</b>. Sort the list and print it,
then apply <b>Collections.shuffle(&#160;)</b> to the list repeatedly, printing
it each time so that you can see how the <b>shuffle(&#160;)</b> method
randomizes the list differently each time. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1466" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Demonstrate that you can&#146;t add anything but a <b>Mouse</b> to a
<b>MouseList</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1467" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>MouseList.java</b> so that it inherits from <b>ArrayList</b>
instead of using composition. Demonstrate the problem with this approach. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1468"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Repair <b>CatsAndDogs.java</b> by creating a <b>Cats</b> container
(utilizing <b>ArrayList</b>)<b> </b>that will only accept and retrieve
<b>Cat</b> objects. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1469" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Fill a <b>HashMap</b> with key-value pairs. Print the results to show
ordering by hash code. Extract the pairs, sort by key, and place the result into
a <b>LinkedHashMap</b>. Show that the insertion order is maintained.</li>
<li>	Repeat the previous example with a <b>HashSet</b> and
<b>LinkedHashSet</b>.</li>
<li>	Create a new type of container that uses a <b>private</b> <b>ArrayList</b>
to hold the objects.<b> </b>Using a <b>Class </b>reference, capture the type of
the first object you put in it, and then allow the user to insert objects of
only that type from then on. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap12_1890" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create a container that encapsulates an array of <b>String</b>, and that
only adds <b>String</b>s and gets <b>String</b>s, so that there are no casting
issues during use. If the internal array isn&#146;t big enough for the next
add, your container should automatically resize it. In <b>main(&#160;)</b>,
compare the performance of your container with an <b>ArrayList</b> holding
<b>String</b>s. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1470" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Repeat Exercise 12 for a container of <b>int</b>, and compare the
performance to an <b>ArrayList</b> holding <b>Integer</b> objects. In your
performance comparison, include the process of incrementing each object in the
container. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1471" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Using the utilities in <b>com.bruceeckel.util</b>, create an array of each
primitive type and of <b>String</b>, then fill each array by using an
appropriate generator, and print each array using the appropriate
<b>print(&#160;)</b> method. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1472" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create a generator that produces character names from your favorite movies
(you can use <i>Snow White</i> or <i>Star Wars </i>as a fallback) and loops
around to the beginning when it runs out of names. Use the utilities in
<b>com.bruceeckel.util</b> to fill an array, an <b>ArrayList</b>, a
<b>LinkedList</b>, and both types of <b>Set</b>, then print each container.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1473"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Create a class containing two <b>String</b> objects and make it
<b>Comparable</b> so that the comparison only cares about the first
<b>String</b>. Fill an array and an <b>ArrayList </b>with objects of your class
by using the <b>geography </b>generator. Demonstrate that sorting works
properly. Now make a <b>Comparator</b> that only cares about the second
<b>String</b> and demonstrate that sorting works properly. Also perform a binary
search using your <b>Comparator</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1474" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify Exercise 16 so that an alphabetic sort is used. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1475" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Use <b>Arrays2.RandStringGenerator</b> to fill a <b>TreeSet</b>, but by
using alphabetic ordering. Print the <b>TreeSet</b> to verify the sort order.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1476"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Create both an <b>ArrayList</b> and a <b>LinkedList</b>, and fill each
using the <b>Collections2.capitals</b> generator. Print each list using an
ordinary <b>Iterator</b>, then insert one list into the other by using a
<b>ListIterator</b>, inserting at every other location. Now perform the
insertion starting at the end of the first list and moving backward. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1477"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Write a method that uses an <b>Iterator</b> to step through a
<b>Collection</b> and print the <b>hashCode(&#160;)</b> of each object in the
container. Fill all the different types of <b>Collection</b>s with objects and
apply your method to each container. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1478" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Repair the problem in <b>InfiniteRecursion.java</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1479" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create a class, then make an initialized array of objects of your class.
Fill a <b>List</b> from your array. Create a subset of your <b>List</b> by using
<b>subList(&#160;)</b>, then remove this subset from your <b>List</b> by using
<b>removeAll(&#160;)</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1480" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Change Exercise 6 in Chapter 7 to use an <b>ArrayList</b> to hold the
<b>Rodent</b>s and an <b>Iterator</b> to move through the sequence of
<b>Rodent</b>s. Remember that an <b>ArrayList</b> holds only <b>Object</b>s, so
you must use a cast when accessing individual <b>Rodent</b>s. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1481" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Following the <b>Queue.java</b> example, create a <b>Deque</b> class and
test it. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1482" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Use a <b>TreeMap</b> in <b>Statistics.java</b>. Now add code that tests the
performance difference between <b>HashMap</b> and <b>TreeMap</b> in that
program. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1483" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Produce a <b>Map</b> and a <b>Set </b>containing all the countries that
begin with &#147;A.&#148; <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1484" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Using <b>Collections2.countries</b>, fill a <b>Set</b> multiple times with
the same data and verify that the <b>Set</b> ends up with only one of each
instance. Try this with both kinds of <b>Set</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1485" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Starting with <b>Statistics.java</b>, create a program that runs the test
repeatedly and looks to see if any one number tends to appear more than the
others in the results. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1486" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Rewrite <b>Statistics.java</b> using a <b>HashSet</b> of <b>Counter</b>
objects (you&#146;ll have to modify <b>Counter</b> so that it will work in the
<b>HashSet</b>). Which approach seems better? <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1487" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Fill a <b>LinkedHashMap</b> with <b>String</b> keys and objects of your
choice. Now extract the pairs, sort them based on the keys, and re-insert them
into the <b>Map</b>.</li>
<li>	Modify the class in Exercise 16 so that the class will work with
<b>HashSet</b>s and as a key in <b>HashMap</b>s. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1488" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Using <b>SlowMap.java</b> for inspiration, create a <b>SlowSet</b>. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1489"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Create a <b>FastTraversalLinkedList</b> that internally uses a
<b>LinkedList</b> for rapid insertions and removals, and an <b>ArrayList</b> for
rapid traversals and <b>get(&#160;)</b> operations. Test it by modifying
<b>ArrayPerformance.java</b>.</li>
<li>	Apply the tests in <b>Map1.java</b> to <b>SlowMap</b> to verify that it
works. Fix anything in <b>SlowMap </b>that doesn&#146;t work correctly. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1490"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Implement the rest of the <b>Map</b> interface for <b>SlowMap</b>. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1491"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Modify <b>MapPerformance.java</b> to include tests of <b>SlowMap</b>. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1492"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Modify <b>SlowMap</b> so that instead of two <b>ArrayList</b>s, it holds a
single <b>ArrayList</b> of <b>MPair</b> objects. Verify that the modified
version works correctly. Using <b>MapPerformance.java</b>, test the speed of
your new <b>Map</b>. Now change the <b>put(&#160;)</b> method so that it
performs a <b>sort(&#160;)</b> after each pair is entered, and modify
<b>get(&#160;)</b> to use <b>Collections.binarySearch(&#160;)</b> to look up the
key. Compare the performance of the new version with the old ones. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1493"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Add a <b>char</b> field to <b>CountedString</b> that is also initialized in
the constructor, and modify the <b>hashCode(&#160;)</b> and
<b>equals(&#160;)</b> methods to include the value of this <b>char</b>. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1494"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Modify <b>SimpleHashMap</b> so that it reports collisions, and test this by
adding the same data set twice so that you see collisions. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1495" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>SimpleHashMap</b> so that it reports the number of
&#147;probes&#148; necessary when collisions occur. That is, how many calls to
<b>next(&#160;)</b> must be made on the <b>Iterator</b>s that walk the
<b>LinkedList</b>s looking for matches? <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1496" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Implement the <b>clear(&#160;)</b> and <b>remove(&#160;)</b> methods for
<b>SimpleHashMap</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1497" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Implement the rest of the <b>Map</b> interface for <b>SimpleHashMap</b>.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1498"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Add a <b>private</b> <b>rehash(&#160;)</b> method to <b>SimpleHashMap</b>
that is invoked when the load factor exceeds 0.75. During rehashing, double the
number of buckets, then search for the first prime number greater than that to
determine the new number of buckets. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1499" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Following the example in <b>SimpleHashMap.java</b>, create and test a
<b>SimpleHashSet</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1500" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>SimpleHashMap</b> to use <b>ArrayList</b>s instead of
<b>LinkedList</b>s. Modify <b>MapPerformance.java</b> to compare the performance
of the two implementations. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1501" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Using the HTML documentation for the JDK (downloadable from
<i>java.sun.com</i>), look up the <b>HashMap</b> class. Create a <b>HashMap</b>,
fill it with elements, and determine the load factor. Test the lookup speed with
this map, then attempt to increase the speed by making a new <b>HashMap</b> with
a larger initial capacity and copying the old map into the new one, then run
your lookup speed test again on the new map. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1502" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	In Chapter 8, locate the <b>GreenhouseController.java</b> example, which
consists of four files. In <b>Controller.java</b>, the class <b>Controller</b>
uses an <b>ArrayList</b>. Change the code to use a <b>LinkedList</b> instead,
and use an <b>Iterator</b> to cycle through the set of events. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1503"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	(Challenging). Write your own hashed map class, customized for a particular
key type: <b>String </b>for this example. Do not inherit it from <b>Map</b>.
Instead, duplicate the methods so that the <b>put(&#160;)</b> and
<b>get(&#160;)</b> methods specifically take <b>String</b> objects, not
<b>Object</b>s, as keys. Everything that involves keys should not use generic
types; instead, work with <b>String</b>s to avoid the cost of upcasting and
downcasting. Your goal is to make the fastest possible custom implementation.
Modify <b>MapPerformance.java</b> to test your implementation versus a
<b>HashMap</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1504" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	(Challenging). Find the source code for <b>List</b> in the Java source code
library that comes with all Java distributions. Copy this code and make a
special version called <b>intList</b> that holds only <b>int</b>s. Consider what
it would take to make a special version of <b>List</b> for all the primitive
types. Now consider what happens if you want to make a linked list class that
works with all the primitive types. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1505" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>c08:Month.java</b> to make it implement the <b>Comparable</b>
interface. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1506" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify the <b>hashCode(&#160;)</b> in <b>CountedString.java</b> by removing
the multiplication by <b>id</b>, and demonstrate that <b>CountedString</b> still
works as a key. What is the problem with this approach? <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap09_1507" title="Send BackTalk
Comment">Feedback</a></font></li></ol><hr><p class="footnote text"><sup><a name="fn51" href="#fnB51">[51]</a></sup> It&#146;s possible, however, to ask how big the <b>vector</b> is, and the <b>at(&#160;)</b> method <i>does</i> perform bounds checking.<br></p>
<p class="footnote text"><sup><a name="fn52" href="#fnB52">[52]</a></sup> This is one of the places where C++ is distinctly superior to Java, since C++ supports <i>parameterized types</i> with the <b>template</b> keyword.<br></p>
<p class="footnote text"><sup><a name="fn53" href="#fnB53">[53]</a></sup> The C++ programmer will note how much the code could be collapsed with the use of default arguments and templates. The Python programmer will note that this entire library would be largely unnecessary in that language.<br></p>
<p class="footnote text"><sup><a name="fn54" href="#fnB54">[54]</a></sup> <i>Design Patterns</i>, Erich Gamma <i>et al.</i>, Addison-Wesley 1995.<br></p>
<p class="footnote text"><sup><a name="fn55" href="#fnB55">[55]</a></sup> By Joshua Bloch at Sun.<br></p>
<p class="footnote text"><sup><a name="fn56" href="#fnB56">[56]</a></sup> This data was found on the Internet, then processed by creating a Python program (see <i>www.Python.org</i>).<br></p>
<p class="footnote text"><sup><a name="fn57" href="#fnB57">[57]</a></sup> This is a place where operator overloading would be nice.<br></p>
<p class="footnote text"><sup><a name="fn58" href="#fnB58">[58]</a></sup> If these speedups still don&#146;t meet your performance needs, you can further accelerate table lookup by writing your own <b>Map</b> and customizing it to your particular types to avoid delays due to casting to and from <b>Object</b>s. To reach even higher levels of performance, speed enthusiasts can use Donald Knuth&#146;s <i>The Art of Computer Programming, Volume 3: Sorting and Searching, Second Edition</i> to replace overflow bucket lists with arrays that have two additional benefits: they can be optimized for disk storage characteristics and they can save most of the time of creating and garbage collecting individual records.<br></p>
<p class="footnote text"><sup><a name="fn59" href="#fnB59">[59]</a></sup> As it turns out, a prime number is not actually the ideal size for hash buckets, and recent hashed implementations in Java uses a power of two size (after extensive testing). Division or remainder is the slowest operation on a modern processor. With a power-of-two hash table length, masking can be used instead of division. Since <b>get(&#160;)</b> is by far the most common operation, the % is a large part of the cost, and the power-of-two approach eliminates this (but may also affect some <b>hashCode(&#160;)</b> methods).<br></p>
<p class="footnote text"><sup><a name="fn60" href="#fnB60">[60]</a></sup> In a private message, Joshua Bloch wrote: &#147;... I believe that we erred by allowing implementation details (such as hash table size and load factor) into our APIs. The client should perhaps tell us the maximum expected size of a collection, and we should take it from there. Clients can easily do more harm than good by choosing values for these parameters. As an extreme example, consider <b>Vector</b>&#146;s capacityIncrement. No one should ever set this, and we shouldn&#146;t have provided it. If you set it to any non-zero value, the asymptotic cost of a sequence of appends goes from linear to quadratic. In other words, it destroys your performance. Over time, we&#146;re beginning to wise up about this sort of thing. If you look at <b>IdentityHashMap</b>, you&#146;ll see that it has no low-level tuning parameters.&#148;<br></p>

<!-- <hr><b>Placeholder</b> -->

<hr>

<div align="CENTER"><a href="TIJ312.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ314.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>

</font></body>

</html>

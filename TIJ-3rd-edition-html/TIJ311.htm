<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en">
<!--
This document was converted from RTF source: 
By r2net 5.8 r2netcmd Windows 
See http://www.logictran.com
-->
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Thinking in Java, 3rd ed. Revision 4.0: 9: Error Handling  with Exceptions</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css"></head>

<body >
   <CENTER>     <a href="http://www.MindView.net">     <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>     <Font FACE="Verdana, Tahoma, Arial, Helvetica, Sans">     <h2>Thinking in Java, 3<sup>rd</sup> ed. Revision 4.0</h2>     <FONT size = "-1"><br>     [ <a href="README.txt">Viewing Hints</a> ]     [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]     [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>     [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]     [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]     [ <a href="http://www.mindview.net/Services">Consulting</a> ] <br><br>     </FONT></FONT>   </CENTER> 
<font face="Georgia"><div align="CENTER"><a href="TIJ310.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ312.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>
<hr>

<h1>
<a name="_Toc375545404"></a><a name="_Toc24272648"></a><a name="_Toc24775697"></a><a name="Heading8318"></a>9:
Error Handling <br>with Exceptions</h1>
<p class="Intro">The basic philosophy of Java is that &#147;badly formed code will not be run.&#148;<br></p>
<p>The ideal time to catch an error is at compile time, before you even try to run the program. However, not all errors can be detected at compile time. The rest of the problems must be handled at run time through some formality that allows the originator of the error to pass appropriate information to a recipient who will know how to handle the difficulty properly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1508" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index778"></a><a name="Index779"></a>C and other earlier languages often had multiple error-handling schemes, and these were generally established by convention and not as part of the programming language. Typically, you returned a special value or set a flag, and the recipient was supposed to look at the value or the flag and determine that something was amiss. However, as the years passed, it was discovered that programmers who use a library tend to think of themselves as invincible&#151;as in, &#147;Yes, errors might happen to others, but not in <i>my</i> code.&#148; So, not too surprisingly, they wouldn&#146;t check for the error conditions (and sometimes the error conditions were too silly to check for<sup><a name="fnB40" href="#fn40">[40]</a></sup>). If you <i>were</i> thorough enough to check for an error every time you called a method, your code could turn into an unreadable nightmare. Because programmers could still coax systems out of these languages, they were resistant to admitting the truth: that this approach to handling errors was a major limitation to creating large, robust, maintainable programs. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1509" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The solution is to take the casual nature out of error handling and to enforce formality. This actually has a long history, because implementations of <i>exception handling</i> go back to operating systems in the 1960s, and even to BASIC&#146;s &#147;<b>on error goto</b>.&#148; But C++ exception handling was based on Ada, and Java&#146;s is based primarily on C++ (although it looks more like that in Object Pascal). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1510" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The word &#147;exception&#148; is meant in the sense of &#147;I take exception to that.&#148; At the point where the problem occurs, you might not know what to do with it, but you do know that you can&#146;t just continue on merrily; you must stop, and somebody, somewhere, must figure out what to do. But you don&#146;t have enough information in the current context to fix the problem. So you hand the problem out to a higher context where someone is qualified to make the proper decision (much like a chain of command). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1511" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The other rather significant benefit of exceptions is that they clean up error handling code. Instead of checking for a particular error and dealing with it at multiple places in your program, you no longer need to check at the point of the method call (since the exception will guarantee that someone catches it). And, you need to handle the problem in only one place, the so-called <a name="Index780"></a><i>exception handler</i>. This saves you code, and it separates the code that describes what you want to do from the code that is executed when things go awry. In general, reading, writing, and debugging code becomes much clearer with exceptions than when using the old way of error handling. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1512" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Because exception handling is the only official way that Java reports errors, and it is enforced by the Java compiler, there are only so many examples that can be written in this book without learning about exception handling. This chapter introduces you to the code you need to write to properly handle exceptions, and the way you can generate your own exceptions if one of your methods gets into trouble. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1513" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545362"></a><a name="_Toc24775698"></a><a name="Heading8327"></a>Basic
exceptions</h2>
<p>An <a name="Index781"></a><i>exceptional condition</i> is a problem that prevents the continuation of the method or scope that you&#146;re in. It&#146;s important to distinguish an exceptional condition from a normal problem, in which you have enough information in the current context to somehow cope with the difficulty. With an exceptional condition, you cannot continue processing because you don&#146;t have the information necessary to deal with the problem <i>in the current context</i>. All you can do is jump out of the current context and relegate that problem to a higher context. This is what happens when you throw an exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1514" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Division is a simple example. If you&#146;re about to divide by zero, it&#146;s worth checking for that condition. But what does it mean that the denominator is zero? Maybe you know, in the context of the problem you&#146;re trying to solve in that particular method, how to deal with a zero denominator. But if it&#146;s an unexpected value, you can&#146;t deal with it and so must throw an exception rather than continuing along that execution path. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1515" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When you throw an exception, several things happen. First, the exception object is created in the same way that any Java object is created: on the heap, with <a name="Index782"></a><b>new</b>. Then the current path of execution (the one you couldn&#146;t continue) is stopped and the reference for the exception object is ejected from the current context. At this point the exception handling mechanism takes over and begins to look for an appropriate place to continue executing the program. This appropriate place is the <i>exception handler,</i> whose job is to recover from the problem so the program can either try another tack or just continue. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1516" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As a simple example of throwing an exception, consider an object reference called <b>t</b>. It&#146;s possible that you might be passed a reference that hasn&#146;t been initialized, so you might want to check before trying to call a method using that object reference. You can send information about the error into a larger context by creating an object representing your information and &#147;throwing&#148; it out of your current context. This is called <i>throwing an exception.</i> Here&#146;s what it looks like:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(t == <font color=#0000ff>null</font>)
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This throws the exception, which allows you&#151;in the current context&#151;to abdicate responsibility for thinking about the issue further. It&#146;s just magically handled somewhere else. Precisely <i>where </i>will be shown shortly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1517" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545363"></a><a name="_Toc24775699"></a><a name="Heading8336"></a>Exception
arguments<br></h3>
<p><a name="Index783"></a><a name="Index784"></a>Like any object in Java, you always create exceptions on the heap using <b>new</b>, which allocates storage and calls a constructor. There are two constructors in all standard exceptions; The first is the default constructor, and the second takes a string argument so you can place pertinent information in the exception:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException(<font color=#004488>"t = null"</font>);</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This string can later be extracted using various methods, as you&#146;ll see. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1518" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The keyword <a name="Index785"></a><b>throw</b> causes a number of relatively magical things to happen. Typically, you&#146;ll first use <b>new</b> to create<b> </b>an object that represents the error condition. You give the resulting reference to <b>throw</b>. The object is, in effect, &#147;returned&#148; from the method, even though that object type isn&#146;t normally what the method is designed to return. A simplistic way to think about exception handling is as a different kind of return mechanism, although you get into trouble if you take that analogy too far. You can also exit from ordinary scopes by throwing an exception. But a value is returned, and the method or scope exits. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1519" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Any similarity to an ordinary return from a method ends here, because <i>where</i> you return is someplace completely different from where you return for a normal method call. (You end up in an appropriate exception handler that might be far&#151;many levels away on the call stack&#151;from where the exception was thrown.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1520" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In addition, you can throw any type of <b>Throwable</b> (the exception root class) object that you want. Typically, you&#146;ll throw a different class of exception for each different type of error. The information about the error is represented both inside the exception object and implicitly in the name of the exception class, so someone in the bigger context can figure out what to do with your exception. (Often, the only information is the type of exception, and nothing meaningful is stored within the exception object.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1521" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc305593298"></a><a name="_Toc305628770"></a><a name="_Toc312374113"></a><a name="_Toc375545364"></a><a name="_Toc24775700"></a><a name="Heading8344"></a>Catching
an exception<br></h2>
<p><a name="Index786"></a><a name="Index787"></a>If a method throws an exception, it must assume that exception will be &#147;caught&#148; and dealt with. One of the advantages of exception handling is that it allows you to concentrate on the problem you&#146;re trying to solve in one place, and then deal with the errors from that code in another place. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1522" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To see how an exception is caught, you must first understand the concept of a <a name="Index788"></a><a name="Index789"></a><i>guarded region.</i> This is a section of code that might produce exceptions and is followed by the code to handle those exceptions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1523" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc312374114"></a><a name="_Toc375545365"></a><a name="_Toc24775701"></a><a name="Heading8347"></a>The
<b>try</b> block</h3>
<p>If you&#146;re inside a method and you throw an exception (or another method you call within this method throws an exception), that method will exit in the process of throwing. If you don&#146;t want a <b>throw </b>to exit the method, you can set up a special block within that method to capture the exception. This is called the <i>try</i> <i>block</i> because you &#147;try&#148; your various method calls there. The try block is an ordinary scope preceded by the keyword <a name="Index790"></a><a name="Index791"></a><b>try</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0144" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>try</font> {
  <font color=#009900>// Code that might generate exceptions</font>
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>If you were checking for errors carefully in a programming language that didn&#146;t support exception handling, you&#146;d have to surround every method call with setup and error testing code, even if you call the same method several times. With exception handling, you put everything in a try block and capture all the exceptions in one place. This means your code is much easier to write and read because the goal of the code is not confused with the error checking. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1524" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc312374115"></a><a name="_Toc375545366"></a><a name="_Toc24775702"></a><a name="Heading8354"></a>Exception
handlers</h3>
<p>Of course, the thrown exception must end up someplace. This &#147;place&#148; is the <i>exception handler</i><a name="Index792"></a><a name="Index793"></a><i>,</i> and there&#146;s one for every exception type you want to catch. Exception handlers immediately follow the try block and are denoted by the keyword <b>catch</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>try</font> {
  <font color=#009900>// Code that might generate exceptions</font>
} <font color=#0000ff>catch</font>(Type1 id1) {
  <font color=#009900>// Handle exceptions of Type1</font>
} <font color=#0000ff>catch</font>(Type2 id2) {
  <font color=#009900>// Handle exceptions of Type2</font>
} <font color=#0000ff>catch</font>(Type3 id3) {
  <font color=#009900>// Handle exceptions of Type3</font>
}

<font color=#009900>// etc...</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Each catch clause (exception handler) is like a little method that takes one and only one argument of a particular type. The identifier (<b>id1</b>, <b>id2</b>, and so on) can be used inside the handler, just like a method argument. Sometimes you never use the identifier because the type of the exception gives you enough information to deal with the exception, but the identifier must still be there. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1525" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The handlers must appear directly after the try block. If an exception is thrown, the exception handling mechanism goes hunting for the first handler with an argument that matches the type of the exception. Then it enters that catch clause, and the exception is considered handled. The search for handlers stops once the catch clause is finished. Only the matching catch clause executes; it&#146;s not like a <b>switch</b> statement in which you need a <b>break</b> after each <b>case</b> to prevent the remaining ones from executing. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1526" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that within the try block, a number of different method calls might generate the same exception, but you need only one handler. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1527" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading8371"></a>Termination vs. resumption<br></h4>
<p><a name="Index795"></a><a name="Index796"></a><a name="Index797"></a>There are two basic models in exception handling theory. In <i>termination</i> (which is what Java and C++ support), you assume that the error is so critical that there&#146;s no way to get back to where the exception occurred. Whoever threw the exception decided that there was no way to salvage the situation, and they don&#146;t <i>want</i> to come back. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1528" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The alternative is called <i>resumption</i>. It means that the exception handler is expected to do something to rectify the situation, and then the faulting method is retried, presuming success the second time. If you want resumption, it means you still hope to continue execution after the exception is handled. In this case, your exception is more like a method call&#151;which is how you should set up situations in Java in which you want resumption-like behavior. (That is, don&#146;t throw an exception; call a method that fixes the problem.) Alternatively, place your <b>try</b> block inside a <b>while</b> loop that keeps reentering the <b>try</b> block until the result is satisfactory. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1529" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Historically, programmers using operating systems that supported resumptive exception handling eventually ended up using termination-like code and skipping resumption. So although resumption sounds attractive at first, it isn&#146;t quite so useful in practice. The dominant reason is probably the <a name="Index798"></a><i>coupling </i>that results; your handler must often be aware of where the exception is thrown, and contain nongeneric code specific to the throwing location. This makes the code difficult to write and maintain, especially for large systems where the exception can be generated from many points. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1530" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545373"></a><a name="_Toc24775703"></a><a name="Heading8375"></a>Creating
your own exceptions</h2>
<p>You&#146;re not stuck using the existing Java exceptions. The JDK exception hierarchy can&#146;t foresee all the errors you might want to report, so you can create your own to denote a special problem that your library might encounter. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1531" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index799"></a>To create your own exception class, you must inherit from an existing exception class, preferably one that is close in meaning to your new exception (although this is often not possible). The most trivial way to create a new type of exception is just to let the compiler create the default constructor for you, so it requires almost no code at all:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:SimpleExceptionDemo.java</font>
<font color=#009900>// Inheriting your own exceptions.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> SimpleException <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleExceptionDemo {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> SimpleException {
    System.out.println(<font color=#004488>"Throw SimpleException from f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> SimpleException();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SimpleExceptionDemo sed = <font color=#0000ff>new</font> SimpleExceptionDemo();
    <font color=#0000ff>try</font> {
      sed.f();
    } <font color=#0000ff>catch</font>(SimpleException e) {
      System.err.println(<font color=#004488>"Caught it!"</font>);
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Throw SimpleException from f()"</font>,
      <font color=#004488>"Caught it!"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The compiler creates a default constructor, which automatically (and invisibly) calls the base-class default constructor. Of course, in this case you don&#146;t get a <b>SimpleException(String)</b> constructor, but in practice that isn&#146;t used much. As you&#146;ll see, the most important thing about an exception is the class name, so most of the time an exception like the one shown here is satisfactory. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1532" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here, the result is printed to the console <a name="Index800"></a><i>standard error</i> stream by writing to <a name="Index801"></a><b>System.err</b>. This is usually a better place to send error information than <b>System.out</b>, which may be redirected. If you send output to <b>System.err</b>, it will not be redirected along with <b>System.out</b> so the user is more likely to notice it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1533" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can also create an exception class that has a constructor with a <b>String</b> argument:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:FullConstructors.java</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> MyException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> MyException() {}
  <font color=#0000ff>public</font> MyException(String msg) { <font color=#0000ff>super</font>(msg); }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FullConstructors {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> MyException {
    System.out.println(<font color=#004488>"Throwing MyException from f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> MyException {
    System.out.println(<font color=#004488>"Throwing MyException from g()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException(<font color=#004488>"Originated in g()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(MyException e) {
      e.printStackTrace();
    }
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(MyException e) {
      e.printStackTrace();
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Throwing MyException from f()"</font>,
      <font color=#004488>"MyException"</font>,
      <font color=#004488>"%% \tat FullConstructors.f\\(.*\\)"</font>,
      <font color=#004488>"%% \tat FullConstructors.main\\(.*\\)"</font>,
      <font color=#004488>"Throwing MyException from g()"</font>,
      <font color=#004488>"MyException: Originated in g()"</font>,
      <font color=#004488>"%% \tat FullConstructors.g\\(.*\\)"</font>,
      <font color=#004488>"%% \tat FullConstructors.main\\(.*\\)"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The added code is small: two constructors that define the way <b>MyException</b> is created. In the second constructor, the base-class constructor with a <b>String</b> argument is explicitly invoked by using the <b>super</b> keyword. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1534" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the handlers, one of the <b>Throwable</b> (from which <b>Exception</b> is inherited) methods is called: <b>printStackTrace(&#160;)</b>. This produces information about the sequence of methods that were called to get to the point where the exception happened. By default, the information goes to the standard error stream, but overloaded versions allow you to send the results to any other stream as well. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1535" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The process of creating your own exceptions can be taken further. You can add extra constructors and members:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ExtraFeatures.java</font>
<font color=#009900>// Further embellishment of exception classes.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> MyException2 <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> x;
  <font color=#0000ff>public</font> MyException2() {}
  <font color=#0000ff>public</font> MyException2(String msg) { <font color=#0000ff>super</font>(msg); }
  <font color=#0000ff>public</font> MyException2(String msg, <font color=#0000ff>int</font> x) {
    <font color=#0000ff>super</font>(msg);
    <font color=#0000ff>this</font>.x = x;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> val() { <font color=#0000ff>return</font> x; }
  <font color=#0000ff>public</font> String getMessage() {
    <font color=#0000ff>return</font> <font color=#004488>"Detail Message: "</font>+ x + <font color=#004488>" "</font>+ <font color=#0000ff>super</font>.getMessage();
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ExtraFeatures {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(<font color=#004488>"Throwing MyException2 from f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(<font color=#004488>"Throwing MyException2 from g()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2(<font color=#004488>"Originated in g()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> h() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(<font color=#004488>"Throwing MyException2 from h()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2(<font color=#004488>"Originated in h()"</font>, 47);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace();
    }
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace();
    }
    <font color=#0000ff>try</font> {
      h();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace();
      System.err.println(<font color=#004488>"e.val() = "</font> + e.val());
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Throwing MyException2 from f()"</font>,
      <font color=#004488>"MyException2: Detail Message: 0 null"</font>,
      <font color=#004488>"%% \tat ExtraFeatures.f\\(.*\\)"</font>,
      <font color=#004488>"%% \tat ExtraFeatures.main\\(.*\\)"</font>,
      <font color=#004488>"Throwing MyException2 from g()"</font>,
      <font color=#004488>"MyException2: Detail Message: 0 Originated in g()"</font>,
      <font color=#004488>"%% \tat ExtraFeatures.g\\(.*\\)"</font>,
      <font color=#004488>"%% \tat ExtraFeatures.main\\(.*\\)"</font>,
      <font color=#004488>"Throwing MyException2 from h()"</font>,
      <font color=#004488>"MyException2: Detail Message: 47 Originated in h()"</font>,
      <font color=#004488>"%% \tat ExtraFeatures.h\\(.*\\)"</font>,
      <font color=#004488>"%% \tat ExtraFeatures.main\\(.*\\)"</font>,
      <font color=#004488>"e.val() = 47"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>A field <b>i</b> has been added, along with a method that reads that value and an additional constructor that sets it. In addition, <b>Throwable.getMessage(&#160;)</b> has been overridden to produce a more interesting detail message. <b>getMessage(&#160;) </b>is something like <b>toString(&#160;) </b>for exception classes. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1537" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Since an exception is just another kind of object, you can continue this process of embellishing the power of your exception classes. Keep in mind, however, that all this dressing-up might be lost on the client programmers using your packages, since they might simply look for the exception to be thrown and nothing more. (That&#146;s the way most of the Java library exceptions are used.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1538" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc312374116"></a><a name="_Toc375545367"></a><a name="_Toc24775704"></a><a name="Heading8521"></a>The
exception specification<br></h2>
<p><a name="Index802"></a><a name="Index803"></a>In Java, you&#146;re encouraged to inform the client programmer, who calls your method, of the exceptions that might be thrown from your method. This is civilized, because the caller can know exactly what code to write to catch all potential exceptions. Of course, if source code is available, the client programmer could hunt through and look for <b>throw</b> statements, but often a library doesn&#146;t come with sources. To prevent this from being a problem, Java provides syntax (and <i>forces </i>you to use that syntax) to allow you to politely tell the client programmer what exceptions this method throws, so the client programmer can handle them. This is the <i>exception specification</i> and it&#146;s part of the method declaration, appearing after the argument list. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1539" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The exception specification uses an additional keyword, <b>throws</b>, followed by a list of all the potential exception types. So your method definition might look like this:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> TooBig, TooSmall, DivZero { <font color=#009900>//... </font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>If you say<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> f() { <font color=#009900>// ...</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>it means that no exceptions are thrown from the method (<i>except </i>for the exceptions inherited from <b>RuntimeException</b>, which can be thrown anywhere without exception specifications&#151;this will be described later). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1540" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can&#146;t lie about an exception specification. If the code within your method causes exceptions, but your method doesn&#146;t handle them, the compiler will detect this and tell you that you must either handle the exception or indicate with an exception specification that it may be thrown from your method. By enforcing exception specifications from top to bottom, Java guarantees that a certain level of exception correctness can be ensured at compile time. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1541" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There is one place you can lie: You can claim to throw an exception that you really don&#146;t. The compiler takes your word for it, and forces the users of your method to treat it as if it really does throw that exception. This has the beneficial effect of being a placeholder for that exception, so you can actually start throwing the exception later without requiring changes to existing code. It&#146;s also important for creating <b>abstract</b> base classes and <b>interface</b>s whose derived classes or implementations may need to throw exceptions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1542" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Exceptions that are checked and enforced at compile time are called <i>checked exceptions</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0508" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc312374118"></a><a name="_Toc375545368"></a><a name="_Toc24775705"></a><a name="Heading8533"></a>Catching
any exception<br></h2>
<p><a name="Index804"></a><a name="Index805"></a>It is possible to create a handler that catches any type of exception. You do this by catching the base-class exception type <b>Exception</b> (there are other types of base exceptions, but <b>Exception</b> is the base that&#146;s pertinent to virtually all programming activities):<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>catch</font>(Exception e) {
  System.err.println(<font color=#004488>"Caught an exception"</font>);
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This will catch any exception, so if you use it you&#146;ll want to put it at the <i>end</i> of your list of handlers to avoid preempting any exception handlers that might otherwise follow it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1543" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Since the <b>Exception</b> class is the base of all the exception classes that are important to the programmer, you don&#146;t get much specific information about the exception, but you can call the methods that come from <i>its</i> base type <a name="Index806"></a><a name="Index807"></a><b>Throwable</b>:<br></p>
<p><b>String getMessage(&#160;)</b><br><b>String getLocalizedMessage(&#160;)</b><br>Gets the detail message, or a message adjusted for this particular locale. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1544" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>String toString(&#160;)</b><br>Returns a short description of the Throwable, including the detail message if there is one. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1545" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>void printStackTrace(&#160;) </b><br><a name="Index808"></a><b>void printStackTrace(PrintStream)</b><br><b>void printStackTrace(java.io.PrintWriter) </b><br>Prints the Throwable and the Throwable&#146;s call stack trace. The call stack shows the sequence of method calls that brought you to the point at which the exception was thrown. The first version prints to standard error, the second and third prints to a stream of your choice (in Chapter 12, you&#146;ll understand why there are two types of streams). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1546" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Throwable fillInStackTrace(&#160;)</b><br>Records information within this <b>Throwable </b>object about the current state of the stack frames. Useful when an application is rethrowing an error or exception (more about this shortly). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1547" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In addition, you get some other methods from <b>Throwable</b>&#146;s base type <b>Object</b> (everybody&#146;s base type). The one that might come in handy for exceptions is <a name="Index809"></a><a name="Index810"></a><b>getClass(&#160;)</b>, which returns an object representing the class of this object. You can in turn query this <b>Class</b> object for its name with <b>getName(&#160;)</b>. You can also do more sophisticated things with <b>Class</b> objects that aren&#146;t necessary in exception handling. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1548" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example that shows the use of the basic <b>Exception</b> methods:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ExceptionMethods.java</font>
<font color=#009900>// Demonstrating the Exception Methods.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ExceptionMethods {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Exception(<font color=#004488>"My Exception"</font>);
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(<font color=#004488>"Caught Exception"</font>);
      System.err.println(<font color=#004488>"getMessage():"</font> + e.getMessage());
      System.err.println(<font color=#004488>"getLocalizedMessage():"</font> +
        e.getLocalizedMessage());
      System.err.println(<font color=#004488>"toString():"</font> + e);
      System.err.println(<font color=#004488>"printStackTrace():"</font>);
      e.printStackTrace();
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Caught Exception"</font>,
      <font color=#004488>"getMessage():My Exception"</font>,
      <font color=#004488>"getLocalizedMessage():My Exception"</font>,
      <font color=#004488>"toString():java.lang.Exception: My Exception"</font>,
      <font color=#004488>"printStackTrace():"</font>,
      <font color=#004488>"java.lang.Exception: My Exception"</font>,
      <font color=#004488>"%% \tat ExceptionMethods.main\\(.*\\)"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that the methods provide successively more information&#151;each is effectively a superset of the previous one. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1549" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc312374119"></a><a name="_Toc375545369"></a><a name="_Toc24775706"></a><a name="Heading8578"></a>Rethrowing
an exception<br></h3>
<p><a name="Index811"></a><a name="Index812"></a>Sometimes you&#146;ll want to rethrow the exception that you just caught, particularly when you use <b>Exception</b> to catch any exception. Since you already have the reference to the current exception, you can simply rethrow that reference:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>catch</font>(Exception e) {
  System.err.println(<font color=#004488>"An exception was thrown"</font>);
  <font color=#0000ff>throw</font> e;
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Rethrowing an exception causes it to go to the exception handlers in the next-higher context. Any further <b>catch</b> clauses for the same <b>try</b> block are still ignored. In addition, everything about the exception object is preserved, so the handler at the higher context that catches the specific exception type can extract all the information from that object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1550" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you simply rethrow the current exception, the information that you print about that exception in <a name="Index813"></a><a name="Index814"></a><b>printStackTrace(&#160;) </b>will pertain to the exception&#146;s origin, not the place where you rethrow it. If you want to install new stack trace information, you can do so by calling <a name="Index815"></a><a name="Index816"></a><b>fillInStackTrace(&#160;)</b>, which returns a <b>Throwable</b> object that it creates by stuffing the current stack information into the old exception object. Here&#146;s what it looks like: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0145" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Rethrowing.java</font>
<font color=#009900>// Demonstrating fillInStackTrace()</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Rethrowing {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> Exception {
    System.out.println(<font color=#004488>"originating the exception in f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Exception(<font color=#004488>"thrown from f()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(<font color=#004488>"Inside g(),e.printStackTrace()"</font>);
      e.printStackTrace();
      <font color=#0000ff>throw</font> e; <font color=#009900>// 17</font>
      <font color=#009900>// throw e.fillInStackTrace(); // 18</font>
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  main(String[] args) <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(
        <font color=#004488>"Caught in main, e.printStackTrace()"</font>);
      e.printStackTrace();
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"originating the exception in f()"</font>,
      <font color=#004488>"Inside g(),e.printStackTrace()"</font>,
      <font color=#004488>"java.lang.Exception: thrown from f()"</font>,
      <font color=#004488>"%% \tat Rethrowing.f(.*?)"</font>,
      <font color=#004488>"%% \tat Rethrowing.g(.*?)"</font>,
      <font color=#004488>"%% \tat Rethrowing.main(.*?)"</font>,
      <font color=#004488>"Caught in main, e.printStackTrace()"</font>,
      <font color=#004488>"java.lang.Exception: thrown from f()"</font>,
      <font color=#004488>"%% \tat Rethrowing.f(.*?)"</font>,
      <font color=#004488>"%% \tat Rethrowing.g(.*?)"</font>,
      <font color=#004488>"%% \tat Rethrowing.main(.*?)"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The important line numbers are marked as comments. With line 17 uncommented (as shown), the output is as shown, so the exception stack trace always remembers its true point of origin no matter how many times it gets rethrown. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1551" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>With line 17 commented and line 18 uncommented, <b>fillInStackTrace(&#160;)</b> is used instead, and the result is:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>originating the exception in f()
Inside g(),e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.f(Rethrowing.java:9)
        at Rethrowing.g(Rethrowing.java:12)
        at Rethrowing.main(Rethrowing.java:23)
Caught in main, e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.g(Rethrowing.java:18)
        at Rethrowing.main(Rethrowing.java:23)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>(Plus additional complaints from the <b>Test.expect(&#160;) </b>method.) Because of <b>fillInStackTrace(&#160;)</b>, line 18 becomes the new point of origin of the exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1552" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index817"></a>The class <b>Throwable</b> must appear in the exception specification for <b>g(&#160;)</b> and <b>main(&#160;)</b> because <b>fillInStackTrace(&#160;)</b> produces a reference to a <b>Throwable</b> object. Since <b>Throwable</b><a name="Index818"></a> is a base class of <b>Exception</b>, it&#146;s possible to get an object that&#146;s a <b>Throwable</b> but <i>not</i> an <b>Exception</b>, so the handler for <b>Exception</b> in <b>main(&#160;) </b>might miss it. To make sure everything is in order, the compiler forces an exception specification for <b>Throwable</b>. For example, the exception in the following program is <i>not</i> caught in <b>main(&#160;)</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1553" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ThrowOut.java</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThrowOut {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  main(String[] args) <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Throwable();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(<font color=#004488>"Caught in main()"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>It&#146;s also possible to rethrow a different exception from the one you caught. If you do this, you get a similar effect as when you use <b>fillInStackTrace(&#160;)</b>&#151;the information about the original site of the exception is lost, and what you&#146;re left with is the information pertaining to the new <b>throw</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1554" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:RethrowNew.java</font>
<font color=#009900>// Rethrow a different object from the one that was caught.</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> OneException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> OneException(String s) { <font color=#0000ff>super</font>(s); }
}

<font color=#0000ff>class</font> TwoException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> TwoException(String s) { <font color=#0000ff>super</font>(s); }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> RethrowNew {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> OneException {
    System.out.println(<font color=#004488>"originating the exception in f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> OneException(<font color=#004488>"thrown from f()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  main(String[] args) <font color=#0000ff>throws</font> TwoException {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(OneException e) {
      System.err.println(
        <font color=#004488>"Caught in main, e.printStackTrace()"</font>);
      e.printStackTrace();
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> TwoException(<font color=#004488>"from main()"</font>);
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"originating the exception in f()"</font>,
      <font color=#004488>"Caught in main, e.printStackTrace()"</font>,
      <font color=#004488>"OneException: thrown from f()"</font>,
      <font color=#004488>"\tat RethrowNew.f(RethrowNew.java:18)"</font>,
      <font color=#004488>"\tat RethrowNew.main(RethrowNew.java:22)"</font>,
      <font color=#004488>"Exception in thread \"</font>main\<font color=#004488>" "</font> +
      <font color=#004488>"TwoException: from main()"</font>,
      <font color=#004488>"\tat RethrowNew.main(RethrowNew.java:28)"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The final exception knows only that it came from <b>main(&#160;)</b> and not from <b>f(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1555" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You never have to worry about cleaning up the previous exception, or any exceptions for that matter. They&#146;re all heap-based objects created with <b>new</b>, so the garbage collector automatically cleans them all up. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1556" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775707"></a><a name="Heading8705"></a>Exception chaining</h3>
<p>Often you want to catch one exception and throw another, but still keep the information about the originating exception&#151;this is called <i>exception chaining</i>. Prior to JDK 1.4, programmers had to write their own code to preserve the original exception information, but now all <b>Throwable</b> subclasses may take a <i>cause</i> object in their constructor. The <i>cause</i> is intended to be the originating exception, and by passing it in you maintain the stack trace back to its origin, even though you&#146;re creating and throwing a new exception at this point. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0509" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s interesting to note that the only <b>Throwable</b> subclasses that provide the <i>cause</i> argument in the constructor are the three fundamental exception classes <b>Error</b> (used by the JVM to report system errors), <b>Exception</b>, and <b>RuntimeException</b>. If you want to chain any other exception types, you do it through the <b>initCause(&#160;)</b> method rather than the constructor. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0510" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example that allows you to dynamically add fields to a <b>DynamicFields</b> object at run time:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:DynamicFields.java</font>
<font color=#009900>// A Class that dynamically adds fields to itself.</font>
<font color=#009900>// Demonstrates exception chaining.</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> DynamicFieldsException <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DynamicFields {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> Object[][] fields;
  <font color=#0000ff>public</font> DynamicFields(<font color=#0000ff>int</font> initialSize) {
    fields = <font color=#0000ff>new</font> Object[initialSize][2];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; initialSize; i++)
      fields[i] = <font color=#0000ff>new</font> Object[] { <font color=#0000ff>null</font>, <font color=#0000ff>null</font> };
  }
  <font color=#0000ff>public</font> String toString() {
    StringBuffer result = <font color=#0000ff>new</font> StringBuffer();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; fields.length; i++) {
      result.append(fields[i][0]);
      result.append(<font color=#004488>": "</font>);
      result.append(fields[i][1]);
      result.append(<font color=#004488>"\n"</font>);
    }
    <font color=#0000ff>return</font> result.toString();
  }
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> hasField(String id) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; fields.length; i++)
      <font color=#0000ff>if</font>(id.equals(fields[i][0]))
        <font color=#0000ff>return</font> i;
    <font color=#0000ff>return</font> -1;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>int</font>
  getFieldNumber(String id) <font color=#0000ff>throws</font> NoSuchFieldException {
    <font color=#0000ff>int</font> fieldNum = hasField(id);
    <font color=#0000ff>if</font>(fieldNum == -1)
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NoSuchFieldException();
    <font color=#0000ff>return</font> fieldNum;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> makeField(String id) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; fields.length; i++)
      <font color=#0000ff>if</font>(fields[i][0] == <font color=#0000ff>null</font>) {
        fields[i][0] = id;
        <font color=#0000ff>return</font> i;
      }
    <font color=#009900>// No empty fields. Add one:</font>
    Object[][]tmp = <font color=#0000ff>new</font> Object[fields.length + 1][2];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; fields.length; i++)
      tmp[i] = fields[i];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = fields.length; i &lt; tmp.length; i++)
      tmp[i] = <font color=#0000ff>new</font> Object[] { <font color=#0000ff>null</font>, <font color=#0000ff>null</font> };
    fields = tmp;
    <font color=#009900>// Reursive call with expanded fields:</font>
    <font color=#0000ff>return</font> makeField(id);
  }
  <font color=#0000ff>public</font> Object
  getField(String id) <font color=#0000ff>throws</font> NoSuchFieldException {
    <font color=#0000ff>return</font> fields[getFieldNumber(id)][1];
  }
  <font color=#0000ff>public</font> Object setField(String id, Object value)
  <font color=#0000ff>throws</font> DynamicFieldsException {
    <font color=#0000ff>if</font>(value == <font color=#0000ff>null</font>) {
      <font color=#009900>// Most exceptions don't have a "cause" constructor.</font>
      <font color=#009900>// In these cases you must use initCause(),</font>
      <font color=#009900>// available in all Throwable subclasses.</font>
      DynamicFieldsException dfe =
        <font color=#0000ff>new</font> DynamicFieldsException();
      dfe.initCause(<font color=#0000ff>new</font> NullPointerException());
      <font color=#0000ff>throw</font> dfe;
    }
    <font color=#0000ff>int</font> fieldNumber = hasField(id);
    <font color=#0000ff>if</font>(fieldNumber == -1)
      fieldNumber = makeField(id);
    Object result = <font color=#0000ff>null</font>;
    <font color=#0000ff>try</font> {
      result = getField(id); <font color=#009900>// Get old value</font>
    } <font color=#0000ff>catch</font>(NoSuchFieldException e) {
      <font color=#009900>// Use constructor that takes "cause":</font>
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
    }
    fields[fieldNumber][1] = value;
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    DynamicFields df = <font color=#0000ff>new</font> DynamicFields(3);
    System.out.println(df);
    <font color=#0000ff>try</font> {
      df.setField(<font color=#004488>"d"</font>, <font color=#004488>"A value for d"</font>);
      df.setField(<font color=#004488>"number"</font>, <font color=#0000ff>new</font> Integer(47));
      df.setField(<font color=#004488>"number2"</font>, <font color=#0000ff>new</font> Integer(48));
      System.out.println(df);
      df.setField(<font color=#004488>"d"</font>, <font color=#004488>"A new value for d"</font>);
      df.setField(<font color=#004488>"number3"</font>, <font color=#0000ff>new</font> Integer(11));
      System.out.println(df);
      System.out.println(df.getField(<font color=#004488>"d"</font>));
      Object field = df.getField(<font color=#004488>"a3"</font>); <font color=#009900>// Exception</font>
    } <font color=#0000ff>catch</font>(NoSuchFieldException e) {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
    } <font color=#0000ff>catch</font>(DynamicFieldsException e) {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"null: null"</font>,
      <font color=#004488>"null: null"</font>,
      <font color=#004488>"null: null"</font>,
      <font color=#004488>""</font>,
      <font color=#004488>"d: A value for d"</font>,
      <font color=#004488>"number: 47"</font>,
      <font color=#004488>"number2: 48"</font>,
      <font color=#004488>""</font>,
      <font color=#004488>"d: A new value for d"</font>,
      <font color=#004488>"number: 47"</font>,
      <font color=#004488>"number2: 48"</font>,
      <font color=#004488>"number3: 11"</font>,
      <font color=#004488>""</font>,
      <font color=#004488>"A value for d"</font>,
      <font color=#004488>"Exception in thread \"</font>main\<font color=#004488>" "</font> +
      <font color=#004488>"java.lang.RuntimeException: "</font> +
      <font color=#004488>"java.lang.NoSuchFieldException"</font>,
      <font color=#004488>"\tat DynamicFields.main(DynamicFields.java:98)"</font>,
      <font color=#004488>"Caused by: java.lang.NoSuchFieldException"</font>,
      <font color=#004488>"\tat DynamicFields.getFieldNumber("</font> +
      <font color=#004488>"DynamicFields.java:37)"</font>,
      <font color=#004488>"\tat DynamicFields.getField(DynamicFields.java:58)"</font>,
      <font color=#004488>"\tat DynamicFields.main(DynamicFields.java:96)"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Each <b>DynamicFields</b> object contains an array of <b>Object-Object</b> pairs. The first object is the field identifier (a <b>String</b>), and the second is the field value, which can be any type except an unwrapped primitive. When you create the object, you make an educated guess about how many fields you need. When you call <b>setField(&#160;)</b>, it either finds the existing field by that name or creates a new one, and puts in your value. If it runs out of space, it adds new space by creating an array of length one longer and copying the old elements in. If you try to put in a <b>null</b> value, then it throws a <b>DynamicFieldsException</b> by creating one and using <b>initCause(&#160;)</b> to insert a <b>NullPointerException</b> as the cause. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0511" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As a return value,<b> setField(&#160;)</b> also fetches out the old value at that field location using <b>getField(&#160;)</b>, which could throw a <b>NoSuchFieldException</b>. If the client programmer calls <b>getField(&#160;)</b>, then they are responsible for handling <b>NoSuchFieldException</b>, but if this exception is thrown inside <b>setField(&#160;)</b>, it&#146;s a programming error, so the <b>NoSuchFieldException</b> is converted to a <b>RuntimeException</b> using the constructor that takes a <i>cause</i> argument. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0512" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545370"></a><a name="_Toc24775708"></a><a name="Heading8840"></a>Standard
Java exceptions</h2>
<p>The Java class <b>Throwable</b> describes anything that can be thrown as an exception. There are two general types of <b>Throwable</b> objects (&#147;types of&#148; = &#147;inherited from&#148;). <a name="Index819"></a><b>Error</b> represents compile-time and system errors that you don&#146;t worry about catching (except in special cases). <a name="Index820"></a><b>Exception</b> is the basic type that can be thrown from any of the standard Java library class methods and from your methods and run-time accidents. So the Java programmer&#146;s base type of interest is usually <b>Exception</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1557" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The best way to get an overview of the exceptions is to browse the HTML Java documentation that you can download from <i>java.sun.com.</i> It&#146;s worth doing this once just to get a feel for the various exceptions, but you&#146;ll soon see that there isn&#146;t anything special between one exception and the next except for the name. Also, the number of exceptions in Java keeps expanding; basically, it&#146;s pointless to print them in a book. Any new library you get from a third-party vendor will probably have its own exceptions as well. The important thing to understand is the concept and what you should do with the exceptions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1558" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The basic idea is that the name of the exception represents the problem that occurred, and the exception name is intended to be relatively self-explanatory. The exceptions are not all defined in <b>java.lang</b>; some are created to support other libraries such as <b>util</b>, <b>net,</b> and <b>io</b>, which you can see from their full class names or what they are inherited from. For example, all I/O exceptions are inherited from <b>java.io.IOException</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1559" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545372"></a><a name="_Toc24775709"></a><a name="Heading8844"></a>The
special case of <b>RuntimeException</b></h3>
<p>The first example in this chapter was<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(t == <font color=#0000ff>null</font>)
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>It can be a bit horrifying to think that you must check for <b>null</b> on every reference that is passed into a method (since you can&#146;t know if the caller has passed you a valid reference). Fortunately, you don&#146;t&#151;this is part of the standard run-time checking that Java performs for you, and if any call is made to a <b>null</b> reference, Java will automatically throw a <a name="Index821"></a><a name="Index822"></a><b>NullPointerException</b>. So the above bit of code is always superfluous. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1560" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There&#146;s a whole group of exception types that are in this category. They&#146;re always thrown automatically by Java and you don&#146;t need to include them in your exception specifications. Conveniently enough, they&#146;re all grouped together by putting them under a single base class called <b>RuntimeException</b>, which is a perfect example of inheritance; It establishes a family of types that have some characteristics and behaviors in common. Also, you never need to write an exception specification saying that a method might throw a <b>RuntimeException</b> (or any type inherited from <b>RuntimeException</b>), because they are <i>unchecked exceptions</i>. Because they indicate bugs, you don&#146;t usually catch a <a name="Index823"></a><a name="Index824"></a><b>RuntimeException</b>&#151;it&#146;s dealt with automatically. If you were forced to check for <b>RuntimeException</b>s, your code could get too messy. Even though you don&#146;t typically catch <b>RuntimeExceptions</b>,<b> </b>in your own packages you might choose to throw some of the <b>RuntimeException</b>s. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1561" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>What happens when you don&#146;t catch such exceptions? Since the compiler doesn&#146;t enforce exception specifications for these, it&#146;s quite plausible that a <b>RuntimeException</b> could percolate all the way out to your <b>main(&#160;) </b>method without being caught. To see what happens in this case, try the following example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:NeverCaught.java</font>
<font color=#009900>// Ignoring RuntimeExceptions.</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NeverCaught {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(<font color=#004488>"From f()"</font>);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() {
    f();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    g();
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Exception in thread \"</font>main\<font color=#004488>" "</font> +
      <font color=#004488>"java.lang.RuntimeException: From f()"</font>,
      <font color=#004488>"        at NeverCaught.f(NeverCaught.java:7)"</font>,
      <font color=#004488>"        at NeverCaught.g(NeverCaught.java:10)"</font>,
      <font color=#004488>"        at NeverCaught.main(NeverCaught.java:13)"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can already see that a <b>RuntimeException </b>(or anything inherited from it) is a special case, since the compiler doesn&#146;t require an exception specification for these types. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1562" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>So the answer is: If a <b>RuntimeException</b> gets all the way out to <b>main(&#160;)</b> without being caught, <b>printStackTrace(&#160;)</b> is called for that exception as the program exits. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1563" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Keep in mind that you can only ignore exceptions of type <b>RuntimeException</b> (and subclasses) in your coding, since all other handling is carefully enforced by the compiler. The reasoning is that a <b>RuntimeException</b> represents a programming error:<br></p>
<ol>
<li>An error you cannot anticipate. For example, a <b>null</b> reference that is
outside of your control. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1564" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>An error that you, as a programmer, should have checked for in your code
(such as <b>ArrayIndexOutOfBoundsException</b> where you should have paid
attention to the size of the array). An exception that happens from point #1
often becomes an issue for point #2. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1565" title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>You can see what a tremendous benefit it is to have exceptions in this case, since they help in the debugging process. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1566" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s interesting to notice that you cannot classify Java exception handling as a single-purpose tool. Yes, it is designed to handle those pesky run-time errors that will occur because of forces outside your code&#146;s control, but it&#146;s also essential for certain types of programming bugs that the compiler cannot detect. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1567" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775710"></a><a name="Heading8884"></a>Performing cleanup <br>with
finally</h2>
<p>There&#146;s often some piece of code that you want to execute whether or not an exception is thrown within a <b>try</b> block. This usually pertains to some operation other than memory recovery (since that&#146;s taken care of by the garbage collector). To achieve this effect, you use a <a name="Index825"></a><a name="Index826"></a><b>finally</b> clause<sup><a name="fnB41" href="#fn41">[41]</a></sup> at the end of all the exception handlers. The full picture of an exception handling section is thus:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>try</font> {
  <font color=#009900>// The guarded region: Dangerous activities</font>
  <font color=#009900>// that might throw A, B, or C </font>
} <font color=#0000ff>catch</font>(A a1) {
  <font color=#009900>// Handler for situation A</font>
} <font color=#0000ff>catch</font>(B b1) {
  <font color=#009900>// Handler for situation B</font>
} <font color=#0000ff>catch</font>(C c1) {
  <font color=#009900>// Handler for situation C</font>
} <font color=#0000ff>finally</font> {
  <font color=#009900>// Activities that happen every time</font>
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>To demonstrate that the <b>finally</b> clause always runs, try this program: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1568" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:FinallyWorks.java</font>
<font color=#009900>// The finally clause is always executed.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> ThreeException <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FinallyWorks {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>try</font> {
        <font color=#009900>// Post-increment is zero first time:</font>
        <font color=#0000ff>if</font>(count++ == 0)
          <font color=#0000ff>throw</font> <font color=#0000ff>new</font> ThreeException();
        System.out.println(<font color=#004488>"No exception"</font>);
      } <font color=#0000ff>catch</font>(ThreeException e) {
        System.err.println(<font color=#004488>"ThreeException"</font>);
      } <font color=#0000ff>finally</font> {
        System.err.println(<font color=#004488>"In finally clause"</font>);
        <font color=#0000ff>if</font>(count == 2) <font color=#0000ff>break</font>; <font color=#009900>// out of "while"</font>
      }
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"ThreeException"</font>,
      <font color=#004488>"In finally clause"</font>,
      <font color=#004488>"No exception"</font>,
      <font color=#004488>"In finally clause"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>From the output, you can see that whether or not an exception is thrown, the <b>finally</b> clause is always executed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1570" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This program also gives a hint for how you can deal with the fact that exceptions in Java (like exceptions in C++) do not allow you to resume back to where the exception was thrown, as discussed earlier. If you place your <b>try</b> block in a loop, you can establish a condition that must be met before you continue the program. You can also add a <b>static</b> counter or some other device to allow the loop to try several different approaches before giving up. This way you can build a greater level of robustness into your programs. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1569" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545375"></a><a name="_Toc24775711"></a><a name="Heading8935"></a>What&#146;s
<b>finally</b> for?</h3>
<p>In a language without garbage collection <i>and</i> without automatic destructor calls,<a name="Index827"></a><sup><a name="fnB42" href="#fn42">[42]</a></sup> <b>finally</b> is important because it allows the programmer to guarantee the release of memory regardless of what happens in the <a name="Index828"></a><a name="Index829"></a><b>try</b> block. But Java has garbage collection, so releasing memory is virtually never a problem. Also, it has no destructors to call. So when do you need to use <a name="Index830"></a><b>finally</b> in Java? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1571" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>finally</b> clause is necessary when you need to set something <i>other</i> than memory back to its original state. This is some kind of cleanup like an open file or network connection, something you&#146;ve drawn on the screen, or even a switch in the outside world, as modeled in the following example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Switch.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Switch {
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> state = <font color=#0000ff>false</font>;
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> read() { <font color=#0000ff>return</font> state; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> on() { state = <font color=#0000ff>true</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> off() { state = <font color=#0000ff>false</font>; }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:OnOffException1.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> OnOffException1 <font color=#0000ff>extends</font> Exception {} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:OnOffException2.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> OnOffException2 <font color=#0000ff>extends</font> Exception {} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:OnOffSwitch.java</font>
<font color=#009900>// Why use finally?</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> OnOffSwitch {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Switch sw = <font color=#0000ff>new</font> Switch();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f()
  <font color=#0000ff>throws</font> OnOffException1,OnOffException2 {}
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      sw.on();
      <font color=#009900>// Code that can throw exceptions...</font>
      f();
      sw.off();
    } <font color=#0000ff>catch</font>(OnOffException1 e) {
      System.err.println(<font color=#004488>"OnOffException1"</font>);
      sw.off();
    } <font color=#0000ff>catch</font>(OnOffException2 e) {
      System.err.println(<font color=#004488>"OnOffException2"</font>);
      sw.off();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The goal here is to make sure that the switch is off when <b>main(&#160;)</b> is completed, so <b>sw.off(&#160;)</b> is placed at the end of the try block and at the end of each exception handler. But it&#146;s possible that an exception could be thrown that isn&#146;t caught here, so <b>sw.off(&#160;) </b>would be missed. However, with <b>finally</b> you can place the cleanup code from a try block in just one place: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1572" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:WithFinally.java</font>
<font color=#009900>// Finally Guarantees cleanup.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WithFinally {
  <font color=#0000ff>static</font> Switch sw = <font color=#0000ff>new</font> Switch();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      sw.on();
      <font color=#009900>// Code that can throw exceptions...</font>
      OnOffSwitch.f();
    } <font color=#0000ff>catch</font>(OnOffException1 e) {
      System.err.println(<font color=#004488>"OnOffException1"</font>);
    } <font color=#0000ff>catch</font>(OnOffException2 e) {
      System.err.println(<font color=#004488>"OnOffException2"</font>);
    } <font color=#0000ff>finally</font> {
      sw.off();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Here the <b>sw.off(&#160;)</b> has been moved to just one place, where it&#146;s guaranteed to run no matter what happens. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1573" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Even in cases in which the exception is not caught in the current set of <b>catch</b> clauses, <b>finally</b> will be executed before the exception handling mechanism continues its search for a handler at the next higher level:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:AlwaysFinally.java</font>
<font color=#009900>// Finally is always executed.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> FourException <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlwaysFinally {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Entering first try block"</font>);
    <font color=#0000ff>try</font> {
      System.out.println(<font color=#004488>"Entering second try block"</font>);
      <font color=#0000ff>try</font> {
        <font color=#0000ff>throw</font> <font color=#0000ff>new</font> FourException();
      } <font color=#0000ff>finally</font> {
        System.out.println(<font color=#004488>"finally in 2nd try block"</font>);
      }
    } <font color=#0000ff>catch</font>(FourException e) {
      System.err.println(
        <font color=#004488>"Caught FourException in 1st try block"</font>);
    } <font color=#0000ff>finally</font> {
      System.err.println(<font color=#004488>"finally in 1st try block"</font>);
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Entering first try block"</font>,
      <font color=#004488>"Entering second try block"</font>,
      <font color=#004488>"finally in 2nd try block"</font>,
      <font color=#004488>"Caught FourException in 1st try block"</font>,
      <font color=#004488>"finally in 1st try block"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>finally</b> statement will also be executed in situations in which <b>break</b> and <b>continue</b> statements are involved. Note that, along with the labeled <b>break</b> and labeled <b>continue</b>, <b>finally</b> eliminates the need for a <b>goto </b>statement in Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1575" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775712"></a><a name="Heading9033"></a>Pitfall: the lost
exception</h3>
<p>Unfortunately, there&#146;s a flaw in Java&#146;s exception implementation. Although exceptions are an indication of a crisis in your program and should never be ignored, it&#146;s possible for an exception to simply be lost. This happens with a particular configuration using a <a name="Index831"></a><a name="Index832"></a><b>finally</b> clause: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0146" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:LostMessage.java</font>
<font color=#009900>// How an exception can be lost.</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> VeryImportantException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"A very important exception!"</font>;
  }
}

<font color=#0000ff>class</font> HoHumException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"A trivial exception"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LostMessage {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> VeryImportantException {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> VeryImportantException();
  }
  <font color=#0000ff>void</font> dispose() <font color=#0000ff>throws</font> HoHumException {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> HoHumException();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    LostMessage lm = <font color=#0000ff>new</font> LostMessage();
    <font color=#0000ff>try</font> {
      lm.f();
    } <font color=#0000ff>finally</font> {
      lm.dispose();
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Exception in thread \"</font>main\<font color=#004488>" A trivial exception"</font>,
      <font color=#004488>"\tat LostMessage.dispose(LostMessage.java:24)"</font>,
      <font color=#004488>"\tat LostMessage.main(LostMessage.java:31)"</font>
    });  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that there&#146;s no evidence of the <b>VeryImportantException</b>, which is simply replaced by the <b>HoHumException</b> in the <b>finally</b> clause. This is a rather serious pitfall, since it means that an exception can be completely lost, and in a far more subtle and difficult-to-detect fashion than the preceding example. In contrast, C++ treats the situation in which a second exception is thrown before the first one is handled as a dire programming error. Perhaps a future version of Java will repair this problem (on the other hand, you will typically wrap any method that throws an exception, such as <b>dispose(&#160;)</b>, inside a <b>try-catch</b> clause). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1576" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545374"></a><a name="_Toc24775713"></a><a name="Heading9075"></a>Exception
restrictions<br></h2>
<p><a name="Index833"></a><a name="Index834"></a>When you override a method, you can throw only the exceptions that have been specified in the base-class version of the method. This is a useful restriction, since it means that code that works with the base class will automatically work with any object derived from the base class (a fundamental OOP concept, of course), including exceptions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1577" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This example demonstrates the kinds of restrictions imposed (at compile time) for exceptions:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:StormyInning.java</font>
<font color=#009900>// Overridden methods may throw only the exceptions</font>
<font color=#009900>// specified in their base-class versions, or exceptions</font>
<font color=#009900>// derived from the base-class exceptions.</font>

<font color=#0000ff>class</font> BaseballException <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> Foul <font color=#0000ff>extends</font> BaseballException {}
<font color=#0000ff>class</font> Strike <font color=#0000ff>extends</font> BaseballException {}

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Inning {
  <font color=#0000ff>public</font> Inning() <font color=#0000ff>throws</font> BaseballException {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> event() <font color=#0000ff>throws</font> BaseballException {
    <font color=#009900>// Doesn't actually have to throw anything</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> atBat() <font color=#0000ff>throws</font> Strike, Foul;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> walk() {} <font color=#009900>// Throws no checked exceptions</font>
}

<font color=#0000ff>class</font> StormException <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> RainedOut <font color=#0000ff>extends</font> StormException {}
<font color=#0000ff>class</font> PopFoul <font color=#0000ff>extends</font> Foul {}

<font color=#0000ff>interface</font> Storm {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> event() <font color=#0000ff>throws</font> RainedOut;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> rainHard() <font color=#0000ff>throws</font> RainedOut;
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StormyInning <font color=#0000ff>extends</font> Inning <font color=#0000ff>implements</font> Storm {
  <font color=#009900>// OK to add new exceptions for constructors, but you</font>
  <font color=#009900>// must deal with the base constructor exceptions:</font>
  <font color=#0000ff>public</font> StormyInning() 
    <font color=#0000ff>throws</font> RainedOut, BaseballException {}
  <font color=#0000ff>public</font> StormyInning(String s) 
    <font color=#0000ff>throws</font> Foul, BaseballException {}
  <font color=#009900>// Regular methods must conform to base class:</font>
<font color=#009900>//! void walk() throws PopFoul {} //Compile error</font>
  <font color=#009900>// Interface CANNOT add exceptions to existing</font>
  <font color=#009900>// methods from the base class:</font>
<font color=#009900>//! public void event() throws RainedOut {}</font>
  <font color=#009900>// If the method doesn't already exist in the</font>
  <font color=#009900>// base class, the exception is OK:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> rainHard() <font color=#0000ff>throws</font> RainedOut {}
  <font color=#009900>// You can choose to not throw any exceptions,</font>
  <font color=#009900>// even if the base version does:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> event() {}
  <font color=#009900>// Overridden methods can throw inherited exceptions:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> atBat() <font color=#0000ff>throws</font> PopFoul {}
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      StormyInning si = <font color=#0000ff>new</font> StormyInning();
      si.atBat();
    } <font color=#0000ff>catch</font>(PopFoul e) {
      System.err.println(<font color=#004488>"Pop foul"</font>);
    } <font color=#0000ff>catch</font>(RainedOut e) {
      System.err.println(<font color=#004488>"Rained out"</font>);
    } <font color=#0000ff>catch</font>(BaseballException e) {
      System.err.println(<font color=#004488>"Generic baseball exception"</font>);
    }
    <font color=#009900>// Strike not thrown in derived version.</font>
    <font color=#0000ff>try</font> {
      <font color=#009900>// What happens if you upcast?</font>
      Inning i = <font color=#0000ff>new</font> StormyInning();
      i.atBat();
      <font color=#009900>// You must catch the exceptions from the</font>
      <font color=#009900>// base-class version of the method:</font>
    } <font color=#0000ff>catch</font>(Strike e) {
      System.err.println(<font color=#004488>"Strike"</font>);
    } <font color=#0000ff>catch</font>(Foul e) {
      System.err.println(<font color=#004488>"Foul"</font>);
    } <font color=#0000ff>catch</font>(RainedOut e) {
      System.err.println(<font color=#004488>"Rained out"</font>);
    } <font color=#0000ff>catch</font>(BaseballException e) {
      System.err.println(<font color=#004488>"Generic baseball exception"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In <b>Inning</b>, you can see that both the constructor and the <b>event(&#160;)</b> method say they will throw an exception, but they never do. This is legal because it allows you to force the user to catch any exceptions that might be added in overridden versions of <b>event(&#160;)</b>. The same idea holds for <b>abstract</b> methods, as seen in <b>atBat(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1578" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>interface Storm</b> is interesting because it contains one method (<b>event(&#160;)</b>) that is defined in <b>Inning</b>, and one method that isn&#146;t. Both methods throw a new type of exception, <b>RainedOut</b>. When <b>StormyInning</b> <b>extends Inning</b> and <b>implements Storm</b>, you&#146;ll see that the <b>event(&#160;)</b> method in <b>Storm</b> <i>cannot</i> change the exception interface of <b>event(&#160;)</b> in <b>Inning</b>. Again, this makes sense because otherwise you&#146;d never know if you were catching the correct thing when working with the base class. Of course, if a method described in an <b>interface</b> is not in the base class, such as <b>rainHard(&#160;)</b>,<b> </b>then there&#146;s no problem if it throws exceptions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1579" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The restriction on exceptions does not apply to constructors. You can see in <a name="Index835"></a><a name="Index836"></a><b>StormyInning </b>that a constructor can throw anything it wants, regardless of what the base-class constructor throws. However, since a base-class constructor must always be called one way or another (here, the default constructor is called automatically), the derived-class constructor must declare any base-class constructor exceptions in its exception specification. Note that a derived-class constructor cannot catch exceptions thrown by its base-class constructor. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1580" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The reason <b>StormyInning.walk(&#160;)</b> will not compile is that it throws an exception, but <b>Inning.walk(&#160;)</b> does not. If this were allowed, then you could write code that called <b>Inning.walk(&#160;)</b> and that didn&#146;t have to handle any exceptions, but then when you substituted an object of a class derived from <b>Inning</b>, exceptions would be thrown so your code would break. By forcing the derived-class methods to conform to the exception specifications of the base-class methods, substitutability of objects is maintained. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1581" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The overridden <b>event(&#160;)</b> method shows that a derived-class version of a method may choose not to throw any exceptions, even if the base-class version does. Again, this is fine since it doesn&#146;t break any code that is written&#151;assuming the base-class version throws exceptions. Similar logic applies to <b>atBat(&#160;)</b>, which throws <b>PopFoul</b>, an exception that is derived from <b>Foul</b> thrown by the base-class version of <b>atBat(&#160;)</b>. This way, if you write code that works with <b>Inning</b> and calls <b>atBat(&#160;)</b>, you must catch the <b>Foul</b> exception. Since <b>PopFoul</b> is derived from <b>Foul</b>, the exception handler will also catch <b>PopFoul</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1582" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The last point of interest is in <b>main(&#160;)</b>. Here, you can see that if you&#146;re dealing with exactly a <b>StormyInning</b> object, the compiler forces you to catch only the exceptions that are specific to that class, but if you upcast to the base type, then the compiler (correctly) forces you to catch the exceptions for the base type. All these constraints produce much more robust exception-handling code.<sup><a name="fnB43" href="#fn43">[43]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1583" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s useful to realize that although exception specifications are enforced by the compiler during inheritance, the exception specifications are not part of the type of a method, which comprises only the method name and argument types. Therefore, you cannot overload methods based on exception specifications. In addition, just because an exception specification exists in a base-class version of a method doesn&#146;t mean that it must exist in the derived-class version of the method. This is quite different from inheritance rules, where a method in the base class must also exist in the derived class. Put another way, the &#147;exception specification interface&#148; for a particular method may narrow during inheritance and overriding, but it may not widen&#151;this is precisely the opposite of the rule for the class interface during inheritance. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1584" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc305593300"></a><a name="_Toc305628772"></a><a name="_Toc312374122"></a><a name="_Toc375545376"></a><a name="_Toc24775714"></a><a name="Heading9163"></a>Constructors<br></h2>
<p><a name="Index837"></a><a name="Index838"></a>When writing code with exceptions, it&#146;s particularly important that you always ask &#147;If an exception occurs, will this be properly cleaned up?&#148; Most of the time you&#146;re fairly safe, but in constructors there&#146;s a problem. The constructor puts the object into a safe starting state, but it might perform some operation&#151;such as opening a file&#151;that doesn&#146;t get cleaned up until the user is finished with the object and calls a special cleanup method. If you throw an exception from inside a constructor, these cleanup behaviors might not occur properly. This means that you must be especially diligent while you write your constructor. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1585" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Since you&#146;ve just learned about <a name="Index839"></a><a name="Index840"></a><b>finally</b>, you might think that it is the correct solution. But it&#146;s not quite that simple, because <b>finally </b>performs the cleanup code <i>every time,</i> even in the situations in which you don&#146;t want the cleanup code executed until the cleanup method runs. Thus, if you do perform cleanup in <b>finally</b>, you must set some kind of flag when the constructor finishes normally so that you don&#146;t do anything in the <b>finally</b> block if the flag is set. Because this isn&#146;t particularly elegant (you are coupling your code from one place to another), it&#146;s best if you try to avoid performing this kind of cleanup in <b>finally</b> unless you are forced to. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1586" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the following example, a class called <b>InputFile</b> is created that opens a file and allows you to read it one line (converted into a <b>String</b>) at a time. It uses the classes <a name="Index841"></a><a name="Index842"></a><b>FileReader</b> and <a name="Index843"></a><a name="Index844"></a><b>BufferedReader</b> from the Java standard I/O library that will be discussed in Chapter 12, but which are simple enough that you probably won&#146;t have any trouble understanding their basic use:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Cleanup.java</font>
<font color=#009900>// Paying attention to exceptions in constructors.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> InputFile {
  <font color=#0000ff>private</font> BufferedReader in;
  <font color=#0000ff>public</font> InputFile(String fname) <font color=#0000ff>throws</font> Exception {
    <font color=#0000ff>try</font> {
      in = <font color=#0000ff>new</font> BufferedReader(<font color=#0000ff>new</font> FileReader(fname));
      <font color=#009900>// Other code that might throw exceptions</font>
    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.err.println(<font color=#004488>"Could not open "</font> + fname);
      <font color=#009900>// Wasn't open, so don't close it</font>
      <font color=#0000ff>throw</font> e;
    } <font color=#0000ff>catch</font>(Exception e) {
      <font color=#009900>// All other exceptions must close it</font>
      <font color=#0000ff>try</font> {
        in.close();
      } <font color=#0000ff>catch</font>(IOException e2) {
        System.err.println(<font color=#004488>"in.close() unsuccessful"</font>);
      }
      <font color=#0000ff>throw</font> e; <font color=#009900>// Rethrow</font>
    } <font color=#0000ff>finally</font> {
      <font color=#009900>// Don't close it here!!!</font>
    }
  }
  <font color=#0000ff>public</font> String getLine() {
    String s;
    <font color=#0000ff>try</font> {
      s = in.readLine();
    } <font color=#0000ff>catch</font>(IOException e) {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(<font color=#004488>"readLine() failed"</font>);
    }
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> dispose() {
    <font color=#0000ff>try</font> {
      in.close();
      System.out.println(<font color=#004488>"dispose() successful"</font>);
    } <font color=#0000ff>catch</font>(IOException e2) {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(<font color=#004488>"in.close() failed"</font>);
    }
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Cleanup {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      InputFile in = <font color=#0000ff>new</font> InputFile(<font color=#004488>"Cleanup.java"</font>);
      String s;
      <font color=#0000ff>int</font> i = 1;
      <font color=#0000ff>while</font>((s = in.getLine()) != <font color=#0000ff>null</font>)
        ; <font color=#009900>// Perform line-by-line processing here...</font>
      in.dispose();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(<font color=#004488>"Caught Exception in main"</font>);
      e.printStackTrace();
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"dispose() successful"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The constructor for <b>InputFile</b> takes a <b>String</b> argument, which is the name of the file you want to open. Inside a <b>try</b> block, it creates a <b>FileReader</b> using the file name. A <b>FileReader</b> isn&#146;t particularly useful until you turn around and use it to create a <b>BufferedReader</b> that you can actually talk to&#151;notice that one of the benefits of <b>InputFile</b> is that it combines these two actions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1587" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If the <b>FileReader</b> constructor is unsuccessful, it throws a <a name="Index845"></a><a name="Index846"></a><b>FileNotFoundException</b>, which must be caught separately. This is the one case in which you don&#146;t want to close the file, because it wasn&#146;t successfully opened. Any <i>other</i> catch clauses must close the file because it <i>was</i> opened by the time those catch clauses are entered. (Of course, this is trickier if more than one method can throw a <b>FileNotFoundException</b>. In that case, you might want to break things into several <b>try </b>blocks.) The <b>close(&#160;)</b> method might throw an exception so it is tried and caught even though it&#146;s within the block of another <b>catch</b> clause&#151;it&#146;s just another pair of curly braces to the Java compiler. After performing local operations, the exception is rethrown, which is appropriate because this constructor failed, and you wouldn&#146;t want the calling method to assume that the object had been properly created and was valid. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1588" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In this example, which doesn&#146;t use the aforementioned flagging technique, the <b>finally</b> clause is definitely <i>not</i> the place to <b>close(&#160;)</b> the file, since that would close it every time the constructor completed. Because we want the file to be open for the useful lifetime of the <b>InputFile</b> object, this would not be appropriate. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1589" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>getLine(&#160;)</b> method returns a <b>String</b> containing the next line in the file. It calls <a name="Index847"></a><a name="Index848"></a><b>readLine(&#160;),</b> which can throw an exception, but that exception is caught so <b>getLine(&#160;)</b> doesn&#146;t throw any exceptions. One of the design issues with exceptions is whether to handle an exception completely at this level, to handle it partially and pass the same exception (or a different one) on, or whether to simply pass it on. Passing it on, when appropriate, can certainly simplify coding. In this situation, the <a name="Index849"></a><b>getLine(&#160;)</b> method <i>converts</i> the exception to a <b>RuntimeException</b> to indicate a programming error. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1590" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>dispose(&#160;)</b> method must be called by the user when finished using the <b>InputFile</b> object. This will release the system resources (such as file handles) that are used by the <b>BufferedReader</b> and/or <b>FileReader</b> objects. You don&#146;t want to do this until you&#146;re finished with the <b>InputFile</b> object, at the point you&#146;re going to let it go. You might think of putting such functionality into a <a name="Index850"></a><b>finalize(&#160;)</b> method, but as mentioned in Chapter 4, you can&#146;t always be sure that <b>finalize(&#160;)</b> will be called (even if you <i>can</i> be sure that it will be called, you don&#146;t know <i>when</i>). This is one of the downsides to Java; All cleanup&#151;other than memory cleanup&#151;doesn&#146;t happen automatically, so you must inform the client programmer that they are responsible, and possibly guarantee that cleanup occurs using <b>finalize(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1591" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In <b>Cleanup.java</b> an <b>InputFile</b> is created to open the same source file that creates the program, the file is read in a line at a time, and line numbers are added. All exceptions are caught generically in <b>main(&#160;)</b>, although you could choose greater granularity. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1592" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One of the benefits of this example is to show you why exceptions are introduced at this point in the book&#151;there are many libraries (like I/O, mentioned earlier) that you can&#146;t use without dealing with exceptions. Exceptions are so integral to programming in Java, especially because the compiler enforces them, that you can accomplish only so much without knowing how to work with them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1593" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc305593301"></a><a name="_Toc305628773"></a><a name="_Toc312374124"></a><a name="_Toc375545377"></a><a name="_Toc24775715"></a><a name="Heading9240"></a>Exception
matching<br></h2>
<p><a name="Index851"></a><a name="Index852"></a>When an exception is thrown, the exception handling system looks through the &#147;nearest&#148; handlers in the order they are written. When it finds a match, the exception is considered handled, and no further searching occurs. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1594" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Matching an exception doesn&#146;t require a perfect match between the exception and its handler. A derived-class object will match a handler for the base class, as shown in this example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Human.java</font>
<font color=#009900>// Catching exception hierarchies.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>class</font> Annoyance <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> Sneeze <font color=#0000ff>extends</font> Annoyance {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Human {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Sneeze s) {
      System.err.println(<font color=#004488>"Caught Sneeze"</font>);
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.err.println(<font color=#004488>"Caught Annoyance"</font>);
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Caught Sneeze"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>Sneeze</b> exception will be caught by the first <b>catch</b> clause that it matches, which is the first one, of course. However, if you remove the first catch clause, leaving only: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1595" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.err.println(<font color=#004488>"Caught Annoyance"</font>);
    }</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>the code will still work because it&#146;s catching the base class of <b>Sneeze</b>. Put another way, <b>catch(Annoyance e)</b> will catch an <b>Annoyance</b> <i>or any class derived from it</i>. This is useful because if you decide to add more derived exceptions to a method, then the client programmer&#146;s code will not need changing as long as the client catches the base class exceptions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1596" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you try to &#147;mask&#148; the derived-class exceptions by putting the base-class catch clause first, like this:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.err.println(<font color=#004488>"Caught Annoyance"</font>);
    } <font color=#0000ff>catch</font>(Sneeze s) {
      System.err.println(<font color=#004488>"Caught Sneeze"</font>);
    }</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>the compiler will give you an error message, since it sees that the <b>Sneeze</b> catch-clause can never be reached. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1597" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc312374128"></a><a name="_Toc375545378"></a><a name="_Toc24775716"></a><a name="Heading9284"></a>Alternative
approaches</h2>
<p>An exception-handling system is a trap door that allows your program to abandon execution of the normal sequence of statements. The trap door is used when an &#147;exceptional condition&#148; occurs, such that normal execution is no longer possible or desirable. Exceptions represent conditions that the current method is unable to handle. The reason exception handling systems were developed is because the approach of dealing with each possible error condition produced by each function call was too onerous, and programmers simply weren&#146;t doing it. As a result, they were ignoring the errors. It&#146;s worth observing that the issue of programmer convenience in handling errors was a prime motivation for exceptions in the first place. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0515" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One of the important guidelines in exception handling is &#147;don&#146;t catch an exception unless you know what to do with it.&#148; In fact, one of the important <i>goals</i> of exception handling is to move the error-handling code away from the point where the errors occur. This allows you to focus on what you want to accomplish in one section of your code, and how you&#146;re going to deal with problems in a distinct separate section of your code. As a result, your mainline code is not cluttered with error-handling logic, and it&#146;s much easier to understand and maintain. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0513" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index855"></a><a name="Index856"></a>Checked exceptions complicate this scenario a bit, because they force you to add catch clauses in places where you may not be ready to handle an error. This results in the &#147;harmful if swallowed&#148; problem:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>try</font> {
  <font color=#009900>// ... to do something useful</font>
} <font color=#0000ff>catch</font>(ObligatoryException e) {} <font color=#009900>// Gulp!</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Programmers (myself included, in the first edition of this book) would just do the simplest thing, and swallow the exception&#151;often unintentionally, but once you do it, the compiler has been satisfied, so unless you remember to revisit and correct the code, the exception will be lost. The exception happens, but it vanishes completely when swallowed. Because the compiler forces you to write code right away to handle the exception, this seems like the easiest solution even though it&#146;s probably the worst thing you can do. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0514" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Horrified upon realizing that I had done this, in the second edition I &#147;fixed&#148; the problem by printing the stack trace inside the handler (as is still seen&#151;appropriately&#151;in a number of examples in this chapter). While this is useful to trace the behavior of exceptions, it still indicates that you don&#146;t really know what to do with the exception at that point in your code. In this section we&#146;ll look at some of the issues and complications arising from checked exceptions, and options that you have when dealing with them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0516" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This topic seems simple. But it is not only complicated, it is also an issue of some volatility. There are people who are staunchly rooted on either side of the fence and who feel that the correct answer (theirs) is blatantly obvious. I believe the reason for one of these positions is the distinct benefit seen in going from a poorly-typed language like pre-ANSI C to a strong, statically-typed language (that is, checked at compile-time) like C++ or Java. When you make that transition (as I did), the benefits are so dramatic that it can seem like strong static type checking is always the best answer to most problems. My hope is to relate a little bit of my own evolution, that has brought the <a name="Index857"></a><a name="Index858"></a><a name="Index859"></a><i>absolute</i> value of strong static type checking into question; clearly, it&#146;s very helpful much of the time, but there&#146;s a fuzzy line we cross when it begins to get in the way and become a hindrance (one of my favorite quotes is: &#147;All models are wrong. Some are useful.&#148;). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0517" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775717"></a><a name="Heading9295"></a>History</h3>
<p>Exception handling originated in systems like PL/1 and Mesa, and later appeared in CLU, Smalltalk, Modula-3, Ada, Eiffel, C++, Python, Java, and the post-Java languages Ruby and C#. The Java design is similar to C++, except in places where the Java designers felt that the C++ design caused problems. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0518" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To provide programmers with a framework that they were more likely to use for error handling and recovery, exception handling was added to C++ rather late in the standardization process, promoted by Bjarne Stroustrup, the language&#146;s original author. The model for C++ exceptions came primarily from CLU. However, other languages existed at that time that also supported exception handling: Ada, Smalltalk (both of which had exceptions but no exception specifications) and Modula-3 (which included both exceptions and specifications). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0519" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index860"></a>In their seminal paper<sup><a name="fnB44" href="#fn44">[44]</a></sup> on the subject, Liskov and Snyder note that a major defect of languages like C that <a name="Index861"></a>report errors in a transient fashion is that:<br></p>
<p><i>&#147;...every invocation must be followed by a conditional test to determine what the outcome was. This requirement leads to programs that are difficult to read, and probably inefficient as well, thus discouraging programmers from signaling and handling exceptions.&#148;</i><br></p>
<p>Note that one of the original motivations of exception handling was to prevent this requirement, but with checked exceptions in Java we commonly see exactly this kind of code. They go on to say:<br></p>
<p><i>&#147;...requiring that the text of a handler be attached to the invocation that raises the exception would lead to unreadable programs in which expressions were broken up with handlers.&#148; </i><font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0520" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Following the CLU approach when designing C++ exceptions, Stroustrup stated that the goal was to reduce the amount of code required to recover from errors. I believe that he was observing that programmers were typically not writing error-handling code in C because the amount and placement of such code was daunting and distracting. As a result, they were used to doing it the C way, ignoring errors in code and using debuggers to track down problems. To use exceptions, these C programmers had to be convinced to write &#147;additional&#148; code that they weren&#146;t normally writing. Thus, to draw them into a better way of handling errors, the amount of code they would need to &#147;add&#148; must not be onerous. I think it&#146;s important to keep this goal in mind when looking at the effects of checked exceptions in Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0521" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>C++ brought an additional idea over from CLU: the exception specification, to programmatically state in the method signature what exceptions may result from calling that method. The exception specification really has two purposes. It can say &#147;I&#146;m originating this exception in my code, you handle it.&#148; But it can also mean &#147;I&#146;m ignoring this exception that can occur as a result of my code, you handle it.&#148; We&#146;ve been focusing on the &#147;you handle it&#148; part when looking at the mechanics and syntax of exceptions, but here I&#146;m particularly interested in the fact that often we ignore exceptions and that&#146;s what the exception specification can state. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0522" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index862"></a><a name="Index863"></a>In C++ the exception specification is not part of the type information of a function. The only compile-time checking is to ensure that exception specifications are used consistently; for example, if a function or method throws exceptions, then the overloaded or derived versions must also throw those exceptions. Unlike Java, however, no compile-time checking occurs to determine whether or not the function or method will actually throw that exception, or whether the exception specification is complete (that is, whether it accurately describes all exceptions that may be thrown). That validation does happen, but only at run time. If an exception is thrown that violates the exception specification, the C++ program will call the standard library function <b>unexpected(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0523" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It is interesting to note that, because of the use of templates, exception specifications are not used at all in the standard C++ library. Exception specifications, then, may have a significant impact on the design of Java <a name="Index864"></a><a name="Index865"></a><i>generics</i> (Java&#146;s version of C++ templates, expected to appear in JDK 1.5). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0524" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775718"></a><a name="Heading9307"></a>Perspectives</h3>
<p>First, it&#146;s worth noting that Java effectively invented the checked exception (clearly inspired by C++ exception specifications and the fact that C++ programmers typically don&#146;t bother with them). It has been an experiment, which no language since has chosen to duplicate. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0525" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Secondly, checked exceptions appear to be an obvious good thing when seen in introductory examples and in small programs. It has been suggested that the subtle difficulties begin to appear when programs start to get large. Of course, largeness usually doesn&#146;t happen overnight; it creeps. Languages that may not be suited for large-scale projects are used for small projects that grow, and at some point we realize that things have gone from manageable to difficult. This is what I&#146;m suggesting may be the case with too much type checking; in particular, with checked exceptions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0526" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The scale of the program seems to be a significant issue. This is a problem because most discussions tend to use small programs as demonstrations. One of the C# designers observed that:<br></p>
<p><i>&#147;Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result&#151;decreased productivity and little or no increase in code quality.&#148;</i><sup> <a name="fnB45" href="#fn45">[45]</a></sup><i> </i><font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0527" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In reference to uncaught exceptions, the CLU creators stated:<br></p>
<p><i>&#147;We felt it was unrealistic to require the programmer to provide handlers in situations where no meaningful action can be taken.&#148;</i><sup> <a name="fnB46" href="#fn46">[46]</a></sup><i> </i><font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0528" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When explaining why a function declaration with no specification means that it can throw <i>any</i> exception, rather than <i>no</i> exceptions, Stroustrup states:<br></p>
<p><i>&#147;However, that would require exception specifications for essentially every function, would be a significant cause for recompilation, and would inhibit cooperation with software written in other languages. This would encourage programmers to subvert the exception-handling mechanisms and to write spurious code to suppress exceptions. It would provide a false sense of security to people who failed to notice the exception.&#148;</i><sup> <a name="fnB47" href="#fn47">[47]</a></sup><br></p>
<p>We see this very behavior&#151;subverting the exceptions&#151;happening with checked exceptions in Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0529" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index866"></a>Martin Fowler (author of <i>UML Distilled</i>, <i>Refactoring</i>, and <i>Analysis Patterns</i>) wrote the following to me:<br></p>
<p><i>&#147;...on the whole I think that exceptions are good, but Java checked exceptions are more trouble than they are worth.&#148;</i> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0530" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>I now think that Java&#146;s important step was to unify the error reporting model, so that all errors are <i>reported</i> using exceptions. This wasn&#146;t happening with C++, because for backward compatibility with C the old model of just ignoring errors was still available. But if you have consistent reporting with exceptions, then the exceptions can be used if desired, and if not, they will propagate out to the highest level (the console or other container program). When Java changed the C++ model so that exceptions were the only way to report errors, the extra enforcement of checked exceptions may have become less necessary. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0531" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the past, I have been a strong believer that both checked exceptions and strong static type checking were essential to robust program development. However, both anecdotal and direct experience<sup><a name="fnB48" href="#fn48">[48]</a></sup> with languages that are more dynamic than static have lead me to think that the great benefits actually come from:<br></p>
<ol>
<li>A unified error-reporting model via exceptions, regardless of whether the
programmer is forced by the compiler to handle them.</li>
<li>Type checking, regardless of <i>when</i> it takes place. That is, as long as
proper use of a type is enforced, it doesn&#146;t matter if it happens at
compile time or run time. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0532" title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>On top of this, there are very significant productivity benefits to reducing the compile-time constraints upon the programmer. Indeed, <a name="Index867"></a><i>reflection</i> (and eventually, <i>generics</i>) is required to compensate for the over-constraining nature of strong static typing, as you shall see in the next chapter and in a number of examples throughout the book. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0533" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>I&#146;ve already been told by some that what I say here constitutes blasphemy, and by uttering these words my reputation will be destroyed, civilizations will fall, and a higher percentage of programming projects will fail. The belief that the compiler can save your project by pointing out errors at compile time runs strong, but it&#146;s even more important to realize the limitation of what the compiler is able to do; in Chapter 15, I emphasize the value of an automated build process and unit testing, which give you far more leverage than you get by trying to turn everything into a syntax error. It&#146;s worth keeping in mind that:<br></p>
<p><i>A good programming language is one that helps programmers write good programs. No programming language will prevent its users from writing bad programs.<sup><a name="fnB49" href="#fn49">[49]</a></sup></i> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0534" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In any event, the likelihood of checked exceptions ever being removed from Java seems dim. It would be too radical of a language change, and proponents within Sun appear to be quite strong. Sun has a history and policy of absolute backwards compatibility&#151;to give you a sense of this, virtually all Sun software runs on all Sun hardware, no matter how old. However, if you find that some checked exceptions are getting in your way, or especially if you find yourself being forced to catch exceptions, but you don&#146;t know what to do with them, there are some alternatives. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0535" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775719"></a><a name="Heading9332"></a>Passing exceptions to the
console<br></h3>
<p><a name="Index868"></a><a name="Index869"></a>In simple programs, like many of those in this book, the easiest way to preserve the exceptions without writing a lot of code is to pass them out of <b>main(&#160;)</b> to the console. For example, if you want to open a file for reading (something you&#146;ll learn about in detail in Chapter 12), you must open and close a <b>FileInputStream</b>, which throws exceptions. For a simple program, you can do this (you&#146;ll see this approach used in numerous places throughout this book): <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0536" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:MainException.java</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MainException {
  <font color=#009900>// Pass all exceptions to the console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    <font color=#009900>// Open the file:</font>
    FileInputStream file =
      <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"MainException.java"</font>);
    <font color=#009900>// Use the file ...</font>
    <font color=#009900>// Close the file:</font>
    file.close();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Note that <b>main(&#160;)</b> is also a method that may have an exception specification, and here the type of exception is <b>Exception</b>,<b> </b>the root class of all checked exceptions. By passing it out to the console, you are relieved from writing try-catch clauses within the body of <b>main(&#160;)</b>. (Unfortunately, file I/O is significantly more complex than it would appear to be from this example, so don&#146;t get too excited until after you&#146;ve read Chapter 12). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0537" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775720"></a><a name="Heading9350"></a>Converting checked to
unchecked exceptions<br></h3>
<p><a name="Index870"></a><a name="Index871"></a><a name="Index872"></a>Throwing an exception from <b>main(&#160;)</b> is convenient when you&#146;re writing a <b>main(&#160;)</b>, but not generally useful. The real problem is when you are writing an ordinary method body, and you call another method and realize &#147;I have no idea what to do with this exception here, but I don&#146;t want to swallow it or print some banal message.&#148; With <a name="Index873"></a><a name="Index874"></a><a name="Index875"></a>JDK 1.4 chained exceptions, a new and simple solution prevents itself. You simply &#147;wrap&#148; a checked exception inside a <a name="Index876"></a><b>RuntimeException</b>, like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0538" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>try</font> {
  <font color=#009900>// ... to do something useful</font>
} <font color=#0000ff>catch</font>(IDontKnowWhatToDoWithThisCheckedException e) {
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This seems to be an ideal solution if you want to &#147;turn off&#148; the checked exception&#151;you don&#146;t swallow it, and you don&#146;t have to put it in your method&#146;s exception specification, but because of exception chaining you don&#146;t lose any information from the original exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0539" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This technique provides the option to ignore the exception and let it bubble up the call stack without being required to write <b>try-catch</b> clauses and/or exception specifications. However, you may still catch and handle the specific exception by using <b>getCause(&#160;)</b>, as seen here: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0540" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:TurnOffChecking.java</font>
<font color=#009900>// "Turning off" Checked exceptions.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> WrapCheckedException {
  <font color=#0000ff>void</font> throwRuntimeException(<font color=#0000ff>int</font> type) {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>switch</font>(type) {
        <font color=#0000ff>case</font> 0: <font color=#0000ff>throw</font> <font color=#0000ff>new</font> FileNotFoundException();
        <font color=#0000ff>case</font> 1: <font color=#0000ff>throw</font> <font color=#0000ff>new</font> IOException();
        <font color=#0000ff>case</font> 2: <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(<font color=#004488>"Where am I?"</font>);
        <font color=#0000ff>default</font>: <font color=#0000ff>return</font>;
      }
    } <font color=#0000ff>catch</font>(Exception e) { <font color=#009900>// Adapt to unchecked:</font>
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
    }
  }
}

<font color=#0000ff>class</font> SomeOtherException <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TurnOffChecking {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    WrapCheckedException wce = <font color=#0000ff>new</font> WrapCheckedException();
    <font color=#009900>// You can call f() without a try block, and let</font>
    <font color=#009900>// RuntimeExceptions go out of the method:</font>
    wce.throwRuntimeException(3);
    <font color=#009900>// Or you can choose to catch exceptions:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 4; i++)
      <font color=#0000ff>try</font> {
        <font color=#0000ff>if</font>(i &lt; 3)
          wce.throwRuntimeException(i);
        <font color=#0000ff>else</font>
          <font color=#0000ff>throw</font> <font color=#0000ff>new</font> SomeOtherException();
      } <font color=#0000ff>catch</font>(SomeOtherException e) {
          System.out.println(<font color=#004488>"SomeOtherException: "</font> + e);
      } <font color=#0000ff>catch</font>(RuntimeException re) {
        <font color=#0000ff>try</font> {
          <font color=#0000ff>throw</font> re.getCause();
        } <font color=#0000ff>catch</font>(FileNotFoundException e) {
          System.out.println(
            <font color=#004488>"FileNotFoundException: "</font> + e);
        } <font color=#0000ff>catch</font>(IOException e) {
          System.out.println(<font color=#004488>"IOException: "</font> + e);
        } <font color=#0000ff>catch</font>(Throwable e) {
          System.out.println(<font color=#004488>"Throwable: "</font> + e);
        }
      }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"FileNotFoundException: "</font> +
      <font color=#004488>"java.io.FileNotFoundException"</font>,
      <font color=#004488>"IOException: java.io.IOException"</font>,
      <font color=#004488>"Throwable: java.lang.RuntimeException: Where am I?"</font>,
      <font color=#004488>"SomeOtherException: SomeOtherException"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>WrapCheckedException.throwRuntimeException(&#160;)</b> contains code that generates different types of exceptions. These are caught and wrapped inside <b>RuntimeException</b> objects, so they become the &#147;cause&#148; of those exceptions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0541" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In <b>TurnOffChecking</b>, you can see that it&#146;s possible to call <b>throwRuntimeException(&#160;)</b> with no try block because the method does not throw any checked exceptions. However, when you&#146;re ready to catch exceptions, you still have the ability to catch any exception you want by putting your code inside a <b>try</b> block. You start by catching all the exceptions you explicitly know might emerge from the code in your <b>try</b> block&#151;in this case, <b>SomeOtherException</b> is caught first. Lastly, you catch <b>RuntimeException</b> and <b>throw</b> the result of <b>getCause(&#160;)</b> (the wrapped exception). This extracts the originating exceptions, which can then be handled in their own <b>catch</b> clauses. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0542" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The technique of wrapping a checked exception in a <b>RuntimeException</b> will be used when appropriate throughout the rest of this book. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0543" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775721"></a><a name="Heading9423"></a>Exception
guidelines<br></h2>
<p><a name="Index877"></a>Use exceptions to:<br></p>
<ol>
<li>Handle problems at the appropriate level. (Avoid catching exceptions unless
you know what to do with them).</li>
<li>Fix the problem and call the method that caused the exception again.</li>
<li>Patch things up and continue without retrying the method.</li>
<li>Calculate some alternative result instead of what the method was supposed to
produce.</li>
<li>Do whatever you can in the current context and rethrow the <i>same</i>
exception to a higher context.</li>
<li>Do whatever you can in the current context and throw a <i>different</i>
exception to a higher context.</li>
<li>Terminate the program.</li>
<li>Simplify. (If your exception scheme makes things more complicated, then it
is painful and annoying to use.)</li>
<li>Make your library and program safer. (This is a short-term investment for
debugging, and a long-term investment for application robustness.) <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1598"
title="Send BackTalk Comment">Feedback</a></font></li></ol><h2>
<a name="_Toc375545379"></a><a name="_Toc24775722"></a><a name="Heading9434"></a>Summary</h2>
<p>Improved error recovery is one of the most powerful ways that you can increase the robustness of your code. Error recovery is a fundamental concern for every program you write, but it&#146;s especially important in Java, where one of the primary goals is to create program components for others to use. <a name="Index878"></a><i>To create a robust system, each component must be robust. </i>By providing a consistent error-reporting model with exceptions, Java allows components to reliably communicate problems to client code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1599" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The goals for exception handling in Java are to simplify the creation of large, reliable programs using less code than currently possible, and to do so with more confidence that your application doesn&#146;t have an unhandled error. Exceptions are not terribly difficult to learn, and are one of those features that provide immediate and significant benefits to your project. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1600" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545380"></a><a name="_Toc24775723"></a><a name="Heading9437"></a>Exercises</h2>
<p>Solutions to selected exercises can be found in the electronic document <i>The Thinking in Java Annotated Solution Guide</i>, available for a small fee from <i>www.BruceEckel.com</i>.<br></p>
<ol>
<li>	Create a class with a <b>main(&#160;)</b> that throws an object of class
<b>Exception</b> inside a <b>try</b> block. Give the constructor for
<b>Exception</b> a <b>String</b> argument. Catch the exception inside a
<b>catch</b> clause and print the <b>String</b> argument. Add a <b>finally</b>
clause and print a message to prove you were there. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1602" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create your own exception class using the <b>extends</b> keyword. Write a
constructor for this class that takes a <b>String</b> argument and stores it
inside the object with a <b>String</b> reference. Write a method that prints out
the stored <b>String</b>. Create a <b>try-catch</b> clause to exercise your new
exception. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1603" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Write a class with a method that throws an exception of the type created in
Exercise 2. Try compiling it without an exception specification to see what the
compiler says. Add the appropriate exception specification. Try out your class
and its exception inside a try-catch clause. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1604" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Define an object reference and initialize it to <b>null</b>. Try to call a
method through this reference. Now wrap the code in a <b>try-catch</b> clause to
catch the exception. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1605" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create a class with two methods, <b>f(&#160;)</b> and <b>g(&#160;)</b>. In
<b>g(&#160;)</b>, throw an exception of a new type that you define. In
<b>f(&#160;)</b>, call <b>g(&#160;)</b>, catch its exception and, in the
<b>catch</b> clause, throw a different exception (of a second type that you
define). Test your code in <b>main(&#160;)</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1606" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Repeat the previous exercise, but inside the <b>catch</b> clause, wrap
<b>g(&#160;)</b>&#146;s exception in a <b>RuntimeException</b>.</li>
<li>	Create three new types of exceptions. Write a class with a method that
throws all three. In <b>main(&#160;)</b>, call the method but only use a single
<b>catch</b> clause that will catch all three types of exceptions. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1607"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Write code to generate and catch an <b>ArrayIndexOutOfBoundsException</b>.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1608"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Create your own resumption-like behavior by using a <b>while</b> loop that
repeats until an exception is no longer thrown. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1609" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create a three-level hierarchy of exceptions. Now create a base-class <b>A
</b>with a method that throws an exception at the base of your hierarchy.
Inherit <b>B</b> from <b>A</b> and override the method so it throws an exception
at level two of your hierarchy. Repeat by inheriting class <b>C</b> from
<b>B</b>. In <b>main(&#160;)</b>, create a <b>C</b> and upcast it to <b>A</b>,
then call the method. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1610" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Demonstrate that a derived-class constructor cannot catch exceptions thrown
by its base-class constructor. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1611" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Show that <b>OnOffSwitch.java</b> can fail by throwing a
<b>RuntimeException</b> inside the <b>try</b> block. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1612" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Show that <b>WithFinally.java</b> doesn&#146;t fail by throwing a
<b>RuntimeException</b> inside the <b>try</b> block. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1613" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify Exercise 7 by adding a <b>finally</b> clause. Verify that your
<b>finally</b> clause is executed, even if a <b>NullPointerException</b> is
thrown. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1614" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create an example where you use a flag to control whether cleanup code is
called, as described in the second paragraph after the heading
&#147;Constructors.&#148; <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1615" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>StormyInning.java</b> by adding an <b>UmpireArgument</b>
exception type and methods that throw this exception. Test the modified
hierarchy. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1616" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Remove the first catch clause in <b>Human.java</b> and verify that the code
still compiles and runs properly. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1617" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Add a second level of exception loss to <b>LostMessage.java</b> so that the
<b>HoHumException</b> is itself replaced by a third exception. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1618"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Add an appropriate set of exceptions to <b>c08:GreenhouseControls.java</b>.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap10_1620"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Add an appropriate set of exceptions to <b>c08:Sequence.java</b>.</li>
<li>	Change the file name string in <b>MainException.java</b> to name a file
that doesn&#146;t exist. Run the program and note the
result.</li></ol><hr><p class="footnote text"><sup><a name="fn40" href="#fnB40">[40]</a></sup> The C programmer can look up the return value of <b>printf(&#160;)</b> for an example of this.<br></p>
<p class="footnote text"><sup><a name="fn41" href="#fnB41">[41]</a></sup> C++ exception handling does not have the <b>finally</b> clause because it relies on destructors to accomplish this sort of cleanup.<br></p>
<p class="footnote text"><sup><a name="fn42" href="#fnB42">[42]</a></sup> A destructor is a function that&#146;s always called when an object becomes unused. You always know exactly where and when the destructor gets called. C++ has automatic destructor calls, and C# (which is much more like Java) has a way that automatic destruction can occur.<br></p>
<p class="footnote text"><sup><a name="fn43" href="#fnB43">[43]</a></sup> ISO C++ added similar constraints that require derived-method exceptions to be the same as, or derived from, the exceptions thrown by the base-class method. This is one case in which C++ is actually able to check exception specifications at compile time.<br></p>
<p class="footnote text"><sup><a name="fn44" href="#fnB44">[44]</a></sup> Barbara Liskov and Alan Snyder: <i>Exception Handling in CLU</i>, IEEE Transactions on Software Engineering, Vol. SE-5, No. 6, November 1979. This paper is not available on the Internet, only in print form so you&#146;ll have to contact a library to get a copy.<br></p>
<p class="footnote text"><sup><a name="fn45" href="#fnB45">[45]</a></sup> http://discuss.develop.com/archives/wa.exe?A2=ind0011A&amp;L=DOTNET&amp;P=R32820<br></p>
<p class="footnote text"><sup><a name="fn46" href="#fnB46">[46]</a></sup> ibid<br></p>
<p class="footnote text"><sup><a name="fn47" href="#fnB47">[47]</a></sup> Bjarne Stroustrup, <i>The C++ Programming Language, 3<sup>rd</sup> edition, Addison-Wesley 1997, </i>pp 376.<br></p>
<p class="footnote text"><sup><a name="fn48" href="#fnB48">[48]</a></sup> Indirectly with Smalltalk via conversations with many experienced programmers in that language; directly with Python (<i>www.Python.org</i>). <br></p>
<p class="footnote text"><sup><a name="fn49" href="#fnB49">[49]</a></sup> <i>(Kees Koster, designer of the CDL language, as quoted by Bertrand Meyer, designer of the Eiffel Language). </i>http://www.elj.com/elj/v1/n1/bm/right/.<br></p>

<!-- <hr><b>Placeholder</b> -->

<hr>

<div align="CENTER"><a href="TIJ310.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ312.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>

</font></body>

</html>

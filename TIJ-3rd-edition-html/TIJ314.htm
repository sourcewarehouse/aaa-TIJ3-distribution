<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en">
<!--
This document was converted from RTF source: 
By r2net 5.8 r2netcmd Windows 
See http://www.logictran.com
-->
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Thinking in Java, 3rd ed. Revision 4.0: 12: The Java  I/O System</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css"></head>

<body >
   <CENTER>     <a href="http://www.MindView.net">     <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>     <Font FACE="Verdana, Tahoma, Arial, Helvetica, Sans">     <h2>Thinking in Java, 3<sup>rd</sup> ed. Revision 4.0</h2>     <FONT size = "-1"><br>     [ <a href="README.txt">Viewing Hints</a> ]     [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]     [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>     [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]     [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]     [ <a href="http://www.mindview.net/Services">Consulting</a> ] <br><br>     </FONT></FONT>   </CENTER> 
<font face="Georgia"><div align="CENTER"><a href="TIJ313.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ315.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>
<hr>

<h1>
<a name="_Toc375545381"></a><a name="_Toc24272651"></a><a name="_Toc24775783"></a><a name="Heading13843"></a>12:
The Java <br>I/O System</h1>
<p class="Intro">Creating a good input/output (I/O) system is one of the more difficult tasks for the language designer.<br></p>
<p>This is evidenced by the number of different approaches. The challenge seems to be in covering all eventualities. Not only are there different sources and sinks of I/O that you want to communicate with (files, the console, network connections, etc.), but you need to talk to them in a wide variety of ways (sequential, random-access, buffered, binary, character, by lines, by words, etc.). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1621" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The Java library designers attacked this problem by creating lots of classes. In fact, there are so many classes for Java&#146;s I/O system that it can be intimidating at first (ironically, the Java I/O design actually prevents an explosion of classes). There was also a significant change in the I/O library after Java 1.0, when the original <a name="Index1162"></a><b>byte</b>-oriented library was supplemented with <b>char</b>-oriented, Unicode-based I/O classes. In JDK 1.4, the <b>nio</b> classes (for &#147;new I/O,&#148; a name we&#146;ll still be using years from now) were added for improved performance and functionality. As a result, there are a fair number of classes to learn before you understand enough of Java&#146;s I/O picture that you can use it properly. In addition, it&#146;s rather important to understand the evolution history of the I/O library, even if your first reaction is &#147;don&#146;t bother me with history, just show me how to use it!&#148; The problem is that without the historical perspective, you will rapidly become confused with some of the classes and when you should and shouldn&#146;t use them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1622" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This chapter will give you an introduction to the variety of I/O classes in the standard Java library and how to use them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1623" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545382"></a><a name="_Toc375545390"></a><a name="_Toc24775784"></a><a name="Heading13848"></a>The
<b>File</b> class<br></h2>
<p><a name="Index1163"></a><a name="Index1164"></a><a name="Index1165"></a><a name="Index1166"></a><a name="Index1167"></a><a name="Index1168"></a>Before getting into the classes that actually read and write data to streams, we&#146;ll look at a utility provided with the library to assist you in handling file directory issues. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1624" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>File </b>class has a deceiving name; you might think it refers to a file, but it doesn&#146;t. It can represent either the <i>name</i> of a particular file or the <i>names</i> of a set of files in a directory. If it&#146;s a set of files, you can ask for that set using the <b>list(&#160;)</b> method, which returns an array of <b>String</b>. It makes sense to return an array rather than one of the flexible container classes, because the number of elements is fixed, and if you want a different directory listing, you just create a different <b>File</b> object. In fact, &#147;FilePath&#148; would have been a better name for the class. This section shows an example of the use of this class, including the associated <b>FilenameFilter</b> <b>interface</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1625" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545391"></a><a name="_Toc24775785"></a><a name="Heading13851"></a>A
directory lister<br></h3>
<p><a name="Index1169"></a><a name="Index1170"></a>Suppose you&#146;d like to see a directory listing. The <b>File</b> object can be listed in two ways. If you call <b>list(&#160;)</b> with no arguments, you&#146;ll get the full list that the <b>File</b> object contains. However, if you want a restricted list&#151;for example, if you want all of the files with an extension of <b>.java</b>&#151;then you use a &#147;directory filter,&#148; which is a class that tells how to select the <b>File</b> objects for display. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1626" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s the code for the example. Note that the result has been effortlessly sorted (alphabetically) using the <b>java.utils.Arrays.sort(&#160;)</b> method and the <b>AlphabeticComparator</b> defined in Chapter 11:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:DirList.java</font>
<font color=#009900>// Displays directory listing using regular expressions.</font>
<font color=#009900>// {Args: "D.*\.java"}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font>
      list = path.list(<font color=#0000ff>new</font> DirFilter(args[0]));
    Arrays.sort(list, <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
}

<font color=#0000ff>class</font> DirFilter <font color=#0000ff>implements</font> FilenameFilter {
  <font color=#0000ff>private</font> Pattern pattern;
  <font color=#0000ff>public</font> DirFilter(String regex) {
    pattern = Pattern.compile(regex);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
    <font color=#009900>// Strip path information, search for regex:</font>
    <font color=#0000ff>return</font> pattern.matcher(
      <font color=#0000ff>new</font> File(name).getName()).matches();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>DirFilter</b> class &#147;implements&#148; the <b>interface</b> <b>FilenameFilter</b>. It&#146;s useful to see how simple the <b>FilenameFilter</b> <b>interface</b> is: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1627" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>interface</font> FilenameFilter {
  <font color=#0000ff>boolean</font> accept(File dir, String name);
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>It says all that this type of object does is provide a method called <b>accept(&#160;)</b>. The whole reason behind the creation of this class is to provide the <b>accept(&#160;)</b> method to the <b>list(&#160;)</b> method so that <b>list(&#160;)</b> can &#147;call back&#148; <b>accept(&#160;)</b> to determine which file names should be included in the list. Thus, this structure is often referred to as a <a name="Index1171"></a><i>callback</i>. More specifically, this is an example of the <i>Strategy Pattern</i>, because <b>list(&#160;)</b> implements basic functionality, and you provide the <i>Strategy</i> in the form of a <b>FilenameFilter</b> in order to complete the algorithm necessary for <b>list(&#160;)</b> to provide its service. Because <b>list(&#160;)</b> takes a <b>FilenameFilter</b> object as its argument, it means that you can pass an object of any class that implements <b>FilenameFilter</b> to choose (even at run time) how the <b>list(&#160;)</b> method will behave. The purpose of a callback is to provide flexibility in the behavior of code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1628" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>DirFilter</b> shows that just because an <b>interface</b> contains only a set of methods, you&#146;re not restricted to writing only those methods. (You must at least provide definitions for all the methods in an interface, however.) In this case, the <b>DirFilter</b> constructor is also created. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1629" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>accept(&#160;)</b> method must accept a <b>File</b> object representing the directory that a particular file is found in, and a <b>String</b> containing the name of that file. You might choose to use or ignore either of these arguments, but you will probably at least use the file name. Remember that the <b>list(&#160;)</b> method is calling <b>accept(&#160;)</b> for each of the file names in the directory object to see which one should be included; this is indicated by the <b>boolean</b> result returned by <b>accept(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1630" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To make sure the element you&#146;re working with is only the file name and contains no path information, all you have to do is take the <b>String</b> object and create a <b>File</b> object out of it, then call <b>getName(&#160;)</b>, which strips away all the path information (in a platform-independent way). Then <b>accept(&#160;)</b> uses a regular expression <b>matcher</b> object to see if the regular expression <b>regex</b> matches the name of the file. Using <b>accept(&#160;)</b>, the <b>list(&#160;)</b> method returns an array. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1631" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading13897"></a>Anonymous inner classes</h4>
<p>This example is ideal for rewriting using an anonymous inner class (described in Chapter 8). As a first cut, a method <a name="Index1172"></a><a name="Index1173"></a><a name="Index1174"></a><b>filter(&#160;) </b>is created that returns a reference to a <b>FilenameFilter</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:DirList2.java</font>
<font color=#009900>// Uses anonymous inner classes.</font>
<font color=#009900>// {Args: "D.*\.java"}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> FilenameFilter filter(<font color=#0000ff>final</font> String regex) {
    <font color=#009900>// Creation of anonymous inner class:</font>
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> FilenameFilter() {
      <font color=#0000ff>private</font> Pattern pattern = Pattern.compile(regex);
      <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
        <font color=#0000ff>return</font> pattern.matcher(
          <font color=#0000ff>new</font> File(name).getName()).matches();
      }
    }; <font color=#009900>// End of anonymous inner class</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font>
      list = path.list(filter(args[0]));
    Arrays.sort(list, <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Note that the argument to <b>filter(&#160;)</b> must be <a name="Index1175"></a><a name="Index1176"></a><b>final</b>. This is required by the anonymous inner class so that it can use an object from outside its scope. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1633" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This design is an improvement because the <b>FilenameFilter</b> class is now tightly bound to <b>DirList2</b>. However, you can take this approach one step further and define the anonymous inner class as an argument to <b>list(&#160;)</b>, in which case it&#146;s even smaller:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:DirList3.java</font>
<font color=#009900>// Building the anonymous inner class "in-place."</font>
<font color=#009900>// {Args: "D.*\.java"}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList3 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(<font color=#0000ff>final</font> String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font>
      list = path.list(<font color=#0000ff>new</font> FilenameFilter() {
        <font color=#0000ff>private</font> Pattern pattern = Pattern.compile(args[0]);
        <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
          <font color=#0000ff>return</font> pattern.matcher(
            <font color=#0000ff>new</font> File(name).getName()).matches();
        }
      });
    Arrays.sort(list, <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The argument to <b>main(&#160;)</b> is now <b>final</b>, since the anonymous inner class uses <b>args[0]</b> directly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1634" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This shows you how anonymous inner classes allow the creation of specific, one-off classes to solve problems. One benefit of this approach is that it keeps the code that solves a particular problem isolated together in one spot. On the other hand, it is not always as easy to read, so you must use it judiciously. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1635" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545392"></a><a name="_Toc24775786"></a><a name="Heading13963"></a>Checking
for and creating directories</h3>
<p>The <b>File</b> class is more than just a representation for an existing file or directory. You can also use a <b>File</b> object to create a new directory or an entire directory path if it doesn&#146;t exist. You can also look at the characteristics of files (size, last modification date, read/write), see whether a <a name="Index1177"></a><a name="Index1178"></a><a name="Index1179"></a><a name="Index1180"></a><b>File</b> object represents a file or a directory, and delete a file. This program shows some of the other methods available with the <b>File</b> class (see the HTML documentation from <i>java.sun.com </i>for the full set):<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:MakeDirectories.java</font>
<font color=#009900>// Demonstrates the use of the File class to</font>
<font color=#009900>// create directories and manipulate files.</font>
<font color=#009900>// {Args: MakeDirectoriesTest}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MakeDirectories {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> usage() {
    System.err.println(
      <font color=#004488>"Usage:MakeDirectories path1 ...\n"</font> +
      <font color=#004488>"Creates each path\n"</font> +
      <font color=#004488>"Usage:MakeDirectories -d path1 ...\n"</font> +
      <font color=#004488>"Deletes each path\n"</font> +
      <font color=#004488>"Usage:MakeDirectories -r path1 path2\n"</font> +
      <font color=#004488>"Renames from path1 to path2"</font>);
    System.exit(1);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fileData(File f) {
    System.out.println(
      <font color=#004488>"Absolute path: "</font> + f.getAbsolutePath() +
      <font color=#004488>"\n Can read: "</font> + f.canRead() +
      <font color=#004488>"\n Can write: "</font> + f.canWrite() +
      <font color=#004488>"\n getName: "</font> + f.getName() +
      <font color=#004488>"\n getParent: "</font> + f.getParent() +
      <font color=#004488>"\n getPath: "</font> + f.getPath() +
      <font color=#004488>"\n length: "</font> + f.length() +
      <font color=#004488>"\n lastModified: "</font> + f.lastModified());
    <font color=#0000ff>if</font>(f.isFile())
      System.out.println(<font color=#004488>"It's a file"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(f.isDirectory())
      System.out.println(<font color=#004488>"It's a directory"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 1) usage();
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-r"</font>)) {
      <font color=#0000ff>if</font>(args.length != 3) usage();
      File
        old = <font color=#0000ff>new</font> File(args[1]),
        rname = <font color=#0000ff>new</font> File(args[2]);
      old.renameTo(rname);
      fileData(old);
      fileData(rname);
      <font color=#0000ff>return</font>; <font color=#009900>// Exit main</font>
    }
    <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>boolean</font> del = <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-d"</font>)) {
      count++;
      del = <font color=#0000ff>true</font>;
    }
    count--;
    <font color=#0000ff>while</font>(++count &lt; args.length) {
      File f = <font color=#0000ff>new</font> File(args[count]);
      <font color=#0000ff>if</font>(f.exists()) {
        System.out.println(f + <font color=#004488>" exists"</font>);
        <font color=#0000ff>if</font>(del) {
          System.out.println(<font color=#004488>"deleting..."</font> + f);
          f.delete();
        }
      }
      <font color=#0000ff>else</font> { <font color=#009900>// Doesn't exist</font>
        <font color=#0000ff>if</font>(!del) {
          f.mkdirs();
          System.out.println(<font color=#004488>"created "</font> + f);
        }
      }
      fileData(f);
    }
    <font color=#0000ff>if</font>(args.length == 1 &amp;&amp;
        args[0].equals(<font color=#004488>"MakeDirectoriesTest"</font>))
      monitor.expect(<font color=#0000ff>new</font> String[] {
        <font color=#004488>"%% (MakeDirectoriesTest exists"</font>+
          <font color=#004488>"|created MakeDirectoriesTest)"</font>,
        <font color=#004488>"%% Absolute path: "</font>
          + <font color=#004488>"\\S+MakeDirectoriesTest"</font>,
        <font color=#004488>"%%  Can read: (true|false)"</font>,
        <font color=#004488>"%%  Can write: (true|false)"</font>,
        <font color=#004488>" getName: MakeDirectoriesTest"</font>,
        <font color=#004488>" getParent: null"</font>,
        <font color=#004488>" getPath: MakeDirectoriesTest"</font>,
        <font color=#004488>"%%  length: \\d+"</font>,
        <font color=#004488>"%%  lastModified: \\d+"</font>,
        <font color=#004488>"It's a directory"</font>
      });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In <b>fileData(&#160;)</b> you can see various file investigation methods used to display information about the file or directory path. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1636" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The first method that&#146;s exercised by <b>main(&#160;)</b> is <a name="Index1181"></a><a name="Index1182"></a><b>renameTo(&#160;)</b>, which allows you to rename (or move) a file to an entirely new path represented by the argument, which is another <b>File</b> object. This also works with directories of any length. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1637" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you experiment with the preceding program, you&#146;ll find that you can make a directory path of any complexity, because <a name="Index1183"></a><a name="Index1184"></a><b>mkdirs(&#160;)</b> will do all the work for you. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1638" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775787"></a><a name="Heading14057"></a>Input and output<br></h2>
<p><a name="Index1185"></a><a name="Index1186"></a><a name="Index1187"></a><a name="Index1188"></a><a name="Index1189"></a><a name="Index1190"></a><a name="Index1191"></a><a name="Index1192"></a><a name="Index1193"></a><a name="Index1194"></a><a name="Index1195"></a><a name="Index1196"></a><a name="Index1197"></a><a name="Index1198"></a><a name="Index1199"></a>I/O libraries often use the abstraction of a <i>stream</i>, which represents any data source or sink as an object capable of producing or receiving pieces of data. The stream hides the details of what happens to the data inside the actual I/O device. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1639" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The Java library classes for I/O are divided by input and output, as you can see by looking at the class hierarchy in the JDK documentation. By inheritance, everything derived from the <b>InputStream</b> or <b>Reader </b>classes have basic methods called <b>read(&#160;) </b>for reading a single byte or array of bytes. Likewise, everything derived from <b>OutputStream </b>or <b>Writer </b>classes have basic methods called <b>write(&#160;) </b>for writing a single byte or array of bytes. However, you won&#146;t generally use these methods; they exist so that other classes can use them&#151;these other classes provide a more useful interface. Thus, you&#146;ll rarely create your stream object by using a single class, but instead will layer multiple objects together to provide your desired functionality. The fact that you create more than one object to create a single resulting stream is the primary reason that Java&#146;s stream library is confusing. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1640" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s helpful to categorize the classes by their functionality. In Java 1.0, the library designers started by deciding that all classes that had anything to do with input would be inherited from <b>InputStream</b>, and all classes that were associated with output would be inherited from <b>OutputStream</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1641" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545383"></a><a name="_Toc24775788"></a><a name="Heading14061"></a>Types
of <b>InputStream</b></h3>
<p><b>InputStream</b>&#146;s job is to represent classes that produce input from different sources. These sources can be: <br></p>
<ol>
<li>An array of bytes.</li>
<li>A <b>String</b> object.</li>
<li>A file.</li>
<li>A &#147;pipe,&#148; which works like a physical
<a name="Index1200"></a><a name="Index1201"></a>pipe: You put things in at one
end and they come out the other.</li>
<li>A sequence of other streams, so you can collect them together into a single
stream.</li>
<li>Other sources, such as an Internet connection. (This is covered in
<i>Thinking in Enterprise Java</i>.) <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1642" title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>Each of these has an associated subclass of <b>InputStream</b>. In addition, the <b>FilterInputStream</b> is also a type of <b>InputStream</b>, to provide a base class for "decorator" classes that attach attributes or useful interfaces to input streams. This is discussed later. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1643" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Table 12-1. Types of InputStream</b><br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<th width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><a name="Index1202"></a><a name="Index1203"></a><a name="Index1204"></a><a name="Index1205"></a><a name="Index1206"></a><a name="Index1207"></a><a name="Index1208"></a><a name="Index1209"></a><a name="Index1210"></a><a name="Index1211"></a><a name="Index1212"></a><a name="Index1213"></a><a name="Index1214"></a><a name="Index1215"></a><a name="Index1216"></a><a name="Index1217"></a><a name="Index1218"></a><a name="Index1219"></a><a name="Index1220"></a><a name="Index1221"></a><b>Class</b><br></p>
</th>
<th width="143.999964" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Function</b><br></p>
</th>
<th width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Constructor Arguments</b><br></p>
</th>
</tr>
<tr valign="top">
<th width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>How to use it</b><br></p>
</th>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>ByteArray-InputStream</b><br></p>
</td>
<td width="143.999964" colspan="1" rowspan="2" valign="top">
<p class="Table">Allows a buffer in memory to be used as an <b>InputStream</b>.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">The buffer from which to extract the bytes.<br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">As a source of data: Connect it to a <b>FilterInputStream</b> object to provide a useful interface.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>StringBuffer-InputStream</b><br></p>
</td>
<td width="143.999964" colspan="1" rowspan="2" valign="top">
<p class="Table">Converts a <b>String</b> into an <b>InputStream</b>.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">A <b>String</b>. The underlying implementation actually uses a <b>StringBuffer</b>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">As a source of data: Connect it to a <b>FilterInputStream</b> object to provide a useful interface.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>File-InputStream</b><br></p>
</td>
<td width="143.999964" colspan="1" rowspan="2" valign="top">
<p class="Table">For reading information from a file.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">A <b>String</b> representing the file name, or a <b>File</b> or <b>FileDescriptor</b> object.<br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">As a source of data: Connect it to a <b>FilterInputStream</b> object to provide a useful interface.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Piped-InputStream</b><br></p>
</td>
<td width="143.999964" colspan="1" rowspan="2" valign="top">
<p class="Table">Produces the data that&#146;s being written to the associated <b>PipedOutput</b>-<b>Stream</b>. Implements the &#147;piping&#148; concept.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PipedOutputStream</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">As a source of data in multithreading: Connect it to a <b>FilterInputStream</b> object to provide a useful interface.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Sequence-InputStream</b><br></p>
</td>
<td width="143.999964" colspan="1" rowspan="2" valign="top">
<p class="Table">Converts two or more <b>InputStream</b> objects into a single <b>InputStream</b>.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">Two <b>InputStream</b> objects or an <b>Enumeration</b> for a container of <b>InputStream</b> objects.<br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">As a source of data: Connect it to a <b>FilterInputStream</b> object to provide a useful interface.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Filter-InputStream</b><br></p>
</td>
<td width="143.999964" colspan="1" rowspan="2" valign="top">
<p class="Table">Abstract class that is an interface for decorators that provide useful functionality to the other <b>InputStream</b> classes. See Table 12-3.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">See Table 12-3.<br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">See Table 12-3.<br></p>
</td>
</tr>
</table></div>
<h3>
<a name="_Toc375545385"></a><a name="_Toc24775789"></a><a name="Heading14113"></a>Types
of <b>OutputStream</b><br></h3>
<p><a name="Index1222"></a><a name="Index1223"></a>This category includes the classes that decide where your output will go: an array of bytes (no <b>String</b>, however; presumably, you can create one using the array of bytes), a file, or a &#147;pipe.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1644" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In addition, the <b>FilterOutputStream</b> provides a base class for "decorator" classes that attach attributes or useful interfaces to output streams. This is discussed later. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1645" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Table 12-2. Types of OutputStream</b><br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<th width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><a name="Index1224"></a><a name="Index1225"></a><a name="Index1226"></a><a name="Index1227"></a><a name="Index1228"></a><a name="Index1229"></a><a name="Index1230"></a><a name="Index1231"></a><b>Class</b><br></p>
</th>
<th width="155.999961" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Function</b><br></p>
</th>
<th width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Constructor Arguments</b><br></p>
</th>
</tr>
<tr valign="top">
<th width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>How to use it</b><br></p>
</th>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>ByteArray-OutputStream</b><br></p>
</td>
<td width="155.999961" colspan="1" rowspan="2" valign="top">
<p class="Table">Creates a buffer in memory. All the data that you send to the stream is placed in this buffer.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">Optional initial size of the buffer.<br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">To designate the destination of your data: Connect it to a <b>FilterOutputStream</b> object to provide a useful interface.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>File-OutputStream</b><br></p>
</td>
<td width="155.999961" colspan="1" rowspan="2" valign="top">
<p class="Table">For sending information to a file.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">A String representing the file name, or a <b>File</b> or <b>FileDescriptor</b> object.<br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">To designate the destination of your data: Connect it to a <b>FilterOutputStream</b> object to provide a useful interface.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Piped-OutputStream</b><br></p>
</td>
<td width="155.999961" colspan="1" rowspan="2" valign="top">
<p class="Table">Any information you write to this automatically ends up as input for the associated <b>PipedInput-Stream</b>. Implements the &#147;piping&#148; concept.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PipedInputStream</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">To designate the destination of your data for multithreading: Connect it to a <b>FilterOutputStream</b> object to provide a useful interface.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Filter-OutputStream</b><br></p>
</td>
<td width="155.999961" colspan="1" rowspan="2" valign="top">
<p class="Table">Abstract class that is an interface for decorators that provide useful functionality to the other <b>OutputStream</b> classes. See Table 12-4.<br></p>
</td>
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">See Table 12-4.<br></p>
</td>
</tr>
<tr valign="top">
<td width="203.999949" colspan="1" rowspan="1" valign="top">
<p class="Table">See Table 12-4.<br></p>
</td>
</tr>
</table></div>
<h2>
<a name="_Toc375545386"></a><a name="_Toc24775790"></a><a name="Heading14147"></a>Adding
attributes <br>and useful interfaces</h2>
<p>The use of layered objects to dynamically and transparently add responsibilities to individual objects is referred to as the <a name="Index1232"></a><a name="Index1233"></a><i>Decorator</i> pattern. (Patterns<sup><a name="fnB61" href="#fn61">[61]</a></sup> are the subject of <i>Thinking in Patterns (with Java)</i> at <i>www.BruceEckel.com</i>.) The decorator pattern specifies that all objects that wrap around your initial object have the same interface. This makes the basic use of the decorators transparent&#151;you send the same message to an object whether it has been decorated or not. This is the reason for the existence of the &#147;filter&#148; classes in the Java I/O library: The abstract &#147;filter&#148; class is the base class for all the decorators. (A decorator must have the same interface as the object it decorates, but the decorator can also extend the interface, which occurs in several of the &#147;filter&#148; classes). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1646" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Decorators are often used when simple subclassing results in a large number of classes in order to satisfy every possible combination that is needed&#151;so many classes that it becomes impractical. The Java I/O library requires many different combinations of features, and this is the justification for using the decorator pattern.<sup><a name="fnB62" href="#fn62">[62]</a></sup> There is a drawback to the decorator pattern, however. Decorators give you much more flexibility while you&#146;re writing a program (since you can easily mix and match attributes), but they add complexity to your code. The reason that the Java I/O library is awkward to use is that you must create many classes&#151;the &#147;core&#148; I/O type plus all the decorators&#151;in order to get the single I/O object that you want. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1647" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The classes that provide the decorator interface to control a particular <b>InputStream</b> or <b>OutputStream</b> are the <b>FilterInputStream</b> and <b>FilterOutputStream</b>, which don&#146;t have very intuitive names. <b>FilterInputStream</b> and <b>FilterOutputStream</b> are derived from the base classes of the I/O library, <b>InputStream</b> and <b>OutputStream</b>, which is the key requirement of the decorator (so that it provides the common interface to all the objects that are being decorated). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1648" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545387"></a><a name="_Toc24775791"></a><a name="Heading14153"></a>Reading
from an <b>InputStream </b><br>with<b> FilterInputStream</b></h3>
<p>The <b>FilterInputStream</b> classes accomplish two significantly different things. <b>DataInputStream</b> allows you to read different types of primitive data as well as <b>String</b> objects. (All the methods start with &#147;read,&#148; such as <b>readByte(&#160;)</b>, <b>readFloat(&#160;)</b>, etc.) This, along with its companion <b>DataOutputStream</b>, allows you to move primitive data from one place to another via a stream. These &#147;places&#148; are determined by the classes in Table 12-1. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1649" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The remaining classes modify the way an <b>InputStream</b> behaves internally: whether it&#146;s buffered or unbuffered, if it keeps track of the lines it&#146;s reading (allowing you to ask for line numbers or set the line number), and whether you can push back a single character. The last two classes look a lot like support for building a compiler (that is, they were probably added to support the construction of the Java compiler), so you probably won&#146;t use them in general programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1650" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You&#146;ll need to buffer your input almost every time, regardless of the I/O device you&#146;re connecting to, so it would have made more sense for the I/O library to make a special case (or simply a method call) for unbuffered input rather than buffered input. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1651" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Table 12-3. Types of FilterInputStream</b><br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><a name="Index1234"></a><a name="Index1235"></a><a name="Index1236"></a><a name="Index1237"></a><a name="Index1238"></a><a name="Index1239"></a><a name="Index1240"></a><a name="Index1241"></a><b>Class</b><br></p>
</td>
<td width="178.666622" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Function</b><br></p>
</td>
<td width="173.333290" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Constructor Arguments</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="173.333290" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>How to use it</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Data-InputStream</b><br></p>
</td>
<td width="178.666622" colspan="1" rowspan="2" valign="top">
<p class="Table">Used in concert with <b>DataOutputStream</b>, so you can read primitives (<b>int</b>, <b>char</b>, <b>long</b>, etc.) from a stream in a portable fashion.<br></p>
</td>
<td width="173.333290" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>InputStream</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="173.333290" colspan="1" rowspan="1" valign="top">
<p class="Table">Contains a full interface to allow you to read primitive types.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Buffered-InputStream</b><br></p>
</td>
<td width="178.666622" colspan="1" rowspan="2" valign="top">
<p class="Table">Use this to prevent a physical read every time you want more data. You&#146;re saying &#147;Use a buffer.&#148;<br></p>
</td>
<td width="174.666623" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>InputStream</b>, with optional buffer size.<br></p>
</td>
</tr>
<tr valign="top">
<td width="174.666623" colspan="1" rowspan="1" valign="top">
<p class="Table">This doesn&#146;t provide an interface <i>per se</i>, just a requirement that a buffer be used. Attach an interface object.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>LineNumber-InputStream</b><br></p>
</td>
<td width="178.666622" colspan="1" rowspan="2" valign="top">
<p class="Table">Keeps track of line numbers in the input stream; you can call <b>getLineNumber(&#160;)</b> and <b>setLineNumber(</b><br><b>int)</b>.<br></p>
</td>
<td width="174.666623" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>InputStream</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="174.666623" colspan="1" rowspan="1" valign="top">
<p class="Table">This just adds line numbering, so you&#146;ll probably attach an interface object.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Pushback-InputStream</b><br></p>
</td>
<td width="178.666622" colspan="1" rowspan="2" valign="top">
<p class="Table">Has a one byte push-back buffer so that you can push back the last character read.<br></p>
</td>
<td width="174.666623" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>InputStream</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="174.666623" colspan="1" rowspan="1" valign="top">
<p class="Table">Generally used in the scanner for a compiler and probably included because the Java compiler needed it. You probably won&#146;t use this.<br></p>
</td>
</tr>
</table></div>
<h3>
<a name="_Toc375545388"></a><a name="_Toc24775792"></a><a name="Heading14188"></a>Writing
to an <b>OutputStream<i> </i></b><br>with<b> FilterOutputStream</b></h3>
<p>The complement to <b>DataInputStream</b> is <b>DataOutputStream</b>, which formats each of the primitive types and <b>String</b> objects onto a stream in such a way that any <b>DataInputStream</b>, on any machine, can read them. All the methods start with &#147;write,&#148; such as <b>writeByte(&#160;)</b>, <b>writeFloat(&#160;)</b>, etc. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1652" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The original intent of <b>PrintStream</b> was to print all of the primitive data types and <b>String</b> objects in a viewable format. This is different from <b>DataOutputStream</b>, whose goal is to put data elements on a stream in a way that <b>DataInputStream</b> can portably reconstruct them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1653" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The two important methods in <b>PrintStream</b> are <b>print(&#160;)</b> and <b>println(&#160;)</b>, which are overloaded to print all the various types. The difference between <b>print(&#160;)</b> and <b>println(&#160;)</b> is that the latter adds a newline when it&#146;s done. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1654" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>PrintStream</b> can be problematic because it traps all <b>IOException</b>s (You must explicitly test the error status with <b>checkError(&#160;)</b>, which returns <b>true</b> if an error has occurred). Also, <b>PrintStream</b> doesn&#146;t internationalize properly and doesn&#146;t handle line breaks in a platform-independent way (these problems are solved with <b>PrintWriter</b>, described later). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1655" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>BufferedOutputStream</b> is a modifier and tells the stream to use buffering so you don&#146;t get a physical write every time you write to the stream. You&#146;ll probably always want to use this when doing output. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1656" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Table 12-4. Types of FilterOutputStream</b><br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<th width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><a name="Index1242"></a><a name="Index1243"></a><a name="Index1244"></a><a name="Index1245"></a><a name="Index1246"></a><a name="Index1247"></a><b>Class</b><br></p>
</th>
<th width="173.333290" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Function</b><br></p>
</th>
<th width="161.333293" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Constructor Arguments </b><br></p>
</th>
</tr>
<tr valign="top">
<th width="161.333293" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>How to use it</b><br></p>
</th>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Data-OutputStream</b><br></p>
</td>
<td width="173.333290" colspan="1" rowspan="2" valign="top">
<p class="Table">Used in concert with <b>DataInputStream</b> so you can write primitives (int, char, long, etc.) to a stream in a portable fashion.<br></p>
</td>
<td width="161.333293" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>OutputStream</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="161.333293" colspan="1" rowspan="1" valign="top">
<p class="Table">Contains full interface to allow you to write primitive types.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>PrintStream</b><br></p>
</td>
<td width="173.333290" colspan="1" rowspan="2" valign="top">
<p class="Table">For producing formatted output. While <b>DataOutputStream</b> handles the <i>storage</i> of data, <b>PrintStream</b> handles <i>display</i>.<br></p>
</td>
<td width="161.333293" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>OutputStream</b>, with optional <b>boolean</b> indicating that the buffer is flushed with every newline.<br></p>
</td>
</tr>
<tr valign="top">
<td width="161.333293" colspan="1" rowspan="1" valign="top">
<p class="Table">Should be the &#147;final&#148; wrapping for your <b>OutputStream</b> object. You&#146;ll probably use this a lot.<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="2" valign="top">
<p class="Table"><b>Buffered-OutputStream</b><br></p>
</td>
<td width="173.333290" colspan="1" rowspan="2" valign="top">
<p class="Table">Use this to prevent a physical write every time you send a piece of data. You&#146;re saying &#147;Use a buffer.&#148; You can call <b>flush(&#160;)</b> to flush the buffer.<br></p>
</td>
<td width="161.333293" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>OutputStream</b>, with optional buffer size.<br></p>
</td>
</tr>
<tr valign="top">
<td width="161.333293" colspan="1" rowspan="1" valign="top">
<p class="Table">This doesn&#146;t provide an interface <i>per se</i>, just a requirement that a buffer is used. Attach an interface object.<br></p>
</td>
</tr>
</table></div>
<h2>
<a name="_Toc375545389"></a><a name="_Toc24775793"></a><a name="Heading14219"></a><b>Reader</b>s
&amp; <b>Writer</b>s<br></h2>
<p><a name="Index1248"></a>Java 1.1 made some significant modifications to the fundamental I/O stream library. When you see the <a name="Index1249"></a><a name="Index1250"></a><b>Reader</b> and <a name="Index1251"></a><a name="Index1252"></a><b>Writer</b> classes, your first thought (like mine) might be that these were meant to replace the <b>InputStream</b> and <b>OutputStream</b> classes. But that&#146;s not the case. Although some aspects of the original streams library are deprecated (if you use them you will receive a warning from the compiler), the <b>InputStream</b> and <b>OutputStream</b> classes still provide valuable functionality in the form of <b>byte</b>-oriented I/O, whereas the <b>Reader </b>and <b>Writer </b>classes provide Unicode-compliant, character-based I/O. In addition:  <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1657" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li><a name="Index1253"></a><a name="Index1254"></a><a name="Index1255"></a><a name="Index1256"></a>Java
1.1 added new classes into the <b>InputStream </b>and <b>OutputStream
</b>hierarchy, so it&#146;s obvious those hierarchies weren&#146;t being
replaced. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1658" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>There are times when you must use classes from the &#147;byte&#148;
hierarchy <i>in combination</i> with classes in the &#147;character&#148;
hierarchy. To accomplish this, there are &#147;adapter&#148; classes:
<b>InputStreamReader</b> converts an <b>InputStream </b>to a <b>Reader </b>and
<b>OutputStreamWriter</b> converts an <b>OutputStream</b> to a <b>Writer</b>.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1659"
title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>The most important reason for the <b>Reader</b> and <b>Writer</b> hierarchies is for internationalization. The old I/O stream hierarchy supports only 8-bit byte streams and doesn&#146;t handle the 16-bit Unicode characters well. Since Unicode is used for internationalization (and Java&#146;s native <a name="Index1257"></a><a name="Index1258"></a><b>char </b>is 16-bit Unicode), the <a name="Index1259"></a><a name="Index1260"></a><b>Reader</b> and <b>Writer</b> hierarchies were added to support Unicode in all I/O operations. In addition, the new libraries are designed for faster operations than the old. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1660" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As is the practice in this book, I will attempt to provide an overview of the classes, but assume that you will use the JDK documentation to determine all the details, such as the exhaustive list of methods. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1661" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775794"></a><a name="Heading14225"></a>Sources and sinks of
data</h3>
<p>Almost all of the original Java I/O stream classes have corresponding <b>Reader</b> and <b>Writer</b> classes to provide native Unicode manipulation. However, there are some places where the <b>byte</b>-oriented <b>InputStream</b>s and <b>OutputStream</b>s are the correct solution;<b> </b>in particular, the <b>java.util.zip</b> libraries are <b>byte</b>-oriented rather than <b>char</b>-oriented. So the most sensible approach to take is to <i>try</i> to use the <b>Reader</b> and <b>Writer</b> classes whenever you can, and you&#146;ll discover the situations when you have to use the <b>byte</b>-oriented libraries, because your code won&#146;t compile. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1662" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here is a table that shows the correspondence between the sources and sinks of information (that is, where the data physically comes from or goes to) in the two hierarchies. <br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><a name="Index1261"></a><a name="Index1262"></a><a name="Index1263"></a><a name="Index1264"></a><a name="Index1265"></a><a name="Index1266"></a><a name="Index1267"></a><a name="Index1268"></a><a name="Index1269"></a><a name="Index1270"></a><a name="Index1271"></a><a name="Index1272"></a><a name="Index1273"></a><a name="Index1274"></a><a name="Index1275"></a><a name="Index1276"></a><a name="Index1277"></a><a name="Index1278"></a><a name="Index1279"></a><a name="Index1280"></a><a name="Index1281"></a><a name="Index1282"></a><a name="Index1283"></a><a name="Index1284"></a><b>Sources &amp; Sinks:</b><br><b>Java 1.0 class</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Corresponding Java 1.1 class</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>InputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Reader </b><br>adapter:<br><b>InputStreamReader</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>OutputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Writer </b><br>adapter:<b> </b><br><b>OutputStreamWriter</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>FileInputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>FileReader</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>FileOutputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>FileWriter</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>StringBufferInputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>StringReader</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table">(no corresponding class)<br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>StringWriter</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>ByteArrayInputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>CharArrayReader</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>ByteArrayOutputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>CharArrayWriter</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PipedInputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PipedReader</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PipedOutputStream</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PipedWriter</b><br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">In general, you&#146;ll find that the interfaces for the two different hierarchies are similar if not identical.<br></p>
<h3>
<a name="_Toc24775795"></a><a name="Heading14251"></a>Modifying stream
behavior</h3>
<p>For <b>InputStream</b>s and <b>OutputStream</b>s, streams were adapted for particular needs using &#147;decorator&#148; subclasses of <b>FilterInputStream</b> and <b>FilterOutputStream.</b> The <b>Reader</b> and <b>Writer</b> class hierarchies continue the use of this idea&#151;but not exactly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1663" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the following table, the correspondence is a rougher approximation than in the previous table. The difference is because of the class organization; although <b>BufferedOutputStream</b> is a subclass of <b>FilterOutputStream</b>, <b>BufferedWriter</b> is <i>not</i> a subclass of <b>FilterWriter</b> (which, even though it is <b>abstract</b>, has no subclasses and so appears to have been put in either as a placeholder or simply so you wouldn&#146;t wonder where it was). However, the interfaces to the classes are quite a close match. <br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<th width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><a name="Index1285"></a><a name="Index1286"></a><a name="Index1287"></a><a name="Index1288"></a><a name="Index1289"></a><a name="Index1290"></a><a name="Index1291"></a><a name="Index1292"></a><a name="Index1293"></a><a name="Index1294"></a><a name="Index1295"></a><a name="Index1296"></a><a name="Index1297"></a><a name="Index1298"></a><a name="Index1299"></a><a name="Index1300"></a><a name="Index1301"></a><a name="Index1302"></a><a name="Index1303"></a><a name="Index1304"></a><b>Filters:</b><br><b>Java 1.0 class</b><br></p>
</th>
<th width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Corresponding Java 1.1 class</b><br></p>
</th>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>FilterInputStream</b><br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>FilterReader</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>FilterOutputStream</b><br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>FilterWriter </b>(abstract class with no subclasses)<br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>BufferedInputStream</b><br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>BufferedReader</b><br>(also has<b> readLine(&#160;)</b>)<br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>BufferedOutputStream</b><br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>BufferedWriter</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>DataInputStream</b><br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table">Use<b> DataInputStream</b><br>(except when you need to use<b> readLine(&#160;)</b>,<b> </b>when you should use a<b> BufferedReader</b>)<br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PrintStream</b><br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PrintWriter</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>LineNumberInputStream</b><br>(deprecated)<br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>LineNumberReader</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>StreamTokenizer</b><br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>StreamTokenizer</b><br>(use constructor that takes a <b>Reader</b> instead)<br></p>
</td>
</tr>
<tr valign="top">
<td width="215.999946" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PushBackInputStream</b><br></p>
</td>
<td width="251.999937" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>PushBackReader</b><br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">There&#146;s one direction that&#146;s quite clear: Whenever you want to use <b>readLine(&#160;)</b>, you shouldn&#146;t do it with a <b>DataInputStream</b> (this is met with a deprecation message at compile time), but instead use a <b>BufferedReader</b>. Other than this, <b>DataInputStream</b> is still a &#147;preferred&#148; member of the I/O library.<br></p>
<p>To make the transition to using a <b>PrintWriter</b> easier, it has constructors that take any <b>OutputStream</b> object as well as <b>Writer</b> objects. However, <b>PrintWriter</b> has no more support for formatting than <b>PrintStream</b> does; the interfaces are virtually the same. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1664" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>PrintWriter</b> constructor also has an option to perform automatic flushing, which happens after every <b>println(&#160;)</b> if the constructor flag is set. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1665" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775796"></a><a name="Heading14277"></a>Unchanged Classes</h3>
<p>Some classes were left unchanged between Java 1.0 and Java 1.1: <br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<th width="221.333278" colspan="1" rowspan="1" valign="top">
<p class="Table"><a name="Index1305"></a><a name="Index1306"></a><a name="Index1307"></a><a name="Index1308"></a><a name="Index1309"></a><a name="Index1310"></a><a name="Index1311"></a><a name="Index1312"></a>Java 1.0 classes without corresponding Java 1.1 classes<br></p>
</th>
</tr>
<tr valign="top">
<td width="221.333278" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>DataOutputStream</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="221.333278" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>File</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="221.333278" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>RandomAccessFile</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="221.333278" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>SequenceInputStream</b><br></p>
</td>
</tr>
</table></div>
<p class="TableFollower"><b>DataOutputStream</b>, in particular, is used without change, so for storing and retrieving data in a transportable format, you use the <b>InputStream</b> and <b>OutputStream</b> hierarchies.<br></p>
<h2>
<a name="_Toc24775797"></a><a name="Heading14285"></a>Off by itself:
<br>RandomAccessFile<br></h2>
<p><a name="Index1313"></a><a name="Index1314"></a><b>RandomAccessFile</b> is used for files containing records of known size so that you can move from one record to another using <a name="Index1315"></a><a name="Index1316"></a><b>seek(&#160;)</b>, then read or change the records. The records don&#146;t have to be the same size; you just have to be able to determine how big they are and where they are placed in the file. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1666" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>At first it&#146;s a little bit hard to believe that <b>RandomAccessFile</b> is not part of the <b>InputStream</b> or <b>OutputStream</b> hierarchy. However, it has no association with those hierarchies other than that it happens to implement the <a name="Index1317"></a><a name="Index1318"></a><b>DataInput</b> and <a name="Index1319"></a><a name="Index1320"></a><b>DataOutput</b> interfaces (which are also implemented by <b>DataInputStream</b> and <b>DataOutputStream</b>). It doesn&#146;t even use any of the functionality of the existing <b>InputStream</b> or <b>OutputStream</b> classes; it&#146;s a completely separate class, written from scratch, with all of its own (mostly native) methods. The reason for this may be that <b>RandomAccessFile</b> has essentially different behavior than the other I/O types, since you can move forward and backward within a file. In any event, it stands alone, as a direct descendant of <b>Object</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1667" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Essentially, a <b>RandomAccessFile</b> works like a <b>DataInputStream</b> pasted together with a <b>DataOutputStream</b>, along with the methods <b>getFilePointer(&#160;)</b> to find out where you are in the file, <b>seek(&#160;)</b> to move to a new point in the file, and <b>length(&#160;)</b> to determine the maximum size of the file. In addition, the constructors require a second argument (identical to <b>fopen(&#160;) </b>in C) indicating whether you are just randomly reading (<b>&#147;r&#148;</b>) or reading and writing (<b>&#147;rw&#148;</b>). There&#146;s no support for write-only files, which could suggest that <b>RandomAccessFile</b> might have worked well if it were inherited from <b>DataInputStream</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1668" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The seeking methods are available only in <b>RandomAccessFile</b>, which works for files only. <b>BufferedInputStream</b> does allow you to <a name="Index1321"></a><a name="Index1322"></a><b>mark(&#160;)</b> a position (whose value is held in a single internal variable) and <a name="Index1323"></a><a name="Index1324"></a><b>reset(&#160;)</b> to that position, but this is limited and not very useful. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1669" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Most, if not all, of the <b>RandomAccessFile</b> functionality is superceded in JDK 1.4 with the <b>nio</b> <i>memory-mapped files</i>, which will be described later in this chapter.<br></p>
<h2>
<a name="_Toc375545393"></a><a name="_Toc24775798"></a><a name="Heading14291"></a>Typical
uses of I/O streams</h2>
<p>Although you can combine the I/O stream classes in many different ways, you&#146;ll probably just use a few combinations. The following example can be used as a basic reference; it shows the creation and use of typical I/O configurations. Note that each configuration begins with a commented number and title that corresponds to the heading for the appropriate explanation that follows in the text.<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:IOStreamDemo.java</font>
<font color=#009900>// Typical I/O stream configurations.</font>
<font color=#009900>// {RunByHand}</font>
<font color=#009900>// {Clean: IODemo.out,Data.txt,rtest.dat}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOStreamDemo {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException {
    <font color=#009900>// 1. Reading input by lines:</font>
    BufferedReader in = <font color=#0000ff>new</font> BufferedReader(
      <font color=#0000ff>new</font> FileReader(<font color=#004488>"IOStreamDemo.java"</font>));
    String s, s2 = <font color=#0000ff>new</font> String();
    <font color=#0000ff>while</font>((s = in.readLine())!= <font color=#0000ff>null</font>)
      s2 += s + <font color=#004488>"\n"</font>;
    in.close();

    <font color=#009900>// 1b. Reading standard input:</font>
    BufferedReader stdin = <font color=#0000ff>new</font> BufferedReader(
      <font color=#0000ff>new</font> InputStreamReader(System.in));
    System.out.print(<font color=#004488>"Enter a line:"</font>);
    System.out.println(stdin.readLine());

    <font color=#009900>// 2. Input from memory</font>
    StringReader in2 = <font color=#0000ff>new</font> StringReader(s2);
    <font color=#0000ff>int</font> c;
    <font color=#0000ff>while</font>((c = in2.read()) != -1)
      System.out.print((<font color=#0000ff>char</font>)c);

    <font color=#009900>// 3. Formatted memory input</font>
    <font color=#0000ff>try</font> {
      DataInputStream in3 = <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(s2.getBytes()));
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>)
        System.out.print((<font color=#0000ff>char</font>)in3.readByte());
    } <font color=#0000ff>catch</font>(EOFException e) {
      System.err.println(<font color=#004488>"End of stream"</font>);
    }

    <font color=#009900>// 4. File output</font>
    <font color=#0000ff>try</font> {
      BufferedReader in4 = <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> StringReader(s2));
      PrintWriter out1 = <font color=#0000ff>new</font> PrintWriter(
        <font color=#0000ff>new</font> BufferedWriter(<font color=#0000ff>new</font> FileWriter(<font color=#004488>"IODemo.out"</font>)));
      <font color=#0000ff>int</font> lineCount = 1;
      <font color=#0000ff>while</font>((s = in4.readLine()) != <font color=#0000ff>null</font> )
        out1.println(lineCount++ + <font color=#004488>": "</font> + s);
      out1.close();
    } <font color=#0000ff>catch</font>(EOFException e) {
      System.err.println(<font color=#004488>"End of stream"</font>);
    }

    <font color=#009900>// 5. Storing &amp; recovering data</font>
    <font color=#0000ff>try</font> {
      DataOutputStream out2 = <font color=#0000ff>new</font> DataOutputStream(
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
      out2.writeDouble(3.14159);
      out2.writeUTF(<font color=#004488>"That was pi"</font>);
      out2.writeDouble(1.41413);
      out2.writeUTF(<font color=#004488>"Square root of 2"</font>);
      out2.close();
      DataInputStream in5 = <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
      <font color=#009900>// Must use DataInputStream for data:</font>
      System.out.println(in5.readDouble());
      <font color=#009900>// Only readUTF() will recover the</font>
      <font color=#009900>// Java-UTF String properly:</font>
      System.out.println(in5.readUTF());
      <font color=#009900>// Read the following double and String:</font>
      System.out.println(in5.readDouble());
      System.out.println(in5.readUTF());
    } <font color=#0000ff>catch</font>(EOFException e) {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
    }

    <font color=#009900>// 6. Reading/writing random access files</font>
    RandomAccessFile rf =
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      rf.writeDouble(i*1.414);
    rf.close();
    rf = <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
    rf.seek(5*8);
    rf.writeDouble(47.0001);
    rf.close();
    rf = <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"r"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      System.out.println(<font color=#004488>"Value "</font> + i + <font color=#004488>": "</font> +
        rf.readDouble());
    rf.close();
    monitor.expect(<font color=#004488>"IOStreamDemo.out"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Here are the descriptions for the numbered sections of the program: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1670" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545394"></a><a name="_Toc24775799"></a><a name="Heading14394"></a>Input
streams</h3>
<p>Parts 1 through 4 demonstrate the creation and use of input streams. Part 4 also shows the simple use of an output stream.<br></p>
<h4>
<a name="Heading14396"></a>1. Buffered input file</h4>
<p>To open a file for character input, you use a <a name="Index1326"></a><a name="Index1327"></a><b>FileInputReader</b> with a <b>String</b> or a <b>File</b> object as the file name. For speed, you&#146;ll want that file to be buffered so you give the resulting reference to the constructor for a <a name="Index1328"></a><a name="Index1329"></a><b>BufferedReader</b>. Since <b>BufferedReader</b> also provides the <b>readLine(&#160;)</b> method, this is your final object and the interface you read from. When you reach the end of the file, <b>readLine(&#160;)</b> returns <b>null</b> so that is used to break out of the <b>while</b> loop. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1671" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>String s2</b> is used to accumulate the entire contents of the file (including newlines that must be added since <b>readLine(&#160;)</b> strips them off). <b>s2 </b>is then used in the later portions of this program. Finally, <b>close(&#160;)</b> is called to close the file. Technically, <b>close(&#160;)</b> will be called when <b>finalize(&#160;)</b> runs, and this is supposed to happen (whether or not garbage collection occurs) as the program exits. However, this has been inconsistently implemented, so the only safe approach is to explicitly call <a name="Index1330"></a><a name="Index1331"></a><b>close(&#160;)</b> for files. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1672" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Section 1b shows how you can wrap <a name="Index1332"></a><a name="Index1333"></a><b>System.in</b> for reading console input. <a name="Index1334"></a><a name="Index1335"></a><a name="Index1336"></a><b>System.in</b> is an <b>InputStream</b>, and <b>BufferedReader</b> needs a <b>Reader</b> argument, so <b>InputStreamReader</b> is brought in to perform the adaptation. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1673" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading14400"></a>2. Input from memory</h4>
<p>This section takes the <b>String s2</b> that now contains the entire contents of the file and uses it to create a <a name="Index1337"></a><a name="Index1338"></a><b>StringReader</b>. Then <b>read(&#160;)</b> is used to read each character one at a time and send it out to the console. Note that <b>read(&#160;)</b> returns the next byte as an <b>int</b> and thus it must be cast to a <b>char</b> to print properly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1674" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading14402"></a>3. Formatted memory input</h4>
<p>To read &#147;formatted&#148; data, you use a <a name="Index1339"></a><a name="Index1340"></a><b>DataInputStream</b>, which is a <b>byte</b>-oriented I/O class (rather than <b>char</b>-oriented). Thus you must use all <b>InputStream</b> classes rather than <b>Reader</b> classes. Of course, you can read anything (such as a file) as bytes using <b>InputStream</b> classes, but here a <b>String</b> is used. To convert the <b>String</b> to an array of bytes, which is what is appropriate for a <b>ByteArrayInputStream</b>, <b>String</b> has a <a name="Index1341"></a><b>getBytes(&#160;)</b> method to do the job. At that point, you have an appropriate <b>InputStream</b> to hand to <b>DataInputStream</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1675" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you read the characters from a <b>DataInputStream </b>one byte at a time using <b>readByte(&#160;)</b>, any byte value is a legitimate result, so the return value cannot be used to detect the end of input. Instead, you can use the <a name="Index1342"></a><a name="Index1343"></a><b>available(&#160;) </b>method to find out how many more characters are available. Here&#146;s an example that shows how to read a file one byte at a time:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:TestEOF.java</font>
<font color=#009900>// Testing for end of file while reading a byte at a time.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestEOF {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException {
    DataInputStream in = <font color=#0000ff>new</font> DataInputStream(
      <font color=#0000ff>new</font> BufferedInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"TestEOF.java"</font>)));
    <font color=#0000ff>while</font>(in.available() != 0)
      System.out.print((<font color=#0000ff>char</font>)in.readByte());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Note that <b>available(&#160;)</b> works differently depending on what sort of medium you&#146;re reading from; it&#146;s literally &#147;the number of bytes that can be read <i>without blocking</i>.&#148; With a file, this means the whole file, but with a different kind of stream this might not be true, so use it thoughtfully. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1676" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1344"></a><a name="Index1345"></a>You could also detect the end of input in cases like these by catching an exception. However, the use of exceptions for control flow is considered a misuse of that feature. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1677" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading14423"></a>4. File output</h4>
<p>This example also shows how to write data to a file. First, a <a name="Index1346"></a><a name="Index1347"></a><b>FileWriter</b> is created to connect to the file. You&#146;ll virtually always want to buffer the output by wrapping it in a <a name="Index1348"></a><a name="Index1349"></a><b>BufferedWriter</b> (try removing this wrapping to see the impact on the performance&#151;buffering tends to dramatically increase performance of I/O operations). Then for the formatting it&#146;s turned into a <a name="Index1350"></a><a name="Index1351"></a><b>PrintWriter</b>. The data file created this way is readable as an ordinary text file. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1678" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As the lines are written to the file, line numbers are added. Note that <b>LineNumberInputStream</b> is <i>not</i> used, because it&#146;s a silly class and you don&#146;t need it. As shown here, it&#146;s trivial to keep track of your own line numbers. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1679" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1352"></a><a name="Index1353"></a>When the input stream is exhausted, <a name="Index1354"></a><a name="Index1355"></a><b>readLine(&#160;)</b> returns <b>null</b>. You&#146;ll see an explicit <b>close(&#160;)</b> for <b>out1</b>, because if you don&#146;t call <b>close(&#160;)</b> for all your output files, you might discover that the buffers don&#146;t get flushed, so they&#146;re incomplete. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1680" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545395"></a><a name="_Toc24775800"></a><a name="Heading14427"></a>Output
streams</h3>
<p>The two primary kinds of output streams are separated by the way they write data; one writes it for human consumption, and the other writes it to be reacquired by a <a name="Index1356"></a><a name="Index1357"></a><b>DataInputStream</b>. The <a name="Index1358"></a><a name="Index1359"></a><b>RandomAccessFile</b> stands alone, although its data format is compatible with the <b>DataInputStream</b> and <a name="Index1360"></a><a name="Index1361"></a><b>DataOutputStream</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1681" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading14429"></a>5. Storing and recovering data<br></h4>
<p><a name="Index1362"></a><a name="Index1363"></a>A <b>PrintWriter</b> formats data so that it&#146;s readable by a human. However, to output data for recovery by another stream, you use a <b>DataOutputStream</b> to write the data and a <b>DataInputStream</b> to recover the data. Of course, these streams could be anything, but here a file is used, buffered for both reading and writing. <b>DataOutputStream</b> and <b>DataInputStream</b> are <b>byte</b>-oriented and thus require the <b>InputStream</b>s and <b>OutputStream</b>s. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1682" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you use a <b>DataOutputStream</b> to write the data, then Java guarantees that you can accurately recover the data using a <b>DataInputStream</b>&#151;regardless of what different platforms write and read the data. This is incredibly valuable, as anyone knows who has spent time worrying about platform-specific data issues. That problem vanishes if you have Java on both platforms.<sup><a name="fnB63" href="#fn63">[63]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1683" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1364"></a><a name="Index1365"></a><a name="Index1366"></a><a name="Index1367"></a>When using a <b>DataOutputStream</b>, the only reliable way to write a <b>String</b> so that it can be recovered by a <b>DataInputStream</b> is to use UTF-8 encoding, accomplished in section 5 of the example using <b>writeUTF(&#160;)</b> and <b>readUTF(&#160;)</b>. UTF-8 is a variation on Unicode, which stores all characters in two bytes. If you&#146;re working with ASCII or mostly ASCII characters (which occupy only seven bits), this is a tremendous waste of space and/or bandwidth, so UTF-8 encodes ASCII characters in a single byte, and non-ASCII characters in two or three bytes. In addition, the length of the string is stored in the first two bytes. However, <b>writeUTF(&#160;)</b> and <b>readUTF(&#160;)</b> use a special variation of UTF-8 for Java (which is completely described in the JDK documentation for those methods) , so if you read a string written with <b>writeUTF(&#160;)</b> using a non-Java program, you must write special code in order to read the string properly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1684" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>With <b>writeUTF(&#160;)</b> and <b>readUTF(&#160;)</b>, you can intermingle <b>String</b>s and other types of data using a <b>DataOutputStream </b>with the knowledge that the <b>String</b>s will be properly stored as Unicode, and will be easily recoverable with a <b>DataInputStream</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1685" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <a name="Index1368"></a><a name="Index1369"></a><b>writeDouble(&#160;)</b> stores the <b>double</b> number to the stream and the complementary <a name="Index1370"></a><a name="Index1371"></a><b>readDouble(&#160;)</b> recovers it (there are similar methods for reading and writing the other types). But for any of the reading methods to work correctly, you must know the exact placement of the data item in the stream, since it would be equally possible to read the stored <b>double</b> as a simple sequence of bytes, or as a <b>char</b>, etc. So you must either have a fixed format for the data in the file, or extra information must be stored in the file that you parse to determine where the data is located. Note that object serialization (described later in this chapter) may be an easier way to store and retrieve complex data structures. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1686" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading14436"></a>6. Reading and writing random access files</h4>
<p>As previously noted, the <b>RandomAccessFile</b> is almost totally isolated from the rest of the I/O hierarchy, save for the fact that it implements the <b>DataInput</b> and <b>DataOutput</b> interfaces. So you cannot combine it with any of the aspects of the <b>InputStream</b> and <b>OutputStream</b> subclasses. Even though it might make sense to treat a <b>ByteArrayInputStream</b> as a random-access element, you can use <b>RandomAccessFile</b> only to open a file. You must assume a <b>RandomAccessFile</b> is properly buffered since you cannot add that. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1687" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The one option you have is in the second constructor argument: you can open a <b>RandomAccessFile</b> to read (<b>&#147;r&#148;</b>) or read and write (<b>&#147;rw&#148;</b>). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1688" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Using a <b>RandomAccessFile</b> is like using a combined <b>DataInputStream</b> and <b>DataOutputStream</b> (because it implements the equivalent interfaces). In addition, you can see that <a name="Index1372"></a><a name="Index1373"></a><b>seek(&#160;)</b> is used to move about in the file and change one of the values. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1689" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>With the advent of new I/O in JDK 1.4, you may want to consider using memory-mapped files instead of <b>RandomAccessFile</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1690" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775801"></a><a name="Heading14441"></a>Piped streams<br></h3>
<p><a name="Index1374"></a><a name="Index1375"></a>The <b>PipedInputStream</b>, <b>PipedOutputStream</b>, <b>PipedReader</b> and <b>PipedWriter</b> have been mentioned only briefly in this chapter. This is not to suggest that they aren&#146;t useful, but their value is not apparent until you begin to understand multithreading, since the piped streams are used to communicate between threads. This is covered along with an example in Chapter 13. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1691" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775802"></a><a name="Heading14443"></a>File reading &amp; writing
utilities</h2>
<p>A very common programming task is to read a file into memory, modify it, and then write it out again. One of the problems with the Java I/O library is that it requires you to write quite a bit of code in order to perform these common operations&#151;there are no basic helper function to do them for you. What&#146;s worse, the decorators make it rather hard to remember how to open files. Thus, it makes sense to add helper classes to your library that will easily perform these basic tasks for you. Here&#146;s one that contains <b>static</b> methods to read and write text files as a single string. In addition, you can create a <b>TextFile</b> class that holds the lines of the file in an <b>ArrayList</b> (so you have all the <b>ArrayList</b> functionality available while manipulating the file contents): <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0603" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:TextFile.java</font>
<font color=#009900>// Static functions for reading and writing text files as</font>
<font color=#009900>// a single string, and treating a file as an ArrayList.</font>
<font color=#009900>// {Clean: test.txt test2.txt}</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TextFile <font color=#0000ff>extends</font> ArrayList {
  <font color=#009900>// Tools to read and write files as single strings:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> String
  read(String fileName) <font color=#0000ff>throws</font> IOException {
    StringBuffer sb = <font color=#0000ff>new</font> StringBuffer();
    BufferedReader in =
      <font color=#0000ff>new</font> BufferedReader(<font color=#0000ff>new</font> FileReader(fileName));
    String s;
    <font color=#0000ff>while</font>((s = in.readLine()) != <font color=#0000ff>null</font>) {
      sb.append(s);
      sb.append(<font color=#004488>"\n"</font>);
    }
    in.close();
    <font color=#0000ff>return</font> sb.toString();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  write(String fileName, String text) <font color=#0000ff>throws</font> IOException {
    PrintWriter out = <font color=#0000ff>new</font> PrintWriter(
      <font color=#0000ff>new</font> BufferedWriter(<font color=#0000ff>new</font> FileWriter(fileName)));
    out.print(text);
    out.close();
  }
  <font color=#0000ff>public</font> TextFile(String fileName) <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>super</font>(Arrays.asList(read(fileName).split(<font color=#004488>"\n"</font>)));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> write(String fileName) <font color=#0000ff>throws</font> IOException {
    PrintWriter out = <font color=#0000ff>new</font> PrintWriter(
      <font color=#0000ff>new</font> BufferedWriter(<font color=#0000ff>new</font> FileWriter(fileName)));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size(); i++)
      out.println(get(i));
    out.close();
  }
  <font color=#009900>// Simple test:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    String file = read(<font color=#004488>"TextFile.java"</font>);
    write(<font color=#004488>"test.txt"</font>, file);
    TextFile text = <font color=#0000ff>new</font> TextFile(<font color=#004488>"test.txt"</font>);
    text.write(<font color=#004488>"test2.txt"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>All methods simply pass <b>IOException</b>s out to the caller. <b>read(&#160;)</b> appends each line to a <b>StringBuffer</b> (for efficiency) followed by a newline, because that is stripped out during reading. Then it returns a <b>String</b> containing the whole file. <b>Write(&#160;)</b> opens and writes the text to the file. Both methods remember to <b>close(&#160;)</b> the file when they are done. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0618" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The constructor uses the <b>read(&#160;)</b> method to turn the file into a <b>String</b>, then uses <b>String.split(&#160;)</b> to divide the result into lines along newline boundaries (if you use this class a lot, you may want to rewrite this constructor to improve efficiency). Alas, there is no corresponding &#147;join&#148; method, so the non-<b>static write(&#160;)</b> method must write the lines out by hand. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0619" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In <b>main(&#160;)</b>, a basic test is performed to ensure that the methods work. Although this is a small amount of code, using it can save a lot of time and make your life easier, as you&#146;ll see in some of the examples later in this chapter. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0604" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775803"></a><a name="Heading14497"></a>Standard I/O<br></h2>
<p><a name="Index1376"></a><a name="Index1377"></a><a name="Index1378"></a><a name="Index1379"></a><a name="Index1380"></a><a name="Index1381"></a><a name="Index1382"></a><a name="Index1383"></a><a name="Index1384"></a>The term <i>standard I/O</i> refers to the Unix concept (which is reproduced in some form in Windows and many other operating systems) of a single stream of information that is used by a program. All the program&#146;s input can come from <i>standard input</i>, all its output can go to <i>standard output</i>, and all of its error messages can be sent to <i>standard error</i>. The value of standard I/O is that programs can easily be chained together, and one program&#146;s standard output can become the standard input for another program. This is a powerful tool. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1692" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545397"></a><a name="_Toc24775804"></a><a name="Heading14499"></a>Reading
from standard input</h3>
<p>Following the standard I/O model, Java has <b>System.in</b>, <b>System.out,</b> and <b>System.err</b>. Throughout this book, you&#146;ve seen how to write to standard output using <b>System.out,</b> which is already prewrapped as a <b>PrintStream</b> object. <b>System.err</b> is likewise a <b>PrintStream</b>, but <b>System.in</b> is a raw <b>InputStream</b> with no wrapping. This means that although you can use <b>System.out</b> and <b>System.err</b> right away, <b>System.in</b> must be wrapped before you can read from it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1693" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Typically, you&#146;ll want to read input a line at a time using <b>readLine(&#160;)</b>, so you&#146;ll want to wrap <b>System.in</b> in a <b>BufferedReader</b>. To do this, you must convert <b>System.in </b>to a <b>Reader</b> using <b>InputStreamReader</b>. Here&#146;s an example that simply echoes each line that you type in:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Echo.java</font>
<font color=#009900>// How to read from standard input.</font>
<font color=#009900>// {RunByHand}</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Echo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException {
    BufferedReader in = <font color=#0000ff>new</font> BufferedReader(
      <font color=#0000ff>new</font> InputStreamReader(System.in));
    String s;
    <font color=#0000ff>while</font>((s = in.readLine()) != <font color=#0000ff>null</font> &amp;&amp; s.length() != 0)
      System.out.println(s);
    <font color=#009900>// An empty line or Ctrl-Z terminates the program</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The reason for the exception specification is that <a name="Index1385"></a><a name="Index1386"></a><b>readLine(&#160;)</b> can throw an <b>IOException</b>. Note that <b>System.in</b> should usually be buffered, as with most streams. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1694" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775805"></a><a name="Heading14520"></a>Changing <b>System.out</b>
to a <b>PrintWriter</b></h3>
<p><b>System.out</b> is a <b>PrintStream</b>, which is an <b>OutputStream</b>.<b> PrintWriter</b> has a constructor that takes an <b>OutputStream</b> as an argument. Thus, if you want, you can convert <b>System.out</b> into a <b>PrintWriter</b> using that constructor:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:ChangeSystemOut.java</font>
<font color=#009900>// Turn System.out into a PrintWriter.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ChangeSystemOut {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    PrintWriter out = <font color=#0000ff>new</font> PrintWriter(System.out, <font color=#0000ff>true</font>);
    out.println(<font color=#004488>"Hello, world"</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Hello, world"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>It&#146;s important to use the two-argument version of the <b>PrintWriter</b> constructor and to set the second argument to <b>true</b> in order to enable automatic flushing; otherwise, you may not see the output. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1695" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775806"></a><a name="Heading14539"></a>Redirecting standard
I/O<br></h3>
<p><a name="Index1387"></a><a name="Index1388"></a>The Java <b>System</b> class allows you to redirect the standard input, output, and error I/O streams using simple static method calls:<br></p>
<p><a name="Index1389"></a><a name="Index1390"></a><b>setIn(InputStream) </b><br><a name="Index1391"></a><a name="Index1392"></a><b>setOut(PrintStream)</b><br><a name="Index1393"></a><a name="Index1394"></a><b>setErr(PrintStream) </b><font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1696" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Redirecting output is especially useful if you suddenly start creating a large amount of output on your screen, and it&#146;s scrolling past faster than you can read it.<sup><a name="fnB64" href="#fn64">[64]</a></sup> Redirecting input is valuable for a command-line program in which you want to test a particular user-input sequence repeatedly. Here&#146;s a simple example that shows the use of these methods:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Redirecting.java</font>
<font color=#009900>// Demonstrates standard I/O redirection.</font>
<font color=#009900>// {Clean: test.out}</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Redirecting {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException {
    PrintStream console = System.out;
    BufferedInputStream in = <font color=#0000ff>new</font> BufferedInputStream(
      <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Redirecting.java"</font>));
    PrintStream out = <font color=#0000ff>new</font> PrintStream(
      <font color=#0000ff>new</font> BufferedOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.out"</font>)));
    System.setIn(in);
    System.setOut(out);
    System.setErr(out);
    BufferedReader br = <font color=#0000ff>new</font> BufferedReader(
      <font color=#0000ff>new</font> InputStreamReader(System.in));
    String s;
    <font color=#0000ff>while</font>((s = br.readLine()) != <font color=#0000ff>null</font>)
      System.out.println(s);
    out.close(); <font color=#009900>// Remember this!</font>
    System.setOut(console);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This program attaches standard input to a file and redirects standard output and standard error to another file. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1697" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>I/O redirection manipulates streams of bytes, not streams of characters, thus <b>InputStream</b>s and <b>OutputStream</b>s are used rather than <b>Reader</b>s and <b>Writer</b>s. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1698" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545400"></a><a name="_Toc24775807"></a><a name="Heading14574"></a>New
I/O<br></h2>
<p><a name="Index1395"></a><a name="Index1396"></a><a name="Index1397"></a>The Java &#147;new&#148; I/O library, introduced in JDK 1.4 in the <b>java.nio.*</b> packages, has one goal: speed. In fact, the &#147;old&#148; I/O packages have been reimplemented using <b>nio</b><a name="Index1398"></a> in order to take advantage of this speed increase, so you will benefit even if you don&#146;t explicitly write code with <b>nio</b>. The speed increase occurs in both file I/O, which is explored here,<sup><a name="fnB65" href="#fn65">[65]</a></sup> and in <a name="Index1399"></a><a name="Index1400"></a>network I/O, which is covered in <i>Thinking in Enterprise Java</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0676" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The speed comes from using structures that are closer to the operating system&#146;s way of performing I/O: <i>channels</i> and <i>buffers</i>. You could think of it as a coal mine; the channel is the mine containing the seam of coal (the data), and the buffer is the cart that you send into the mine. The cart comes back full of coal, and you get the coal from the cart. That is, you don&#146;t interact directly with the channel; you interact with the buffer and send the buffer into the channel. The channel either pulls data from the buffer, or puts data into the buffer. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0677" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1401"></a><a name="Index1402"></a><a name="Index1403"></a><a name="Index1404"></a>The only kind of buffer that communicates directly with a channel is a <a name="Index1405"></a><b>ByteBuffer</b>&#151;that is, a buffer that holds raw bytes. If you look at the JDK documentation for <b>java.nio.ByteBuffer</b>, you&#146;ll see that it&#146;s fairly basic: You create one by telling it how much storage to allocate, and there are a selection of methods to put and get data, in either raw byte form or as primitive data types. But there&#146;s no way to put or get an object, or even a <b>String</b>. It&#146;s fairly low-level, precisely because this makes a more efficient mapping with most operating systems. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0678" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Three of the classes in the &#147;old&#148; I/O have been modified so that they produce a <a name="Index1406"></a><b>FileChannel</b>: <b>FileInputStream</b>, <b>FileOutputStream</b>, and, for both reading and writing, <b>RandomAccessFile</b>. Notice that these are the byte manipulation streams, in keeping with the low-level nature of <b>nio</b>. The <b>Reader</b> and <b>Writer</b> character-mode classes do not produce channels, but the class<b> java.nio.channels.Channels</b> has utility methods to produce <b>Reader</b>s and <b>Writer</b>s from channels. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0679" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s a simple example that exercises all three types of stream to produce channels that are writeable, read/writeable, and readable:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:GetChannel.java</font>
<font color=#009900>// Getting channels from streams</font>
<font color=#009900>// {Clean: data.txt}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> java.nio.channels.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GetChannel {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> BSIZE = 1024;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    <font color=#009900>// Write a file:</font>
    FileChannel fc =
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"data.txt"</font>).getChannel();
    fc.write(ByteBuffer.wrap(<font color=#004488>"Some text "</font>.getBytes()));
    fc.close();
    <font color=#009900>// Add to the end of the file:</font>
    fc =
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"data.txt"</font>, <font color=#004488>"rw"</font>).getChannel();
    fc.position(fc.size()); <font color=#009900>// Move to the end</font>
    fc.write(ByteBuffer.wrap(<font color=#004488>"Some more"</font>.getBytes()));
    fc.close();
    <font color=#009900>// Read the file:</font>
    fc = <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"data.txt"</font>).getChannel();
    ByteBuffer buff = ByteBuffer.allocate(BSIZE);
    fc.read(buff);
    buff.flip();
    <font color=#0000ff>while</font>(buff.hasRemaining())
      System.out.print((<font color=#0000ff>char</font>)buff.get());    
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>For any of the stream classes shown here, <a name="Index1407"></a><b>getChannel(&#160;)</b> will produce a <b>FileChannel</b>. A channel is fairly basic: You can hand it a <b>ByteBuffer</b> for reading or writing, and you can lock regions of the file for exclusive access (this will be described later). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0680" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One way to put bytes into a <b>ByteBuffer</b> is to stuff them in directly using one of the &#147;put&#148; methods, to put one or more bytes, or values of primitive types. However, as seen here, you can also &#147;wrap&#148; an existing <b>byte</b> array in a <b>ByteBuffer</b> using the <b>wrap(&#160;)</b> method. When you do this, the underlying array is not copied, but instead is used as the storage for the generated <b>ByteBuffer</b>. We say that the <b>ByteBuffer</b> is &#147;backed by&#148; the array. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0681" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>data.txt</b> file is reopened using a <a name="Index1408"></a><b>RandomAccessFile</b>. Notice that you can move the <b>FileChannel</b> around in the file; here, it is moved to the end so that additional writes will be appended. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0682" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>For read-only access, you must explicitly allocate a <b>ByteBuffer</b> using the <b>static </b><a name="Index1409"></a><b>allocate(&#160;)</b> method. The goal of <b>nio</b> is to rapidly move large amounts of data, so the size of the <b>ByteBuffer</b> should be significant&#151;in fact, the 1K used here is probably quite a bit smaller than you&#146;d normally want to use (you&#146;ll have to experiment with your working application to find the best size). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0683" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s also possible to go for even more speed by using <a name="Index1410"></a><b>allocateDirect(&#160;)</b> instead of <b>allocate(&#160;)</b> to produce a &#147;direct&#148; buffer that may have an even higher coupling with the operating system. However, the overhead in such an allocation is greater, and the actual implementation varies from one operating system to another, so again, you must experiment with your working application to discover whether direct buffers will buy you any advantage in speed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0684" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once you call <a name="Index1411"></a><b>read(&#160;)</b> to tell the <b>FileChannel</b> to store bytes into the <b>ByteBuffer</b>, you must call <a name="Index1412"></a><b>flip(&#160;)</b> on the buffer to tell it to get ready to have its bytes extracted (yes, this seems a bit crude, but remember that it&#146;s very low-level and is done for maximum speed). And if we were to use the buffer for further <b>read(&#160;)</b> operations, we&#146;d also have to call <a name="Index1413"></a><b>clear(&#160;)</b> to prepare it for each <b>read(&#160;)</b>. You can see this in a simple file copying program: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0685" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:ChannelCopy.java</font>
<font color=#009900>// Copying a file using channels and buffers</font>
<font color=#009900>// {Args: ChannelCopy.java test.txt}</font>
<font color=#009900>// {Clean: test.txt} </font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> java.nio.channels.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ChannelCopy {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> BSIZE = 1024;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    <font color=#0000ff>if</font>(args.length != 2) {
      System.out.println(<font color=#004488>"arguments: sourcefile destfile"</font>);
      System.exit(1);
    }
    FileChannel 
      in = <font color=#0000ff>new</font> FileInputStream(args[0]).getChannel(),
      out = <font color=#0000ff>new</font> FileOutputStream(args[1]).getChannel();
    ByteBuffer buffer = ByteBuffer.allocate(BSIZE);
    <font color=#0000ff>while</font>(in.read(buffer) != -1) {
      buffer.flip(); <font color=#009900>// Prepare for writing</font>
      out.write(buffer);
      buffer.clear();  <font color=#009900>// Prepare for reading</font>
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that one <b>FileChannel</b> is opened for reading, and one for writing. A <b>ByteBuffer</b> is allocated, and when <b>FileChannel.read(&#160;)</b> returns <b>-1</b> (a holdover, no doubt, from Unix and C), it means that you&#146;ve reached the end of the input. After each <b>read(&#160;)</b>, which puts data into the buffer, <b>flip(&#160;)</b> prepares the buffer so that its information can be extracted by the <a name="Index1414"></a><b>write(&#160;)</b>. After the <b>write(&#160;)</b>, the information is still in the buffer, and <b>clear(&#160;)</b> resets all the internal pointers so that it&#146;s ready to accept data during another <b>read(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0686" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The preceding program is not the ideal way to handle this kind of operation, however. Special methods <a name="Index1415"></a><b>transferTo(&#160;)</b> and <a name="Index1416"></a><b>transferFrom(&#160;)</b> allow you to connect one channel directly to another: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0687" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:TransferTo.java</font>
<font color=#009900>// Using transferTo() between channels</font>
<font color=#009900>// {Args: TransferTo.java TransferTo.txt}</font>
<font color=#009900>// {Clean: TransferTo.txt} </font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> java.nio.channels.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TransferTo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    <font color=#0000ff>if</font>(args.length != 2) {
      System.out.println(<font color=#004488>"arguments: sourcefile destfile"</font>);
      System.exit(1);
    }
    FileChannel 
      in = <font color=#0000ff>new</font> FileInputStream(args[0]).getChannel(),
      out = <font color=#0000ff>new</font> FileOutputStream(args[1]).getChannel();
    in.transferTo(0, in.size(), out);
    <font color=#009900>// Or:</font>
    <font color=#009900>// out.transferFrom(in, 0, in.size());</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You won&#146;t do this kind of thing very often, but it&#146;s good to know about. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0688" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775808"></a><a name="Heading14672"></a>Converting data</h3>
<p>If you look back at <b>GetChannel.java</b>, you&#146;ll notice that, to print the information in the file, we are pulling the data out one <b>byte</b> at a time and casting each <b>byte</b> to a <b>char</b>. This seems a bit primitive&#151;if you look at the <b>java.nio.CharBuffer</b> class, you&#146;ll see that it has a <b>toString(&#160;)</b> method that says: &#147;Returns a string containing the characters in this buffer.&#148; Since a <b>ByteBuffer</b> can be viewed as a <a name="Index1417"></a><b>CharBuffer</b> with the <a name="Index1418"></a><b>asCharBuffer(&#160;)</b> method, why not use that? As you can see from the first line in the <b>expect(&#160;)</b> statement below, this doesn&#146;t work out: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0689" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:BufferToText.java</font>
<font color=#009900>// Converting text to and from ByteBuffers</font>
<font color=#009900>// {Clean: data2.txt}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> java.nio.channels.*;
<font color=#0000ff>import</font> java.nio.charset.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BufferToText {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> BSIZE = 1024;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    FileChannel fc =
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"data2.txt"</font>).getChannel();
    fc.write(ByteBuffer.wrap(<font color=#004488>"Some text"</font>.getBytes()));
    fc.close();
    fc = <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"data2.txt"</font>).getChannel();
    ByteBuffer buff = ByteBuffer.allocate(BSIZE);
    fc.read(buff);
    buff.flip();
    <font color=#009900>// Doesn't work:</font>
    System.out.println(buff.asCharBuffer());
    <font color=#009900>// Decode using this system's default Charset:</font>
    buff.rewind();
    String encoding = System.getProperty(<font color=#004488>"file.encoding"</font>);
    System.out.println(<font color=#004488>"Decoded using "</font> + encoding + <font color=#004488>": "</font> 
      + Charset.forName(encoding).decode(buff));
    <font color=#009900>// Or, we could encode with something that will print:</font>
    fc = <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"data2.txt"</font>).getChannel();
    fc.write(ByteBuffer.wrap(
      <font color=#004488>"Some text"</font>.getBytes(<font color=#004488>"UTF-16BE"</font>)));
    fc.close();
    <font color=#009900>// Now try reading again:</font>
    fc = <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"data2.txt"</font>).getChannel();
    buff.clear();
    fc.read(buff);
    buff.flip();
    System.out.println(buff.asCharBuffer());
    <font color=#009900>// Use a CharBuffer to write through:</font>
    fc = <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"data2.txt"</font>).getChannel();
    buff = ByteBuffer.allocate(24); <font color=#009900>// More than needed</font>
    buff.asCharBuffer().put(<font color=#004488>"Some text"</font>);
    fc.write(buff);
    fc.close();
    <font color=#009900>// Read and display:</font>
    fc = <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"data2.txt"</font>).getChannel();
    buff.clear();
    fc.read(buff);
    buff.flip();
    System.out.println(buff.asCharBuffer());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"????"</font>,
      <font color=#004488>"%% Decoded using [A-Za-z0-9_\\-]+: Some text"</font>,
      <font color=#004488>"Some text"</font>,
      <font color=#004488>"Some text\0\0\0"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The buffer contains plain bytes, and to turn these into characters we must either <i>encode</i> them as we put them in (so that they will be meaningful when they come out) or <i>decode</i> them as they come out of the buffer. This can be accomplished using the <b>java.nio.charset.Charset</b> class, which provides tools for encoding into many different types of character sets: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0690" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:AvailableCharSets.java</font>
<font color=#009900>// Displays Charsets and aliases</font>
<font color=#0000ff>import</font> java.nio.charset.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AvailableCharSets {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Map charSets = Charset.availableCharsets();
    Iterator it = charSets.keySet().iterator();
    <font color=#0000ff>while</font>(it.hasNext()) {
      String csName = (String)it.next();
      System.out.print(csName);
      Iterator aliases = ((Charset)charSets.get(csName))
        .aliases().iterator();
      <font color=#0000ff>if</font>(aliases.hasNext())
        System.out.print(<font color=#004488>": "</font>);
      <font color=#0000ff>while</font>(aliases.hasNext()) {
        System.out.print(aliases.next());
        <font color=#0000ff>if</font>(aliases.hasNext())
          System.out.print(<font color=#004488>", "</font>);
      }
      System.out.println();
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Big5: csBig5"</font>,
      <font color=#004488>"Big5-HKSCS: big5-hkscs, Big5_HKSCS, big5hkscs"</font>,
      <font color=#004488>"EUC-CN"</font>,
      <font color=#004488>"EUC-JP: eucjis, x-eucjp, csEUCPkdFmtjapanese, "</font> +
      <font color=#004488>"eucjp, Extended_UNIX_Code_Packed_Format_for"</font> +
      <font color=#004488>"_Japanese, x-euc-jp, euc_jp"</font>,
      <font color=#004488>"euc-jp-linux: euc_jp_linux"</font>,
      <font color=#004488>"EUC-KR: ksc5601, 5601, ksc5601_1987, ksc_5601, "</font> +
      <font color=#004488>"ksc5601-1987, euc_kr, ks_c_5601-1987, "</font> +
      <font color=#004488>"euckr, csEUCKR"</font>,
      <font color=#004488>"EUC-TW: cns11643, euc_tw, euctw"</font>,
      <font color=#004488>"GB18030: gb18030-2000"</font>,
      <font color=#004488>"GBK: GBK"</font>,
      <font color=#004488>"ISCII91: iscii, ST_SEV_358-88, iso-ir-153, "</font> +
      <font color=#004488>"csISO153GOST1976874"</font>,
      <font color=#004488>"ISO-2022-CN-CNS: ISO2022CN_CNS"</font>,
      <font color=#004488>"ISO-2022-CN-GB: ISO2022CN_GB"</font>,
      <font color=#004488>"ISO-2022-KR: ISO2022KR, csISO2022KR"</font>,
      <font color=#004488>"ISO-8859-1: iso-ir-100, 8859_1, ISO_8859-1, "</font> +
      <font color=#004488>"ISO8859_1, 819, csISOLatin1, IBM-819, "</font> +
      <font color=#004488>"ISO_8859-1:1987, latin1, cp819, ISO8859-1, "</font> +
      <font color=#004488>"IBM819, ISO_8859_1, l1"</font>,
      <font color=#004488>"ISO-8859-13"</font>,
      <font color=#004488>"ISO-8859-15: 8859_15, csISOlatin9, IBM923, cp923,"</font> +
      <font color=#004488>" 923, L9, IBM-923, ISO8859-15, LATIN9, "</font> +
      <font color=#004488>"ISO_8859-15, LATIN0, csISOlatin0, "</font> +
      <font color=#004488>"ISO8859_15_FDIS, ISO-8859-15"</font>,
      <font color=#004488>"ISO-8859-2"</font>, <font color=#004488>"ISO-8859-3"</font>, <font color=#004488>"ISO-8859-4"</font>,
      <font color=#004488>"ISO-8859-5"</font>, <font color=#004488>"ISO-8859-6"</font>, <font color=#004488>"ISO-8859-7"</font>,
      <font color=#004488>"ISO-8859-8"</font>, <font color=#004488>"ISO-8859-9"</font>, 
      <font color=#004488>"JIS0201: X0201, JIS_X0201, csHalfWidthKatakana"</font>,
      <font color=#004488>"JIS0208: JIS_C6626-1983, csISO87JISX0208, x0208, "</font> +
      <font color=#004488>"JIS_X0208-1983, iso-ir-87"</font>,
      <font color=#004488>"JIS0212: jis_x0212-1990, x0212, iso-ir-159, "</font> +
      <font color=#004488>"csISO159JISC02121990"</font>,
      <font color=#004488>"Johab: ms1361, ksc5601_1992, ksc5601-1992"</font>,
      <font color=#004488>"KOI8-R"</font>,
      <font color=#004488>"Shift_JIS: shift-jis, x-sjis, ms_kanji, "</font> +
      <font color=#004488>"shift_jis, csShiftJIS, sjis, pck"</font>,
      <font color=#004488>"TIS-620"</font>,
      <font color=#004488>"US-ASCII: IBM367, ISO646-US, ANSI_X3.4-1986, "</font> +
      <font color=#004488>"cp367, ASCII, iso_646.irv:1983, 646, us, iso-ir-6,"</font>+
      <font color=#004488>" csASCII, ANSI_X3.4-1968, ISO_646.irv:1991"</font>,
      <font color=#004488>"UTF-16: UTF_16"</font>,
      <font color=#004488>"UTF-16BE: X-UTF-16BE, UTF_16BE, ISO-10646-UCS-2"</font>,
      <font color=#004488>"UTF-16LE: UTF_16LE, X-UTF-16LE"</font>,
      <font color=#004488>"UTF-8: UTF8"</font>, <font color=#004488>"windows-1250"</font>, <font color=#004488>"windows-1251"</font>,
      <font color=#004488>"windows-1252: cp1252"</font>,
      <font color=#004488>"windows-1253"</font>, <font color=#004488>"windows-1254"</font>, <font color=#004488>"windows-1255"</font>,
      <font color=#004488>"windows-1256"</font>, <font color=#004488>"windows-1257"</font>, <font color=#004488>"windows-1258"</font>,
      <font color=#004488>"windows-936: ms936, ms_936"</font>,
      <font color=#004488>"windows-949: ms_949, ms949"</font>, <font color=#004488>"windows-950: ms950"</font>,
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>So, returning to <b>BufferToText.java</b>, if you <a name="Index1420"></a><b>rewind(&#160;)</b> the buffer (to go back to the beginning of the data) and then use that platform&#146;s default character set to <a name="Index1421"></a><b>decode(&#160;)</b> the data, the resulting <b>CharBuffer</b> will print to the console just fine. To discover the default character set, use <b>System.getProperty("file.encoding")</b>, which produces the string that names the character set. Passing this to <b>Charset.forName(&#160;)</b> produces the <b>Charset</b> object that can be used to decode the string. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0691" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Another alternative is to <a name="Index1422"></a><b>encode(&#160;)</b> using a character set that will result in something printable when the file is read, as you see in the third part of <b>BufferToText.java</b>. Here, UTF-16BE is used to write the text into the file, and when it is read, all you have to do is convert it to a <b>CharBuffer</b>, and it produces the expected text. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0692" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Finally, you see what happens if you <i>write</i> to the <b>ByteBuffer</b> through a <b>CharBuffer</b> (you&#146;ll learn more about this later). Note that 24 bytes are allocated for the <b>ByteBuffer</b>. Since each <b>char</b> requires two bytes, this is enough for 12 <b>char</b>s, but &#147;Some text&#148; only has 9. The remaining zero bytes still appear in the representation of the <b>CharBuffer</b> produced by its <b>toString(&#160;)</b>, as you can see in the output. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0693" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775809"></a><a name="Heading14820"></a>Fetching primitives</h3>
<p>Although a <b>ByteBuffer</b> only holds bytes, it contains methods to produce each of the different types of primitive values from the bytes it contains. This example shows the insertion and extraction of various values using these methods: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0694" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:GetData.java</font>
<font color=#009900>// Getting different representations from a ByteBuffer</font>
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GetData {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> BSIZE = 1024;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ByteBuffer bb = ByteBuffer.allocate(BSIZE);
    <font color=#009900>// Allocation automatically zeroes the ByteBuffer:</font>
    <font color=#0000ff>int</font> i = 0;
    <font color=#0000ff>while</font>(i++ &lt; bb.limit())
      <font color=#0000ff>if</font>(bb.get() != 0)
        System.out.println(<font color=#004488>"nonzero"</font>);
    System.out.println(<font color=#004488>"i = "</font> + i);
    bb.rewind();
    <font color=#009900>// Store and read a char array:</font>
    bb.asCharBuffer().put(<font color=#004488>"Howdy!"</font>);
    <font color=#0000ff>char</font> c;
    <font color=#0000ff>while</font>((c = bb.getChar()) != 0)
      System.out.print(c + <font color=#004488>" "</font>);
    System.out.println();
    bb.rewind();
    <font color=#009900>// Store and read a short:</font>
    bb.asShortBuffer().put((<font color=#0000ff>short</font>)471142);
    System.out.println(bb.getShort());
    bb.rewind();
    <font color=#009900>// Store and read an int:</font>
    bb.asIntBuffer().put(99471142);
    System.out.println(bb.getInt());
    bb.rewind();
    <font color=#009900>// Store and read a long:</font>
    bb.asLongBuffer().put(99471142);
    System.out.println(bb.getLong());
    bb.rewind();
    <font color=#009900>// Store and read a float:</font>
    bb.asFloatBuffer().put(99471142);
    System.out.println(bb.getFloat());
    bb.rewind();
    <font color=#009900>// Store and read a double:</font>
    bb.asDoubleBuffer().put(99471142);
    System.out.println(bb.getDouble());
    bb.rewind();
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"i = 1025"</font>,
      <font color=#004488>"H o w d y ! "</font>,
      <font color=#004488>"12390"</font>, <font color=#009900>// Truncation changes the value</font>
      <font color=#004488>"99471142"</font>,
      <font color=#004488>"99471142"</font>,
      <font color=#004488>"9.9471144E7"</font>,
      <font color=#004488>"9.9471142E7"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>After a <b>ByteBuffer</b> is allocated, its values are checked to see whether buffer allocation automatically zeroes the contents&#151;and it does. All 1,024 values are checked (up to the <b>limit(&#160;)</b> of the buffer), and all are zero. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0695" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The easiest way to insert primitive values into a <b>ByteBuffer</b> is to get the appropriate &#147;view&#148; on that buffer using <b>asCharBuffer(&#160;)</b>, <b>asShortBuffer(&#160;)</b>, etc., and then to use that view&#146;s <b>put(&#160;)</b> method. You can see this is the process used for each of the primitive data types. The only one of these that is a little odd is the <b>put(&#160;)</b> for the <b>ShortBuffer</b>, which requires a cast (note that the cast truncates and changes the resulting value). All the other view buffers do not require casting in their <b>put(&#160;)</b> methods. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0696" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775810"></a><a name="Heading14880"></a>View buffers</h3>
<p>A &#147;view buffer&#148; allows you to look at an underlying <b>ByteBuffer</b> through the window of a particular primitive type. The <b>ByteBuffer</b> is still the actual storage that&#146;s &#147;backing&#148; the view, so any changes you make to the view are reflected in modifications to the data in the <b>ByteBuffer</b>. As seen in the previous example, this allows you to conveniently insert primitive types into a <b>ByteBuffer</b>. A view also allows you to read primitive values from a <b>ByteBuffer</b>, either one at a time (as <b>ByteBuffer</b> allows) or in batches (into arrays). Here&#146;s an example that manipulates <b>int</b>s in a <b>ByteBuffer</b> via an <b>IntBuffer</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0697" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:IntBufferDemo.java</font>
<font color=#009900>// Manipulating ints in a ByteBuffer with an IntBuffer</font>
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IntBufferDemo {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> BSIZE = 1024;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ByteBuffer bb = ByteBuffer.allocate(BSIZE);
    IntBuffer ib = bb.asIntBuffer();
    <font color=#009900>// Store an array of int:</font>
    ib.put(<font color=#0000ff>new</font> <font color=#0000ff>int</font>[] { 11, 42, 47, 99, 143, 811, 1016 });
    <font color=#009900>// Absolute location read and write:</font>
    System.out.println(ib.get(3));
    ib.put(3, 1811);
    ib.rewind();
    <font color=#0000ff>while</font>(ib.hasRemaining()) {
      <font color=#0000ff>int</font> i = ib.get();
      <font color=#0000ff>if</font>(i == 0) <font color=#0000ff>break</font>; <font color=#009900>// Else we'll get the entire buffer</font>
      System.out.println(i);
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"99"</font>,
      <font color=#004488>"11"</font>,
      <font color=#004488>"42"</font>,
      <font color=#004488>"47"</font>,
      <font color=#004488>"1811"</font>,
      <font color=#004488>"143"</font>,
      <font color=#004488>"811"</font>,
      <font color=#004488>"1016"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The overloaded <b>put(&#160;)</b> method is first used to store an array of <b>int</b>. The following <b>get(&#160;)</b> and <b>put(&#160;) </b>method calls directly access an <b>int</b> location in the underlying <b>ByteBuffer</b>. Note that these absolute location accesses are available for primitive types by talking directly to a <b>ByteBuffer</b>, as well. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0698" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once the underlying <b>ByteBuffer</b> is filled with <b>int</b>s or some other primitive type via a view buffer, then that <b>ByteBuffer</b> can be written directly to a channel. You can just as easily read from a channel and use a view buffer to convert everything to a particular type of primitive. Here&#146;s an example that interprets the same sequence of bytes as <b>short</b>, <b>int</b>, <b>float</b>, <b>long</b>, and <b>double</b> by producing different view buffers on the same <b>ByteBuffer</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0699" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:ViewBuffers.java</font>
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ViewBuffers {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ByteBuffer bb = ByteBuffer.wrap(
      <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[]{ 0, 0, 0, 0, 0, 0, 0, 'a' });
    bb.rewind();
    System.out.println(<font color=#004488>"Byte Buffer"</font>);
    <font color=#0000ff>while</font>(bb.hasRemaining())
      System.out.println(bb.position()+ <font color=#004488>" -&gt; "</font> + bb.get());
    CharBuffer cb =
      ((ByteBuffer)bb.rewind()).asCharBuffer();
    System.out.println(<font color=#004488>"Char Buffer"</font>);
    <font color=#0000ff>while</font>(cb.hasRemaining())
      System.out.println(cb.position()+ <font color=#004488>" -&gt; "</font> + cb.get());
    FloatBuffer fb =
      ((ByteBuffer)bb.rewind()).asFloatBuffer();
    System.out.println(<font color=#004488>"Float Buffer"</font>);
    <font color=#0000ff>while</font>(fb.hasRemaining())
      System.out.println(fb.position()+ <font color=#004488>" -&gt; "</font> + fb.get());
    IntBuffer ib =
      ((ByteBuffer)bb.rewind()).asIntBuffer();
    System.out.println(<font color=#004488>"Int Buffer"</font>);
    <font color=#0000ff>while</font>(ib.hasRemaining())
      System.out.println(ib.position()+ <font color=#004488>" -&gt; "</font> + ib.get());
    LongBuffer lb =
      ((ByteBuffer)bb.rewind()).asLongBuffer();
    System.out.println(<font color=#004488>"Long Buffer"</font>);
    <font color=#0000ff>while</font>(lb.hasRemaining())
      System.out.println(lb.position()+ <font color=#004488>" -&gt; "</font> + lb.get());
    ShortBuffer sb =
      ((ByteBuffer)bb.rewind()).asShortBuffer();
    System.out.println(<font color=#004488>"Short Buffer"</font>);
    <font color=#0000ff>while</font>(sb.hasRemaining())
      System.out.println(sb.position()+ <font color=#004488>" -&gt; "</font> + sb.get());
    DoubleBuffer db =
      ((ByteBuffer)bb.rewind()).asDoubleBuffer();
    System.out.println(<font color=#004488>"Double Buffer"</font>);
    <font color=#0000ff>while</font>(db.hasRemaining())
      System.out.println(db.position()+ <font color=#004488>" -&gt; "</font> + db.get());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Byte Buffer"</font>,
      <font color=#004488>"0 -&gt; 0"</font>,
      <font color=#004488>"1 -&gt; 0"</font>,
      <font color=#004488>"2 -&gt; 0"</font>,
      <font color=#004488>"3 -&gt; 0"</font>,
      <font color=#004488>"4 -&gt; 0"</font>,
      <font color=#004488>"5 -&gt; 0"</font>,
      <font color=#004488>"6 -&gt; 0"</font>,
      <font color=#004488>"7 -&gt; 97"</font>,
      <font color=#004488>"Char Buffer"</font>,
      <font color=#004488>"0 -&gt; \0"</font>,
      <font color=#004488>"1 -&gt; \0"</font>,
      <font color=#004488>"2 -&gt; \0"</font>,
      <font color=#004488>"3 -&gt; a"</font>,
      <font color=#004488>"Float Buffer"</font>,
      <font color=#004488>"0 -&gt; 0.0"</font>,
      <font color=#004488>"1 -&gt; 1.36E-43"</font>,
      <font color=#004488>"Int Buffer"</font>,
      <font color=#004488>"0 -&gt; 0"</font>,
      <font color=#004488>"1 -&gt; 97"</font>,
      <font color=#004488>"Long Buffer"</font>,
      <font color=#004488>"0 -&gt; 97"</font>,
      <font color=#004488>"Short Buffer"</font>,
      <font color=#004488>"0 -&gt; 0"</font>,
      <font color=#004488>"1 -&gt; 0"</font>,
      <font color=#004488>"2 -&gt; 0"</font>,
      <font color=#004488>"3 -&gt; 97"</font>,
      <font color=#004488>"Double Buffer"</font>,
      <font color=#004488>"0 -&gt; 4.8E-322"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>ByteBuffer</b> is produced by &#147;wrapping&#148; an eight-byte array, which is then displayed via view buffers of all the different primitive types. You can see in the following diagram the way the data appears differently when read from the different types of buffers: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0700" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><img src="TIJ327.png" 	alt="TIJ327.png" border="0" ><br></p>
<p>This corresponds to the output from the program.<br></p>
<h4>
<a name="Heading15000"></a>Endians</h4>
<p>Different machines may use different byte-ordering approaches to store data. &#147;Big endian&#148; places the most significant byte in the lowest memory address, and &#147;little endian&#148; places the most significant byte in the highest memory address. When storing a quantity that is greater than one byte, like <a name="Index1423"></a><a name="Index1424"></a><a name="Index1425"></a><b>int</b>,<b> float</b>, etc.,<b> </b>you may need to consider the byte ordering. A <b>ByteBuffer </b>stores data in big endian form, and data sent over a network always uses big endian order. You can change the endian-ness of a <b>ByteBuffer</b> using <b>order(&#160;) </b>with an argument of <b>ByteOrder.BIG_ENDIAN</b> or <b>ByteOrder.LITTLE_ENDIAN</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0701" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Consider a <b>ByteBuffer</b> containing the following two bytes:<br></p>
<p><img src="TIJ328.png" 	alt="TIJ328.png" border="0" ><br></p>
<p>If you read the data as a <b>short</b> (<b>ByteBuffer.asShortBuffer(&#160;)</b>), you will get the number 97 (00000000  01100001), but if you change to little endian, you will get the number 24832 (01100001 00000000). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0702" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example that shows how byte ordering is changed in characters depending on the endian setting:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Endians.java</font>
<font color=#009900>// Endian differences and data storage.</font>
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Endians {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ByteBuffer bb = ByteBuffer.wrap(<font color=#0000ff>new</font> <font color=#0000ff>byte</font>[12]);
    bb.asCharBuffer().put(<font color=#004488>"abcdef"</font>);
    System.out.println(Arrays2.toString(bb.array()));
    bb.rewind();
    bb.order(ByteOrder.BIG_ENDIAN);
    bb.asCharBuffer().put(<font color=#004488>"abcdef"</font>);
    System.out.println(Arrays2.toString(bb.array()));
    bb.rewind();
    bb.order(ByteOrder.LITTLE_ENDIAN);
    bb.asCharBuffer().put(<font color=#004488>"abcdef"</font>);
    System.out.println(Arrays2.toString(bb.array()));
    monitor.expect(<font color=#0000ff>new</font> String[]{
      <font color=#004488>"[0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102]"</font>,
      <font color=#004488>"[0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102]"</font>,
      <font color=#004488>"[97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102, 0]"</font>
    });
  } 
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>ByteBuffer</b> is given enough space to hold all the bytes in <b>charArray</b> as an external buffer so that that <b>array(&#160;)</b> method can be called to display the underlying bytes. The <b>array(&#160;)</b> method is &#147;optional,&#148; and you can only call it on a buffer that is backed by an array; otherwise, you&#146;ll get an <b>UnsupportedOperationException</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0703" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>charArray</b> is inserted into the <b>ByteBuffer</b> via a <b>CharBuffer</b> view. When the underlying bytes are displayed, you can see that the default ordering is the same as the subsequent big endian order, whereas the little endian order swaps the bytes. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0704" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775811"></a><a name="Heading15036"></a>Data manipulation with
buffers</h3>
<p>The diagram here illustrates the relationships between the <b>nio</b> classes, so that you can see how to move and convert data. For example, if you wish to write a <b>byte</b> array to a file, then you wrap the byte array using the <b>ByteBuffer.wrap(&#160;)</b> method, open a channel on the <b>FileOutputStream</b> using the <b>getChannel(&#160;) </b>method, and then write data into <b>FileChannel </b>from this<b> ByteBuffer</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0705" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><img src="TIJ329.png" 	alt="TIJ329.png" border="0" ><br></p>
<p>Note that <b>ByteBuffer</b> is the only way to move data in and out of channels, and that you can only create a standalone primitive-typed buffer, or get one from a <b>ByteBuffer</b> using an &#147;as&#148; method. That is, you cannot convert a primitive-typed buffer <i>to</i> a <b>ByteBuffer</b>. However, since you are able to move primitive data into and out of a <b>ByteBuffer</b> via a view buffer, this is not really a restriction. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0706" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775812"></a><a name="Heading15040"></a>Buffer details</h3>
<p>A <b>Buffer</b> consists of data and four indexes to access and manipulate this data efficiently: <i>mark</i>, <i>position</i>, <i>limit</i> and <i>capacity</i>. There are methods to set and reset these indexes and to query their value. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0707" title="Send BackTalk Comment">Feedback</a></font><br></p>
<div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>capacity(&#160;)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Returns the buffer&#146;s <i>capacity</i><br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>clear(&#160;)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Clears the buffer, sets the <i>position</i> to zero, and <i>limit</i> to <i>capacity. </i>You call this method to overwrite an existing buffer.<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>flip(&#160;)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Sets <i>limit</i> to <i>position</i> and <i>position</i> to zero. This method is used to prepare the buffer for a read after data has been written into it.<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>limit(&#160;)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Returns the value of <i>limit</i>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>limit(int lim)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Sets the value of <i>limit</i>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>mark(&#160;)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Sets <i>mark</i> at <i>position</i>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>position(&#160;)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Returns the value of <i>position</i>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>position(int pos)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Sets the value of <i>position</i>.<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>remaining(&#160;)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Returns (<i>limit</i> - <i>position</i>).<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p><b>hasRemaining(&#160;)</b><br></p>
</td>
<td width="342.666581" colspan="1" rowspan="1" valign="top">
<p>Returns <b>true</b> if there are any elements between <i>position</i> and <i>limit</i>.<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">Methods that insert and extract data from the buffer update these indexes to reflect the changes.<br></p>
<p>This example uses a very simple algorithm (swapping adjacent characters) to scramble and unscramble characters in a <b>CharBuffer</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0708" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:UsingBuffers.java</font>
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> UsingBuffers {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> symmetricScramble(CharBuffer buffer){
    <font color=#0000ff>while</font>(buffer.hasRemaining()) {
      buffer.mark();
      <font color=#0000ff>char</font> c1 = buffer.get();
      <font color=#0000ff>char</font> c2 = buffer.get();
      buffer.reset();
      buffer.put(c2).put(c1);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>char</font>[] data = <font color=#004488>"UsingBuffers"</font>.toCharArray();
    ByteBuffer bb = ByteBuffer.allocate(data.length * 2);
    CharBuffer cb = bb.asCharBuffer();
    cb.put(data);
    System.out.println(cb.rewind());
    symmetricScramble(cb);
    System.out.println(cb.rewind());
    symmetricScramble(cb);
    System.out.println(cb.rewind());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"UsingBuffers"</font>,
      <font color=#004488>"sUniBgfuefsr"</font>,
      <font color=#004488>"UsingBuffers"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Although you could produce a <b>CharBuffer </b>directly by calling <b>wrap(&#160;) </b>with a <b>char </b>array, an underlying <b>ByteBuffer </b>is allocated instead, and a <b>CharBuffer </b>is produced as a view on the <b>ByteBuffer</b>. This emphasizes that fact that the goal is always to manipulate a <b>ByteBuffer</b>, since that is what interacts with a channel. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0709" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s what the buffer looks like after the <b>put(&#160;)</b>:<br></p>
<p><img src="TIJ330.png" 	alt="TIJ330.png" border="0" ><br></p>
<p>The <i>position</i> points to the first element in the buffer, and the <i>capacity</i> and <i>limit</i> point to the last element. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0710" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In <b>symmetricScramble(&#160;)</b>, the while loop iterates until <i>position</i> is equivalent to <i>limit</i>. The <i>position</i> of the buffer changes when a relative <b>get(&#160;)</b> or <b>put(&#160;)</b> function is called on it. You can also call absolute <b>get(&#160;)</b> and <b>put(&#160;)</b> methods that include an index argument, which is the location where the <b>get(&#160;) </b>or <b>put(&#160;)</b> takes place. These methods do not modify the value of the buffer&#146;s <i>position</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0711" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When the control enters the while loop, the value of <i>mark </i>is set using <b>mark(&#160;) </b>call. The state of the buffer then: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0712" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><img src="TIJ331.png" 	alt="TIJ331.png" border="0" ><br></p>
<p>The two relative <b>get(&#160;)</b> calls save the value of the first two characters in variables <b>c1</b> and <b>c2</b>. After these two calls, the buffer looks like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0713" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><img src="TIJ332.png" 	alt="TIJ332.png" border="0" ><br></p>
<p>To perform the swap, we need to write <b>c2</b> at <i>position</i> = 0 and <b>c1</b> at <i>position</i> = 1. We can either use the absolute put method to achieve this, or set the value of <i>position</i> to <i>mark</i>, which is what <b>reset(&#160;)</b> does: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0714" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><img src="TIJ333.png" 	alt="TIJ333.png" border="0" ><br></p>
<p>The two <b>put(&#160;)</b> methods write <b>c2</b> and then <b>c1</b>:<br></p>
<p><img src="TIJ334.png" 	alt="TIJ334.png" border="0" ><br></p>
<p>During the next iteration of the loop, <i>mark</i> is set to the current value of <i>position</i>:<br></p>
<p><img src="TIJ335.png" 	alt="TIJ335.png" border="0" ><br></p>
<p>The process continues until the entire buffer is traversed. At the end of the <b>while</b> loop, <i>position </i>is at the end of the buffer. If you print the buffer, only the characters between the <i>position</i> and <i>limit</i> are printed. Thus, if you want to show the entire contents of the buffer you must set <i>position</i> to the start of the buffer using <b>rewind(&#160;)</b>. Here is the state of buffer after the <b>rewind(&#160;)</b> call (the value of <i>mark</i> becomes undefined): <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0715" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><img src="TIJ336.png" 	alt="TIJ336.png" border="0" ><br></p>
<p>When the function <b>symmetricScramble(&#160;)</b> is called again, the <b>CharBuffer </b>undergoes the same process and is restored to its original state. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0716" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775813"></a><a name="Heading15115"></a>Memory-mapped
files<br></h3>
<p><a name="Index1426"></a><a name="Index1427"></a>Memory-mapped files allow you to create and modify files that are too big to bring into memory. With a memory-mapped file, you can pretend that the entire file is in memory and that you can access it by simply treating it as a very large array. This approach greatly simplifies the code you write in order to modify the file. Here&#146;s a small example: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0717" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:LargeMappedFiles.java</font>
<font color=#009900>// Creating a very large file using mapping.</font>
<font color=#009900>// {RunByHand}</font>
<font color=#009900>// {Clean: test.dat}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> java.nio.channels.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LargeMappedFiles {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> length = 0x8FFFFFF; <font color=#009900>// 128 Mb</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    MappedByteBuffer out = 
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"test.dat"</font>, <font color=#004488>"rw"</font>).getChannel()
      .map(FileChannel.MapMode.READ_WRITE, 0, length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; length; i++)
      out.put((<font color=#0000ff>byte</font>)'x');
    System.out.println(<font color=#004488>"Finished writing"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = length/2; i &lt; length/2 + 6; i++)
      System.out.print((<font color=#0000ff>char</font>)out.get(i));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>To do both writing and reading, we start with a <b>RandomAccessFile</b>, get a channel for that file, and then call <b>map(&#160;)</b> to produce a <b>MappedByteBuffer</b>, which is a particular kind of direct buffer. Note that you must specify the starting point and the length of the region that you want to map in the file; this means that you have the option to map smaller regions of a large file. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0718" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1428"></a><b>MappedByteBuffer</b> is inherited from <b>ByteBuffer</b>, so it has all of <b>ByteBuffer</b>&#146;s methods. Only the very simple uses of <b>put(&#160;) </b>and <b>get(&#160;)</b> are shown here, but you can also use things like <b>asCharBuffer(&#160;)</b>, etc. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0719" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The file created with the preceding program is 128 MB long, which is probably larger than the space your OS will allow. The file appears to be accessible all at once because only portions of it are brought into memory, and other parts are swapped out. This way a very large file (up to 2 GB) can easily be modified. Note that the file-mapping facilities of the underlying operating system are used to maximize performance. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0720" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading15142"></a>Performance</h4>
<p>Although the performance of &#147;old&#148; stream I/O has been improved by implementing it with <b>nio</b>, mapped file access tends to be dramatically faster. This program does a simple performance comparison:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:MappedIO.java</font>
<font color=#009900>// {Clean: temp.tmp}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> java.nio.channels.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MappedIO {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> numOfInts = 4000000;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> numOfUbuffInts = 200000;
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    <font color=#0000ff>private</font> String name;
    <font color=#0000ff>public</font> Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>public</font> <font color=#0000ff>long</font> runTest() {
      System.out.print(name + <font color=#004488>": "</font>);
      <font color=#0000ff>try</font> {
        <font color=#0000ff>long</font> startTime = System.currentTimeMillis();
        test();
        <font color=#0000ff>long</font> endTime = System.currentTimeMillis();
        <font color=#0000ff>return</font> (endTime - startTime);
      } <font color=#0000ff>catch</font> (IOException e) {
        <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
      }
    }
    <font color=#0000ff>public</font> <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test() <font color=#0000ff>throws</font> IOException;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = { 
    <font color=#0000ff>new</font> Tester(<font color=#004488>"Stream Write"</font>) {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() <font color=#0000ff>throws</font> IOException {
        DataOutputStream dos = <font color=#0000ff>new</font> DataOutputStream(
          <font color=#0000ff>new</font> BufferedOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(<font color=#0000ff>new</font> File(<font color=#004488>"temp.tmp"</font>))));
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; numOfInts; i++)
          dos.writeInt(i);
        dos.close();
      }
    }, 
    <font color=#0000ff>new</font> Tester(<font color=#004488>"Mapped Write"</font>) {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() <font color=#0000ff>throws</font> IOException {
        FileChannel fc = 
          <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"temp.tmp"</font>, <font color=#004488>"rw"</font>)
          .getChannel();
        IntBuffer ib = fc.map(
          FileChannel.MapMode.READ_WRITE, 0, fc.size())
          .asIntBuffer();
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; numOfInts; i++)
          ib.put(i);
        fc.close();
      }
    }, 
    <font color=#0000ff>new</font> Tester(<font color=#004488>"Stream Read"</font>) {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() <font color=#0000ff>throws</font> IOException {
        DataInputStream dis = <font color=#0000ff>new</font> DataInputStream(
          <font color=#0000ff>new</font> BufferedInputStream(
            <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"temp.tmp"</font>)));
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; numOfInts; i++)
          dis.readInt();
        dis.close();
      }
    }, 
    <font color=#0000ff>new</font> Tester(<font color=#004488>"Mapped Read"</font>) {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() <font color=#0000ff>throws</font> IOException {
        FileChannel fc = <font color=#0000ff>new</font> FileInputStream(
          <font color=#0000ff>new</font> File(<font color=#004488>"temp.tmp"</font>)).getChannel();
        IntBuffer ib = fc.map(
          FileChannel.MapMode.READ_ONLY, 0, fc.size())
          .asIntBuffer();
        <font color=#0000ff>while</font>(ib.hasRemaining())
          ib.get();
        fc.close();
      }
    }, 
    <font color=#0000ff>new</font> Tester(<font color=#004488>"Stream Read</font><font color=#004488>/Write"</font>) {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() <font color=#0000ff>throws</font> IOException {
        RandomAccessFile raf = <font color=#0000ff>new</font> RandomAccessFile(
          <font color=#0000ff>new</font> File(<font color=#004488>"temp.tmp"</font>), <font color=#004488>"rw"</font>);
        raf.writeInt(1);
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; numOfUbuffInts; i++) {
          raf.seek(raf.length() - 4);
          raf.writeInt(raf.readInt());
        }
        raf.close();
      }
    }, 
    <font color=#0000ff>new</font> Tester(<font color=#004488>"Mapped Read</font><font color=#004488>/Write"</font>) {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> test() <font color=#0000ff>throws</font> IOException {
        FileChannel fc = <font color=#0000ff>new</font> RandomAccessFile(
          <font color=#0000ff>new</font> File(<font color=#004488>"temp.tmp"</font>), <font color=#004488>"rw"</font>).getChannel();
        IntBuffer ib = fc.map(
          FileChannel.MapMode.READ_WRITE, 0, fc.size())
          .asIntBuffer();
        ib.put(0);
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 1; i &lt; numOfUbuffInts; i++)
          ib.put(ib.get(i - 1));
        fc.close();
      }
    }
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++)
      System.out.println(tests[i].runTest());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>As seen in earlier examples in this book, <b>runTest(&#160;)</b> is the <a name="Index1429"></a><a name="Index1430"></a><i>Template Method</i> that provides the testing framework for various implementations of <b>test(&#160;)</b> defined in anonymous inner subclasses. Each of these subclasses perform one kind of test, so the <b>test(&#160;)</b> methods also give you a prototype for performing the various I/O activities. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0721" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Although a mapped write would seem to use a <b>FileOutputStream</b>, all output in file mapping must use a <b>RandomAccessFile</b>, just as read/write does in the preceding code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0722" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s the output from one run:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Stream Write: 1719
Mapped Write: 359
Stream Read: 750
Mapped Read: 125
Stream Read/Write: 5188
Mapped Read/Write: 16</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Note that the <b>test(&#160;)</b> methods include the time for initialization of the various I/O objects, so even though the setup for mapped files can be expensive, the overall gain compared to stream I/O is significant. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0723" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775814"></a><a name="Heading15258"></a>File locking<br></h3>
<p><a name="Index1431"></a><a name="Index1432"></a>File locking, introduced in JDK 1.4, allows you to synchronize access to a file as a shared resource. However, the two threads that contend for the same file may be in different JVMs, or one may be a Java thread and the other some native thread in the operating system. The file locks are visible to other operating system processes because Java file locking maps directly to the native operating system locking facility. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0724" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here is a simple example of file locking.<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:FileLocking.java</font>
<font color=#009900>// {Clean: file.txt}</font>
<font color=#0000ff>import</font> java.io.FileOutputStream;
<font color=#0000ff>import</font> java.nio.channels.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FileLocking {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    FileOutputStream fos= <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"file.txt"</font>);
    FileLock fl = fos.getChannel().tryLock();
    <font color=#0000ff>if</font>(fl != <font color=#0000ff>null</font>) {
      System.out.println(<font color=#004488>"Locked File"</font>);
      Thread.sleep(100);
      fl.release();
      System.out.println(<font color=#004488>"Released Lock"</font>);
    }
    fos.close();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You get a <a name="Index1433"></a><b>FileLock</b> on the entire file by calling either <a name="Index1434"></a><b>tryLock(&#160;)</b> or <a name="Index1435"></a><b>lock(&#160;)</b> on a <b>FileChannel</b>. (<a name="Index1436"></a><b>SocketChannel</b>, <a name="Index1437"></a><b>DatagramChannel</b>, and <a name="Index1438"></a><b>ServerSocketChannel</b> do not need locking since they are inherently single-process entities; you don&#146;t generally share a network socket between two processes.) <b>tryLock(&#160;) </b>is non-blocking. It tries to grab the lock, but if it cannot (when some other process already holds the same lock and it is not shared), it simply returns from the method call. <b>lock(&#160;)</b> blocks until the lock is acquired, or the thread that invoked <b>lock(&#160;) </b>is interrupted, or the channel on which the <b>lock(&#160;)</b> method is called is closed. A lock is released using <b>FileLock.release(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0725" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It is also possible to lock a part of the file by using <br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>tryLock(<font color=#0000ff>long</font> position, <font color=#0000ff>long</font> size, <font color=#0000ff>boolean</font> shared)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>or<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>lock(<font color=#0000ff>long</font> position, <font color=#0000ff>long</font> size, <font color=#0000ff>boolean</font> shared)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>which locks the region <b>(size - position)</b>. The third argument specifies whether this lock is shared. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0726" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Although the zero-argument locking methods adapt to changes in the size of a file, locks with a fixed size do not change if the file size changes. If a lock is acquired for a region from <b>position</b> to <b>position+size</b> and the file increases beyond <b>position+size</b>, then the section beyond <b>position+size</b> is not locked. The zero-argument locking methods lock the entire file, even if it grows. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0727" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Support for exclusive or shared locks must be provided by the underlying operating system. If the operating system does not support shared locks and a request is made for one, an exclusive lock is used instead. The type of lock (shared or exclusive) can be queried using <b>FileLock</b>.<b>isShared(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0728" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading15290"></a>Locking portions of a mapped file</h4>
<p>As mentioned earlier, file mapping is typically used for very large files. One thing that you may need to do with such a large file is to lock portions of it so that other processes may modify unlocked parts of the file. This is something that happens, for example, with a database, so that it can be available to many users at once. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0729" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example that has two threads, each of which locks a distinct portion of a file:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:LockingMappedFiles.java</font>
<font color=#009900>// Locking portions of a mapped file.</font>
<font color=#009900>// {RunByHand}</font>
<font color=#009900>// {Clean: test.dat}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.nio.*;
<font color=#0000ff>import</font> java.nio.channels.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LockingMappedFiles {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> LENGTH = 0x8FFFFFF; <font color=#009900>// 128 Mb</font>
  <font color=#0000ff>static</font> FileChannel fc;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    fc = 
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"test.dat"</font>, <font color=#004488>"rw"</font>).getChannel();
    MappedByteBuffer out = 
      fc.map(FileChannel.MapMode.READ_WRITE, 0, LENGTH);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; LENGTH; i++)
      out.put((<font color=#0000ff>byte</font>)'x');
    <font color=#0000ff>new</font> LockAndModify(out, 0, 0 + LENGTH/3);
    <font color=#0000ff>new</font> LockAndModify(out, LENGTH/2, LENGTH/2 + LENGTH/4);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> LockAndModify <font color=#0000ff>extends</font> Thread {
    <font color=#0000ff>private</font> ByteBuffer buff;
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> start, end;
    LockAndModify(ByteBuffer mbb, <font color=#0000ff>int</font> start, <font color=#0000ff>int</font> end) {
      <font color=#0000ff>this</font>.start = start;
      <font color=#0000ff>this</font>.end = end;
      mbb.limit(end);
      mbb.position(start);
      buff = mbb.slice();
      start();
    }    
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
      <font color=#0000ff>try</font> {
        <font color=#009900>// Exclusive lock with no overlap:</font>
        FileLock fl = fc.lock(start, end, <font color=#0000ff>false</font>);
        System.out.println(<font color=#004488>"Locked: "</font>+ start +<font color=#004488>" to "</font>+ end);
        <font color=#009900>// Perform modification:</font>
        <font color=#0000ff>while</font>(buff.position() &lt; buff.limit() - 1)
          buff.put((<font color=#0000ff>byte</font>)(buff.get() + 1));
        fl.release();
        System.out.println(<font color=#004488>"Released: "</font>+start+<font color=#004488>" to "</font>+ end);
      } <font color=#0000ff>catch</font>(IOException e) {
        <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
      }
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>LockAndModify</b> thread class sets up the buffer region and creates a <b>slice(&#160;)</b> to be modified, and in <b>run(&#160;)</b>, the lock is acquired on the file channel (you can&#146;t acquire a lock on the buffer&#151;only the channel). The call to <b>lock(&#160;)</b> is very similar to acquiring a threading lock on an object&#151;you now have a &#147;critical section&#148; with exclusive access to that portion of the file. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0730" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The locks are automatically released when the JVM exits, or the channel on which it was acquired is closed, but you can also explicitly call <b>release(&#160;)</b> on the <b>FileLock</b> object, as shown here. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0731" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775815"></a><a name="Heading15344"></a>Compression<br></h2>
<p><a name="Index1439"></a><a name="Index1440"></a>The Java I/O library contains classes to support reading and writing streams in a compressed format. These are wrapped around existing I/O classes to provide compression functionality. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1699" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>These classes are not derived from the <b>Reader</b> and <b>Writer</b> classes, but instead are part of the <b>InputStream</b> and <b>OutputStream</b> hierarchies. This is because the compression library works with bytes, not characters. However, you might sometimes be forced to mix the two types of streams. (Remember that you can use <b>InputStreamReader</b> and <b>OutputStreamWriter</b> to provide easy conversion between one type and another.) <br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<th width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><a name="Index1441"></a><a name="Index1442"></a><a name="Index1443"></a><a name="Index1444"></a><a name="Index1445"></a><a name="Index1446"></a><a name="Index1447"></a><a name="Index1448"></a><a name="Index1449"></a><a name="Index1450"></a><a name="Index1451"></a><a name="Index1452"></a><a name="Index1453"></a><a name="Index1454"></a><a name="Index1455"></a><a name="Index1456"></a><b>Compression class</b><br></p>
</th>
<th width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>Function</b><br></p>
</th>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>CheckedInputStream</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>GetCheckSum(&#160;)</b> produces checksum for any <b>InputStream</b> (not just decompression).<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>CheckedOutputStream</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>GetCheckSum(&#160;)</b> produces checksum for any <b>OutputStream</b> (not just compression).<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>DeflaterOutputStream</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Base class for compression classes.<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>ZipOutputStream</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">A <b>DeflaterOutputStream</b> that compresses data into the Zip file format.<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>GZIPOutputStream</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">A <b>DeflaterOutputStream</b> that compresses data into the GZIP file format.<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>InflaterInputStream</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">Base class for decompression classes.<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>ZipInputStream</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">An <b>InflaterInputStream</b> that decompresses data that has been stored in the Zip file format.<br></p>
</td>
</tr>
<tr valign="top">
<td width="197.333284" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>GZIPInputStream</b><br></p>
</td>
<td width="281.333263" colspan="1" rowspan="1" valign="top">
<p class="Table">An <b>InflaterInputStream</b> that decompresses data that has been stored in the GZIP file format.<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">Although there are many compression algorithms, Zip and GZIP are possibly the most commonly used. Thus you can easily manipulate your compressed data with the many tools available for reading and writing these formats.<br></p>
<h3>
<a name="_Toc24775816"></a><a name="Heading15366"></a>Simple compression with
GZIP</h3>
<p>The GZIP interface is simple and thus is probably more appropriate when you have a single stream of data that you want to compress (rather than a container of dissimilar pieces of data). Here&#146;s an example that compresses a single file:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:GZIPcompress.java</font>
<font color=#009900>// {Args: GZIPcompress.java}</font>
<font color=#009900>// {Clean: test.gz}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GZIPcompress {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>if</font>(args.length == 0) {
      System.out.println(
        <font color=#004488>"Usage: \nGZIPcompress file\n"</font> +
        <font color=#004488>"\tUses GZIP compression to compress "</font> +
        <font color=#004488>"the file to test.gz"</font>);
      System.exit(1);
    }
    BufferedReader in = <font color=#0000ff>new</font> BufferedReader(
      <font color=#0000ff>new</font> FileReader(args[0]));
    BufferedOutputStream out = <font color=#0000ff>new</font> BufferedOutputStream(
      <font color=#0000ff>new</font> GZIPOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.gz"</font>)));
    System.out.println(<font color=#004488>"Writing file"</font>);
    <font color=#0000ff>int</font> c;
    <font color=#0000ff>while</font>((c = in.read()) != -1)
      out.write(c);
    in.close();
    out.close();
    System.out.println(<font color=#004488>"Reading file"</font>);
    BufferedReader in2 = <font color=#0000ff>new</font> BufferedReader(
      <font color=#0000ff>new</font> InputStreamReader(<font color=#0000ff>new</font> GZIPInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.gz"</font>))));
    String s;
    <font color=#0000ff>while</font>((s = in2.readLine()) != <font color=#0000ff>null</font>)
      System.out.println(s);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Writing file"</font>,
      <font color=#004488>"Reading file"</font>
    }, args[0]);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The use of the compression classes is straightforward; you simply wrap your output stream in a <b>GZIPOutputStream</b> or <b>ZipOutputStream</b>, and your input stream in a <b>GZIPInputStream</b> or <b>ZipInputStream</b>. All else is ordinary I/O reading and writing. This is an example of mixing the <b>char</b>-oriented streams with the <b>byte</b>-oriented streams; <b>in</b> uses the <b>Reader</b> classes, whereas <b>GZIPOutputStream</b>&#146;s constructor can accept only an <b>OutputStream</b> object, not a <b>Writer</b> object. When the file is opened, the <b>GZIPInputStream</b> is converted to a <b>Reader</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1700" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775817"></a><a name="Heading15413"></a>Multifile storage with
Zip</h3>
<p>The library that supports the Zip format is much more extensive. With it you can easily store multiple files, and there&#146;s even a separate class to make the process of reading a Zip file easy. The library uses the standard Zip format so that it works seamlessly with all the tools currently downloadable on the Internet. The following example has the same form as the previous example, but it handles as many command-line arguments as you want. In addition, it shows the use of the <a name="Index1457"></a><b>Checksum</b> classes to calculate and verify the checksum for the file. There are two <b>Checksum</b> types: <a name="Index1458"></a><b>Adler32</b> (which is faster) and <a name="Index1459"></a><b>CRC32</b> (which is slower but slightly more accurate). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1701" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:ZipCompress.java</font>
<font color=#009900>// Uses Zip compression to compress any</font>
<font color=#009900>// number of files given on the command line.</font>
<font color=#009900>// {Args: ZipCompress.java}</font>
<font color=#009900>// {Clean: test.zip}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ZipCompress {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException {
    FileOutputStream f = <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.zip"</font>);
    CheckedOutputStream csum =
      <font color=#0000ff>new</font> CheckedOutputStream(f, <font color=#0000ff>new</font> Adler32());
     ZipOutputStream zos = <font color=#0000ff>new</font> ZipOutputStream(csum);
     BufferedOutputStream out =
      <font color=#0000ff>new</font> BufferedOutputStream(zos);
    zos.setComment(<font color=#004488>"A test of Java Zipping"</font>);
    <font color=#009900>// No corresponding getComment(), though.</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; args.length; i++) {
      System.out.println(<font color=#004488>"Writing file "</font> + args[i]);
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(<font color=#0000ff>new</font> FileReader(args[i]));
      zos.putNextEntry(<font color=#0000ff>new</font> ZipEntry(args[i]));
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in.read()) != -1)
        out.write(c);
      in.close();
    }
    out.close();
    <font color=#009900>// Checksum valid only after the file has been closed!</font>
    System.out.println(<font color=#004488>"Checksum: "</font> +
      csum.getChecksum().getValue());
    <font color=#009900>// Now extract the files:</font>
    System.out.println(<font color=#004488>"Reading file"</font>);
    FileInputStream fi = <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.zip"</font>);
    CheckedInputStream csumi =
      <font color=#0000ff>new</font> CheckedInputStream(fi, <font color=#0000ff>new</font> Adler32());
    ZipInputStream in2 = <font color=#0000ff>new</font> ZipInputStream(csumi);
    BufferedInputStream bis = <font color=#0000ff>new</font> BufferedInputStream(in2);
    ZipEntry ze;
    <font color=#0000ff>while</font>((ze = in2.getNextEntry()) != <font color=#0000ff>null</font>) {
      System.out.println(<font color=#004488>"Reading file "</font> + ze);
      <font color=#0000ff>int</font> x;
      <font color=#0000ff>while</font>((x = bis.read()) != -1)
        System.out.write(x);
    }
    <font color=#0000ff>if</font>(args.length == 1)
      monitor.expect(<font color=#0000ff>new</font> String[] {
        <font color=#004488>"Writing file "</font> + args[0],
        <font color=#004488>"%% Checksum: \\d+"</font>,
        <font color=#004488>"Reading file"</font>,
        <font color=#004488>"Reading file "</font> + args[0]}, args[0]);
    System.out.println(<font color=#004488>"Checksum: "</font> +
      csumi.getChecksum().getValue());
    bis.close();
    <font color=#009900>// Alternative way to open and read zip files:</font>
    ZipFile zf = <font color=#0000ff>new</font> ZipFile(<font color=#004488>"test.zip"</font>);
    Enumeration e = zf.entries();
    <font color=#0000ff>while</font>(e.hasMoreElements()) {
      ZipEntry ze2 = (ZipEntry)e.nextElement();
      System.out.println(<font color=#004488>"File: "</font> + ze2);
      <font color=#009900>// ... and extract the data as before</font>
    }
    <font color=#0000ff>if</font>(args.length == 1)
      monitor.expect(<font color=#0000ff>new</font> String[] {
        <font color=#004488>"%% Checksum: \\d+"</font>,
        <font color=#004488>"File: "</font> + args[0]
      });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>For each file to add to the archive, you must call <b>putNextEntry(&#160;) </b>and pass it a <a name="Index1460"></a><a name="Index1461"></a><b>ZipEntry </b>object. The <b>ZipEntry</b> object contains an extensive interface that allows you to get and set all the data available on that particular entry in your Zip file: name, compressed and uncompressed sizes, date, CRC checksum, extra field data, comment, compression method, and whether it&#146;s a directory entry. However, even though the Zip format has a way to set a password, this is not supported in Java&#146;s Zip library. And although <b>CheckedInputStream</b> and <b>CheckedOutputStream</b> support both <b>Adler32</b> and <b>CRC32</b> checksums, the <b>ZipEntry</b> class supports only an interface for CRC. This is a restriction of the underlying Zip format, but it might limit you from using the faster <b>Adler32</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1702" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To extract files, <b>ZipInputStream</b> has a <b>getNextEntry(&#160;)</b> method that returns the next <b>ZipEntry</b> if there is one. As a more succinct alternative, you can read the file using a <b>ZipFile</b> object, which has a method <b>entries(&#160;) </b>to return an <b>Enumeration</b> to the <b>ZipEntries</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1703" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In order to read the checksum, you must somehow have access to the associated <b>Checksum</b> object. Here, a reference to the <b>CheckedOutputStream</b> and <b>CheckedInputStream</b> objects is retained, but you could also just hold onto a reference to the <b>Checksum</b> object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1704" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A baffling method in Zip streams is <b>setComment(&#160;)</b>. As shown in <b>ZipCompress.java</b>, you can set a comment when you&#146;re writing a file, but there&#146;s no way to recover the comment in the <b>ZipInputStream</b>. Comments appear to be supported fully on an entry-by-entry basis only via <b>ZipEntry</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1705" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Of course, you are not limited to files when using the <b>GZIP</b> or <b>Zip</b> libraries&#151;you can compress anything, including data to be sent through a network connection. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1706" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775818"></a><a name="Heading15496"></a>Java ARchives (JARs)</h3>
<p>The Zip format is also used in the JAR (Java ARchive) file format, which is a way to collect a group of files into a single compressed file, just like Zip. However, like everything else in Java, JAR files are cross-platform, so you don&#146;t need to worry about platform issues. You can also include audio and image files as well as class files. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1707" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1462"></a>JAR files are particularly helpful when you deal with the Internet. Before JAR files, your Web browser would have to make repeated requests of a Web server in order to download all of the files that make up an applet. In addition, each of these files was uncompressed. By combining all of the files for a particular applet into a single JAR file, only one server request is necessary and the transfer is faster because of compression. And each entry in a JAR file can be digitally signed for security (see Chapter 14 for an example of signing). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1708" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A JAR file consists of a single file containing a collection of zipped files along with a &#147;manifest&#148; that describes them. (You can create your own manifest file; otherwise, the <a name="Index1463"></a><b>jar </b>program will do it for you.) You can find out more about JAR manifests in the JDK documentation. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1709" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>jar</b> utility that comes with Sun&#146;s JDK automatically compresses the files of your choice. You invoke it on the command line: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1710" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar [options] destination [manifest] inputfile(s)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The options are simply a collection of letters (no hyphen or any other indicator is necessary). Unix/Linux users will note the similarity to the <b>tar </b>options. These are:<br></p>
<div align="center" style="position:relative; left: 0"><table border="1">
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>c </b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Creates a new or empty archive. <br></p>
</td>
</tr>
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>t </b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Lists the table of contents. <br></p>
</td>
</tr>
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>x</b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Extracts all files.<br></p>
</td>
</tr>
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>x file</b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Extracts the named file.<br></p>
</td>
</tr>
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>f</b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Says: &#147;I&#146;m going to give you the name of the file.&#148; If you don&#146;t use this, <b>jar</b> assumes that its input will come from standard input, or, if it is creating a file, its output will go to standard output.<br></p>
</td>
</tr>
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>m</b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Says that the first argument will be the name of the user-created manifest file.<br></p>
</td>
</tr>
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>v</b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Generates verbose output describing what <b>jar</b> is doing.<br></p>
</td>
</tr>
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>0</b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Only store the files; doesn&#146;t compress the files (use to create a JAR file that you can put in your classpath).<br></p>
</td>
</tr>
<tr valign="top">
<td width="66.666650" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>M</b><br></p>
</td>
<td width="387.999903" colspan="1" rowspan="1" valign="top">
<p class="Table">Don&#146;t automatically create a manifest file.<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">If a subdirectory is included in the files to be put into the JAR file, that subdirectory is automatically added, including all of its subdirectories, etc. Path information is also preserved.<br></p>
<p>Here are some typical ways to invoke <b>jar</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cf myJarFile.jar *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This creates a JAR file called <b>myJarFile.jar</b> that contains all of the class files in the current directory, along with an automatically generated manifest file. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1711" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cmf myJarFile.jar myManifestFile.mf *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Like the previous example, but adding a user-created manifest file called <b>myManifestFile.mf</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1712" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar tf myJarFile.jar</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Produces a table of contents of the files in <b>myJarFile.jar</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1713" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar tvf myJarFile.jar</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Adds the &#147;verbose&#148; flag to give more detailed information about the files in <b>myJarFile.jar</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1714" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cvf myApp.jar audio classes image</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Assuming <b>audio</b>, <b>classes,</b> and <b>image</b> are subdirectories, this combines all of the subdirectories into the file <b>myApp.jar</b>. The &#147;verbose&#148; flag is also included to give extra feedback while the <b>jar</b> program is working. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1715" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you create a JAR file using the <b>0</b> (zero) option, that file can be placed in your CLASSPATH:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CLASSPATH=<font color=#004488>"lib1.jar;lib2.jar;"</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Then Java can search <b>lib1.jar</b> and <b>lib2.jar</b> for class files. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1716" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>jar</b> tool isn&#146;t as useful as a <b>zip</b> utility. For example, you can&#146;t add or update files to an existing JAR file; you can create JAR files only from scratch. Also, you can&#146;t move files into a JAR file, erasing them as they are moved. However, a JAR file created on one platform will be transparently readable by the <b>jar</b> tool on any other platform (a problem that sometimes plagues <b>zip</b> utilities). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1717" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As you will see in Chapter 14, JAR files are also used to package JavaBeans. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1718" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775819"></a><a name="Heading15545"></a>Object
serialization<br></h2>
<p><a name="Index1464"></a><a name="Index1465"></a><a name="Index1466"></a><a name="Index1467"></a><a name="Index1468"></a><a name="Index1469"></a>Java&#146;s <i>object serialization</i> allows you to take any object that implements the <b>Serializable</b> interface and turn it into a sequence of bytes that can later be fully restored to regenerate the original object. This is even true across a network, which means that the serialization mechanism automatically compensates for differences in operating systems. That is, you can create an object on a Windows machine, serialize it, and send it across the network to a Unix machine, where it will be correctly reconstructed. You don&#146;t have to worry about the data representations on the different machines, the byte ordering, or any other details. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1719" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>By itself, object serialization is interesting because it allows you to implement <i>lightweight persistence</i>. Remember that persistence means that an object&#146;s lifetime is not determined by whether a program is executing; the object lives <i>in</i> <i>between</i> invocations of the program. By taking a serializable object and writing it to disk, then restoring that object when the program is reinvoked, you&#146;re able to produce the effect of persistence. The reason it&#146;s called &#147;lightweight&#148; is that you can&#146;t simply define an object using some kind of &#147;persistent&#148; keyword and let the system take care of the details (although this might happen in the future). Instead, you must explicitly serialize and deserialize the objects in your program. If you need a more serious persistence mechanism, consider <i>Java Data Objects</i> (JDO) or a tool like Hibernate (<i>http://hibernate.sourceforge.net</i>). For details, see<i> Thinking in Enterprise Java</i>, downloadable from <i>www.BruceEckel.com.</i> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1720" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Object serialization was added to the language to support two major features. Java&#146;s <i>Remote Method Invocation</i> (RMI) allows objects that live on other machines to behave as if they live on your machine. When sending messages to remote objects, object serialization is necessary to transport the arguments and return values. RMI is discussed in <i>Thinking in Enterprise Java</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1721" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Object serialization is also necessary for JavaBeans, described in Chapter 14. When a Bean is used, its state information is generally configured at design time. This state information must be stored and later recovered when the program is started; object serialization performs this task. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1722" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Serializing an object is quite simple as long as the object implements the <b>Serializable</b> interface (this is a tagging interface and has no methods). When serialization was added to the language, many standard library classes were changed to make them serializable, including all of the wrappers for the primitive types, all of the container classes, and many others. Even <b>Class</b> objects can be serialized. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1723" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To serialize an object, you create some sort of <b>OutputStream</b> object and then wrap it inside an <a name="Index1470"></a><a name="Index1471"></a><b>ObjectOutputStream</b> object. At this point you need only call <a name="Index1472"></a><a name="Index1473"></a><b>writeObject(&#160;)</b>, and your object is serialized and sent to the <b>OutputStream</b>. To reverse the process, you wrap an <b>InputStream</b> inside an <b>ObjectInputStream</b> and call <a name="Index1474"></a><a name="Index1475"></a><b>readObject(&#160;)</b>. What comes back is, as usual, a reference to an upcast <b>Object</b>, so you must downcast to set things straight. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1724" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A particularly clever aspect of object serialization is that it not only saves an image of your object, but it also follows all the references contained in your object and saves <i>those </i>objects, and follows all the references in each of those objects, etc. This is sometimes referred to as the &#147;web of objects&#148; that a single object can be connected to, and it includes arrays of references to objects as well as member objects. If you had to maintain your own object serialization scheme, maintaining the code to follow all these links would be a bit mind-boggling. However, Java object serialization seems to pull it off flawlessly, no doubt using an optimized algorithm that traverses the web of objects. The following example tests the serialization mechanism by making a &#147;worm&#148; of linked objects, each of which has a link to the next segment in the worm as well as an array of references to objects of a different class, <a name="Index1476"></a><a name="Index1477"></a><b>Data</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Worm.java</font>
<font color=#009900>// Demonstrates object serialization.</font>
<font color=#009900>// {Clean: worm.out}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Data <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> n;
  <font color=#0000ff>public</font> Data(<font color=#0000ff>int</font> n) { <font color=#0000ff>this</font>.n = n; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> Integer.toString(n); }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Worm <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random rand = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>private</font> Data[] d = {
    <font color=#0000ff>new</font> Data(rand.nextInt(10)),
    <font color=#0000ff>new</font> Data(rand.nextInt(10)),
    <font color=#0000ff>new</font> Data(rand.nextInt(10))
  };
  <font color=#0000ff>private</font> Worm next;
  <font color=#0000ff>private</font> <font color=#0000ff>char</font> c;
  <font color=#009900>// Value of i == number of segments</font>
  <font color=#0000ff>public</font> Worm(<font color=#0000ff>int</font> i, <font color=#0000ff>char</font> x) {
    System.out.println(<font color=#004488>"Worm constructor: "</font> + i);
    c = x;
    <font color=#0000ff>if</font>(--i &gt; 0)
      next = <font color=#0000ff>new</font> Worm(i, (<font color=#0000ff>char</font>)(x + 1));
  }
  <font color=#0000ff>public</font> Worm() {
    System.out.println(<font color=#004488>"Default constructor"</font>);
  }
  <font color=#0000ff>public</font> String toString() {
    String s = <font color=#004488>":"</font> + c + <font color=#004488>"("</font>;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; d.length; i++)
      s += d[i];
    s += <font color=#004488>")"</font>;
    <font color=#0000ff>if</font>(next != <font color=#0000ff>null</font>)
      s += next;
    <font color=#0000ff>return</font> s;
  }
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> ClassNotFoundException, IOException {
    Worm w = <font color=#0000ff>new</font> Worm(6, 'a');
    System.out.println(<font color=#004488>"w = "</font> + w);
    ObjectOutputStream out = <font color=#0000ff>new</font> ObjectOutputStream(
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"worm.out"</font>));
    out.writeObject(<font color=#004488>"Worm storage\n"</font>);
    out.writeObject(w);
    out.close(); <font color=#009900>// Also flushes output</font>
    ObjectInputStream in = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"worm.out"</font>));
    String s = (String)in.readObject();
    Worm w2 = (Worm)in.readObject();
    System.out.println(s + <font color=#004488>"w2 = "</font> + w2);
    ByteArrayOutputStream bout =
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream out2 = <font color=#0000ff>new</font> ObjectOutputStream(bout);
    out2.writeObject(<font color=#004488>"Worm storage\n"</font>);
    out2.writeObject(w);
    out2.flush();
    ObjectInputStream in2 = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> ByteArrayInputStream(bout.toByteArray()));
    s = (String)in2.readObject();
    Worm w3 = (Worm)in2.readObject();
    System.out.println(s + <font color=#004488>"w3 = "</font> + w3);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>To make things interesting, the array of <b>Data</b> objects inside <b>Worm</b> are initialized with random numbers. (This way you don&#146;t suspect the compiler of keeping some kind of meta-information.) Each <b>Worm</b> segment is labeled with a <b>char</b> that&#146;s automatically generated in the process of recursively generating the linked list of <b>Worm</b>s. When you create a <b>Worm</b>, you tell the constructor how long you want it to be. To make the <b>next</b> reference, it calls the <b>Worm</b> constructor with a length of one less, etc. The final <b>next</b> reference is left as <b>null</b>, indicating the end of the <b>Worm</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1725" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The point of all this was to make something reasonably complex that couldn&#146;t easily be serialized. The act of serializing, however, is quite simple. Once the <b>ObjectOutputStream</b> is created from some other stream, <b>writeObject(&#160;)</b> serializes the object. Notice the call to <b>writeObject(&#160;)</b> for a <b>String</b>, as well. You can also write all the primitive data types using the same methods as <b>DataOutputStream</b> (they share the same interface). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1726" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There are two separate code sections that look similar. The first writes and reads a file and the second, for variety, writes and reads a <b>ByteArray</b>. You can read and write an object using serialization to any <b>DataInputStream</b> or <b>DataOutputStream</b> including, as you can see in <i>Thinking in Enterprise Java</i>, a network. The output from one run was:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(414):b(276):c(773):d(870):e(210):f(279)
Worm storage
w2 = :a(414):b(276):c(773):d(870):e(210):f(279)
Worm storage
w3 = :a(414):b(276):c(773):d(870):e(210):f(279)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that the deserialized object really does contain all of the links that were in the original object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1727" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that no constructor, not even the default constructor, is called in the process of deserializing a <b>Serializable</b> object. The entire object is restored by recovering data from the <b>InputStream</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1728" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Object serialization is <b>byte</b>-oriented, and thus uses the <b>InputStream</b> and <b>OutputStream</b> hierarchies. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1729" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775820"></a><a name="Heading15640"></a>Finding the class</h3>
<p>You might wonder what&#146;s necessary for an object to be recovered from its serialized state. For example, suppose you serialize an object and send it as a file or through a network to another machine. Could a program on the other machine reconstruct the object using only the contents of the file? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1730" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The best way to answer this question is (as usual) by performing an experiment. The following file goes in the subdirectory for this chapter: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1731" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Alien.java</font>
<font color=#009900>// A serializable class.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Alien <font color=#0000ff>implements</font> Serializable {} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The file that creates and serializes an <b>Alien </b>object goes in the same directory: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1732" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:FreezeAlien.java</font>
<font color=#009900>// Create a serialized output file.</font>
<font color=#009900>// {Clean: X.file}</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FreezeAlien {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    ObjectOutput out = <font color=#0000ff>new</font> ObjectOutputStream(
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"X.file"</font>));
    Alien zorcon = <font color=#0000ff>new</font> Alien();
    out.writeObject(zorcon);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Rather than catching and handling exceptions, this program takes the quick-and-dirty approach of passing the exceptions out of <b>main(&#160;)</b>, so they&#146;ll be reported on the console. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1733" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once the program is compiled and run, it produces a file called <b>X.file</b> in the <b>c12</b> directory. The following code is in a subdirectory called <b>xfiles</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1734" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:xfiles:ThawAlien.java</font>
<font color=#009900>// Try to recover a serialized file without the</font>
<font color=#009900>// class of object that's stored in that file.</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThawAlien {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    ObjectInputStream in = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> FileInputStream(<font color=#0000ff>new</font> File(<font color=#004488>".."</font>, <font color=#004488>"X.file"</font>)));
    Object mystery = in.readObject();
    System.out.println(mystery.getClass());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Even opening the file and reading in the object <b>mystery</b> requires the <b>Class</b> object for <b>Alien</b>; the JVM cannot find <b>Alien.class</b> (unless it happens to be in the Classpath, which it shouldn&#146;t be in this example). You&#146;ll get a <b>ClassNotFoundException.</b> (Once again, all evidence of alien life vanishes before proof of its existence can be verified!) The JVM must be able to find the associated <b>.class</b> file. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1735" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775821"></a><a name="Heading15682"></a>Controlling
serialization<br></h3>
<p><a name="Index1478"></a><a name="Index1479"></a>As you can see, the default serialization mechanism is trivial to use. But what if you have special needs? Perhaps you have special security issues and you don&#146;t want to serialize portions of your object, or perhaps it just doesn&#146;t make sense for one subobject to be serialized if that part needs to be created anew when the object is recovered. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1737" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can control the process of serialization by implementing the <a name="Index1480"></a><a name="Index1481"></a><b>Externalizable</b> interface instead of the <a name="Index1482"></a><a name="Index1483"></a><b>Serializable</b> interface. The <b>Externalizable</b> interface extends the <b>Serializable</b> interface and adds two methods, <a name="Index1484"></a><a name="Index1485"></a><b>writeExternal(&#160;)</b> and <a name="Index1486"></a><a name="Index1487"></a><b>readExternal(&#160;),</b> that are automatically called for your object during serialization and deserialization so that you can perform your special operations. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1738" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The following example shows simple implementations of the <b>Externalizable</b> interface methods. Note that <b>Blip1</b> and <b>Blip2</b> are nearly identical except for a subtle difference (see if you can discover it by looking at the code):<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Blips.java</font>
<font color=#009900>// Simple use of Externalizable &amp; a pitfall.</font>
<font color=#009900>// {Clean: Blips.out}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Blip1 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>public</font> Blip1() {
    System.out.println(<font color=#004488>"Blip1 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip1.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip1.readExternal"</font>);
  }
}

<font color=#0000ff>class</font> Blip2 <font color=#0000ff>implements</font> Externalizable {
  Blip2() {
    System.out.println(<font color=#004488>"Blip2 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip2.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip2.readExternal"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Blips {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip1 b1 = <font color=#0000ff>new</font> Blip1();
    Blip2 b2 = <font color=#0000ff>new</font> Blip2();
    ObjectOutputStream o = <font color=#0000ff>new</font> ObjectOutputStream(
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blips.out"</font>));
    System.out.println(<font color=#004488>"Saving objects:"</font>);
    o.writeObject(b1);
    o.writeObject(b2);
    o.close();
    <font color=#009900>// Now get them back:</font>
    ObjectInputStream in = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blips.out"</font>));
    System.out.println(<font color=#004488>"Recovering b1:"</font>);
    b1 = (Blip1)in.readObject();
    <font color=#009900>// OOPS! Throws an exception:</font>
<font color=#009900>//! System.out.println("Recovering b2:");</font>
<font color=#009900>//! b2 = (Blip2)in.readObject();</font>
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Constructing objects:"</font>,
      <font color=#004488>"Blip1 Constructor"</font>,
      <font color=#004488>"Blip2 Constructor"</font>,
      <font color=#004488>"Saving objects:"</font>,
      <font color=#004488>"Blip1.writeExternal"</font>,
      <font color=#004488>"Blip2.writeExternal"</font>,
      <font color=#004488>"Recovering b1:"</font>,
      <font color=#004488>"Blip1 Constructor"</font>,
      <font color=#004488>"Blip1.readExternal"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The reason that the <b>Blip2</b> object is not recovered is that trying to do so causes an exception. Can you see the difference between <b>Blip1</b> and <b>Blip2</b>? The constructor for <b>Blip1</b> is <b>public</b>, while the constructor for <b>Blip2</b> is not, and that causes the exception upon recovery. Try making <b>Blip2</b>&#146;s constructor <b>public </b>and removing the <b>//! </b>comments to see the correct results. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1740" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When <b>b1</b> is recovered, the <b>Blip1</b> default constructor is called. This is different from recovering a <b>Serializable</b> object, in which the object is constructed entirely from its stored bits, with no constructor calls. With an <b>Externalizable</b> object, all the normal default construction behavior occurs (including the initializations at the point of field definition), and <i>then</i> <b>readExternal(&#160;)</b> is called. You need to be aware of this&#151;in particular, the fact that all the default construction always takes place&#151;to produce the correct behavior in your <b>Externalizable</b> objects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1741" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example that shows what you must do to fully store and retrieve an <b>Externalizable</b> object: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1742" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Blip3.java</font>
<font color=#009900>// Reconstructing an externalizable object.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Blip3 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>private</font> String s; <font color=#009900>// No initialization</font>
  <font color=#0000ff>public</font> Blip3() {
    System.out.println(<font color=#004488>"Blip3 Constructor"</font>);
    <font color=#009900>// s, i not initialized</font>
  }
  <font color=#0000ff>public</font> Blip3(String x, <font color=#0000ff>int</font> a) {
    System.out.println(<font color=#004488>"Blip3(String x, int a)"</font>);
    s = x;
    i = a;
    <font color=#009900>// s &amp; i initialized only in nondefault constructor.</font>
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> s + i; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
  <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip3.writeExternal"</font>);
    <font color=#009900>// You must do this:</font>
    out.writeObject(s);
    out.writeInt(i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip3.readExternal"</font>);
    <font color=#009900>// You must do this:</font>
    s = (String)in.readObject();
    i = in.readInt();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip3 b3 = <font color=#0000ff>new</font> Blip3(<font color=#004488>"A String "</font>, 47);
    System.out.println(b3);
    ObjectOutputStream o = <font color=#0000ff>new</font> ObjectOutputStream(
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blip3.out"</font>));
    System.out.println(<font color=#004488>"Saving object:"</font>);
    o.writeObject(b3);
    o.close();
    <font color=#009900>// Now get it back:</font>
    ObjectInputStream in = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blip3.out"</font>));
    System.out.println(<font color=#004488>"Recovering b3:"</font>);
    b3 = (Blip3)in.readObject();
    System.out.println(b3);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Constructing objects:"</font>,
      <font color=#004488>"Blip3(String x, int a)"</font>,
      <font color=#004488>"A String 47"</font>,
      <font color=#004488>"Saving object:"</font>,
      <font color=#004488>"Blip3.writeExternal"</font>,
      <font color=#004488>"Recovering b3:"</font>,
      <font color=#004488>"Blip3 Constructor"</font>,
      <font color=#004488>"Blip3.readExternal"</font>,
      <font color=#004488>"A String 47"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The fields <b>s</b> and <b>i </b>are initialized only in the second constructor, but not in the default constructor. This means that if you don&#146;t initialize <b>s</b> and <b>i </b>in <b>readExternal(&#160;)</b>, <b>s</b> will be <b>null</b> and <b>i</b> will be zero (since the storage for the object gets wiped to zero in the first step of object creation). If you comment out the two lines of code following the phrases &#147;You must do this&#148; and run the program, you&#146;ll see that when the object is recovered, <b>s</b> is <b>null</b> and <b>i</b> is zero. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1743" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you are inheriting from an <b>Externalizable</b> object, you&#146;ll typically call the base-class versions of <b>writeExternal(&#160;) </b>and <b>readExternal(&#160;)</b> to provide proper storage and retrieval of the base-class components. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1744" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>So to make things work correctly you must not only write the important data from the object during the <b>writeExternal(&#160;) </b>method (there is no default behavior that writes any of the member objects for an <b>Externalizable</b> object), but you must also recover that data in the <b>readExternal(&#160;)</b> method. This can be a bit confusing at first because the default construction behavior for an <b>Externalizable</b> object can make it seem like some kind of storage and retrieval takes place automatically. It does not. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1745" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading15828"></a>The transient keyword</h4>
<p>When you&#146;re controlling serialization, there might be a particular subobject that you don&#146;t want Java&#146;s serialization mechanism to automatically save and restore. This is commonly the case if that subobject represents sensitive information that you don&#146;t want to serialize, such as a password. Even if that information is <b>private </b>in the object, once it has been serialized, it&#146;s possible for someone to access it by reading a file or intercepting a network transmission. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1746" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One way to prevent sensitive parts of your object from being serialized is to implement your class as <b>Externalizable</b>, as shown previously. Then nothing is automatically serialized, and you can explicitly serialize only the necessary parts inside <b>writeExternal(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1747" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you&#146;re working with a <b>Serializable </b>object, however, all serialization happens automatically. To control this, you can turn off serialization on a field-by-field basis using the <a name="Index1488"></a><a name="Index1489"></a><a name="Index1490"></a><b>transient</b> keyword, which says &#147;Don&#146;t bother saving or restoring this&#151;I&#146;ll take care of it.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1748" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>For example, consider a <b>Login </b>object that keeps information about a particular login session. Suppose that, once you verify the login, you want to store the data, but without the password. The easiest way to do this is by implementing <a name="Index1491"></a><b>Serializable</b> and marking the <b>password</b> field as <b>transient</b>. Here&#146;s what it looks like:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Logon.java</font>
<font color=#009900>// Demonstrates the "transient" keyword.</font>
<font color=#009900>// {Clean: Logon.out}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Logon <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> Date date = <font color=#0000ff>new</font> Date();
  <font color=#0000ff>private</font> String username;
  <font color=#0000ff>private</font> <font color=#0000ff>transient</font> String password;
  <font color=#0000ff>public</font> Logon(String name, String pwd) {
    username = name;
    password = pwd;
  }
  <font color=#0000ff>public</font> String toString() {
    String pwd = (password == <font color=#0000ff>null</font>) ? <font color=#004488>"(n</font><font color=#004488>/a)"</font> : password;
    <font color=#0000ff>return</font> <font color=#004488>"logon info: \n   username: "</font> + username +
      <font color=#004488>"\n   date: "</font> + date + <font color=#004488>"\n   password: "</font> + pwd;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    Logon a = <font color=#0000ff>new</font> Logon(<font color=#004488>"Hulk"</font>, <font color=#004488>"myLittlePony"</font>);
    System.out.println( <font color=#004488>"logon a = "</font> + a);
    ObjectOutputStream o = <font color=#0000ff>new</font> ObjectOutputStream(
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Logon.out"</font>));
    o.writeObject(a);
    o.close();
    Thread.sleep(1000); <font color=#009900>// Delay for 1 second</font>
    <font color=#009900>// Now get them back:</font>
    ObjectInputStream in = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Logon.out"</font>));
    System.out.println(<font color=#004488>"Recovering object at "</font>+<font color=#0000ff>new</font> Date());
    a = (Logon)in.readObject();
    System.out.println(<font color=#004488>"logon a = "</font> + a);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that the <b>date</b> and <b>username</b> fields are ordinary (not <b>transient</b>), and thus are automatically serialized. However, the <b>password</b> is <b>transient</b>, so it is not stored to disk; also, the serialization mechanism makes no attempt to recover it. The output is: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1749" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>logon a = logon info:
   username: Hulk
   date: Mon Oct 21 12:10:13 MDT 2002
   password: myLittlePony
Recovering object at Mon Oct 21 12:10:14 MDT 2002
logon a = logon info:
   username: Hulk
   date: Mon Oct 21 12:10:13 MDT 2002
   password: (n/a)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>When the object is recovered, the <b>password</b> field is <b>null</b>. Note that <b>toString(&#160;)</b> must check for a <b>null</b> value of <b>password</b>,<b> </b>because if you try to assemble a <b>String</b> object using the overloaded &#145;<b>+</b>&#146; operator, and that operator encounters a <b>null </b>reference, you&#146;ll get a <b>NullPointerException.</b> (Newer versions of Java might contain code to avoid this problem.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1750" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can also see that the <b>date</b> field is stored to and recovered from disk and not generated anew. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1751" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Since <b>Externalizable</b> objects do not store any of their fields by default, the <b>transient</b> keyword is for use with <b>Serializable</b> objects only. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1752" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading15883"></a>An alternative to <b>Externalizable</b></h4>
<p>If you&#146;re not keen on implementing the <a name="Index1492"></a><b>Externalizable </b>interface, there&#146;s another approach. You can implement the <b>Serializable</b> interface and <i>add </i>(notice I say &#147;add&#148; and not &#147;override&#148; or &#147;implement&#148;) methods called <a name="Index1493"></a><a name="Index1494"></a><b>writeObject(&#160;)</b> and <a name="Index1495"></a><a name="Index1496"></a><b>readObject(&#160;)</b> that will automatically be called when the object is serialized and deserialized, respectively. That is, if you provide these two methods, they will be used instead of the default serialization. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1753" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The methods must have these exact signatures:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>private</font> <font color=#0000ff>void</font> writeObject(ObjectOutputStream stream)
<font color=#0000ff>throws</font> IOException;

<font color=#0000ff>private</font> <font color=#0000ff>void</font> readObject(ObjectInputStream stream)
<font color=#0000ff>throws</font> IOException, ClassNotFoundException</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>From a design standpoint, things get really weird here. First of all, you might think that because these methods are not part of a base class or the <b>Serializable</b> interface, they ought to be defined in their own interface(s). But notice that they are defined as <b>private</b>, which means they are to be called only by other members of this class. However, you don&#146;t actually call them from other members of this class, but instead the <b>writeObject(&#160;)</b> and <b>readObject(&#160;)</b> methods of the <b>ObjectOutputStream</b> and <b>ObjectInputStream</b> objects call your object&#146;s <b>writeObject(&#160;)</b> and <b>readObject(&#160;)</b> methods. (Notice my tremendous restraint in not launching into a long diatribe about using the same method names here. In a word: confusing.) You might wonder how the <b>ObjectOutputStream</b> and <b>ObjectInputStream</b> objects have access to <b>private</b> methods of your class. We can only assume that this is part of the serialization magic. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1754" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In any event, anything defined in an <b>interface</b> is automatically <b>public</b> so if <b>writeObject(&#160;)</b> and <b>readObject(&#160;)</b> must be <b>private</b>, then they can&#146;t be part of an <b>interface</b>. Since you must follow the signatures exactly, the effect is the same as if you&#146;re implementing an <b>interface</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1755" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It would appear that when you call <b>ObjectOutputStream.writeObject(&#160;)</b>, the <b>Serializable</b> object that you pass it to is interrogated (using reflection, no doubt) to see if it implements its own <b>writeObject(&#160;)</b>. If so, the normal serialization process is skipped and the <b>writeObject(&#160;)</b> is called. The same sort of situation exists for <b>readObject(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1756" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There&#146;s one other twist. Inside your <b>writeObject(&#160;)</b>, you can choose to perform the default <b>writeObject(&#160;)</b> action by calling <b>defaultWriteObject(&#160;)</b>. Likewise, inside <b>readObject(&#160;)</b> you can call <b>defaultReadObject(&#160;)</b>. Here is a simple example that demonstrates how you can control the storage and retrieval of a <b>Serializable</b> object:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:SerialCtl.java</font>
<font color=#009900>// Controlling serialization by adding your own</font>
<font color=#009900>// writeObject() and readObject() methods.</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SerialCtl <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> String a;
  <font color=#0000ff>private</font> <font color=#0000ff>transient</font> String b;
  <font color=#0000ff>public</font> SerialCtl(String aa, String bb) {
    a = <font color=#004488>"Not Transient: "</font> + aa;
    b = <font color=#004488>"Transient: "</font> + bb;
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> a + <font color=#004488>"\n"</font> + b; }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> writeObject(ObjectOutputStream stream)
  <font color=#0000ff>throws</font> IOException {
    stream.defaultWriteObject();
    stream.writeObject(b);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> readObject(ObjectInputStream stream)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    stream.defaultReadObject();
    b = (String)stream.readObject();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    SerialCtl sc = <font color=#0000ff>new</font> SerialCtl(<font color=#004488>"Test1"</font>, <font color=#004488>"Test2"</font>);
    System.out.println(<font color=#004488>"Before:\n"</font> + sc);
    ByteArrayOutputStream buf= <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o = <font color=#0000ff>new</font> ObjectOutputStream(buf);
    o.writeObject(sc);
    <font color=#009900>// Now get it back:</font>
    ObjectInputStream in = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> ByteArrayInputStream(buf.toByteArray()));
    SerialCtl sc2 = (SerialCtl)in.readObject();
    System.out.println(<font color=#004488>"After:\n"</font> + sc2);
    monitor.expect(<font color=#0000ff>new</font> String[] {
     <font color=#004488>"Before:"</font>,
     <font color=#004488>"Not Transient: Test1"</font>,
     <font color=#004488>"Transient: Test2"</font>,
     <font color=#004488>"After:"</font>,
     <font color=#004488>"Not Transient: Test1"</font>,
     <font color=#004488>"Transient: Test2"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In this example, one <b>String</b> field is ordinary and the other is <b>transient</b>, to prove that the non-<b>transient</b> field is saved by the <a name="Index1497"></a><a name="Index1498"></a><b>defaultWriteObject(&#160;)</b> method and the <b>transient</b> field is saved and restored explicitly. The fields are initialized inside the constructor rather than at the point of definition to prove that they are not being initialized by some automatic mechanism during deserialization. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1757" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you are going to use the default mechanism to write the non-<b>transient</b> parts of your object, you must call <b>defaultWriteObject(&#160;)</b> as the first operation in <b>writeObject(&#160;)</b>, and <a name="Index1499"></a><a name="Index1500"></a><b>defaultReadObject(&#160;)</b> as the first operation in <b>readObject(&#160;)</b>. These are strange method calls. It would appear, for example, that you are calling <b>defaultWriteObject(&#160;)</b> for an <b>ObjectOutputStream</b> and passing it no arguments, and yet it somehow turns around and knows the reference to your object and how to write all the non-<b>transient</b> parts. Spooky. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1758" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The storage and retrieval of the <b>transient</b> objects uses more familiar code. And yet, think about what happens here. In <b>main(&#160;)</b>, a <b>SerialCtl</b> object is created, and then it&#146;s serialized to an <b>ObjectOutputStream.</b> (Notice in this case that a buffer is used instead of a file&#151;it&#146;s all the same to the <b>ObjectOutputStream</b>.) The serialization occurs in the line:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>o.writeObject(sc);</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>writeObject(&#160;)</b> method must be examining <b>sc</b> to see if it has its own <b>writeObject(&#160;)</b> method. (Not by checking the interface&#151;there isn&#146;t one&#151;or the class type, but by actually hunting for the method using reflection.) If it does, it uses that. A similar approach holds true for <b>readObject(&#160;)</b>. Perhaps this was the only practical way that they could solve the problem, but it&#146;s certainly strange. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1759" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading15950"></a>Versioning<br></h4>
<p><a name="Index1501"></a><a name="Index1502"></a>It&#146;s possible that you might want to change the version of a serializable class (objects of the original class might be stored in a database, for example). This is supported, but you&#146;ll probably do it only in special cases, and it requires an extra depth of understanding that we will not attempt to achieve here. The JDK documents downloadable from <i>java.sun.com</i> cover this topic quite thoroughly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1760" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You will also notice in the JDK documentation many comments that begin with:<br></p>
<p><b><i>Warning:</i></b><i> Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications ...</i><br></p>
<p>This is because the versioning mechanism is too simple to work reliably in all situations, especially with JavaBeans. They&#146;re working on a correction for the design, and that&#146;s what the warning is about. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1761" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775822"></a><a name="Heading15955"></a>Using persistence<br></h3>
<p><a name="Index1503"></a>It&#146;s quite appealing to use serialization technology to store some of the state of your program so that you can easily restore the program to the current state later. But before you can do this, some questions must be answered. What happens if you serialize two objects that both have a reference to a third object? When you restore those two objects from their serialized state, do you get only one occurrence of the third object? What if you serialize your two objects to separate files and deserialize them in different parts of your code? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1762" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index1504"></a>Here&#146;s an example that shows the problem:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:MyWorld.java</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> House <font color=#0000ff>implements</font> Serializable {}

<font color=#0000ff>class</font> Animal <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> String name;
  <font color=#0000ff>private</font> House preferredHouse;
  Animal(String nm, House h) {
    name = nm;
    preferredHouse = h;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> name + <font color=#004488>"["</font> + <font color=#0000ff>super</font>.toString() +
      <font color=#004488>"], "</font> + preferredHouse + <font color=#004488>"\n"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MyWorld {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    House house = <font color=#0000ff>new</font> House();
    List animals = <font color=#0000ff>new</font> ArrayList();
    animals.add(<font color=#0000ff>new</font> Animal(<font color=#004488>"Bosco the dog"</font>, house));
    animals.add(<font color=#0000ff>new</font> Animal(<font color=#004488>"Ralph the hamster"</font>, house));
    animals.add(<font color=#0000ff>new</font> Animal(<font color=#004488>"Fronk the cat"</font>, house));
    System.out.println(<font color=#004488>"animals: "</font> + animals);
    ByteArrayOutputStream buf1 =
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o1 = <font color=#0000ff>new</font> ObjectOutputStream(buf1);
    o1.writeObject(animals);
    o1.writeObject(animals); <font color=#009900>// Write a 2nd set</font>
    <font color=#009900>// Write to a different stream:</font>
    ByteArrayOutputStream buf2 =
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o2 = <font color=#0000ff>new</font> ObjectOutputStream(buf2);
    o2.writeObject(animals);
    <font color=#009900>// Now get them back:</font>
    ObjectInputStream in1 = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> ByteArrayInputStream(buf1.toByteArray()));
    ObjectInputStream in2 = <font color=#0000ff>new</font> ObjectInputStream(
      <font color=#0000ff>new</font> ByteArrayInputStream(buf2.toByteArray()));
    List
      animals1 = (List)in1.readObject(),
      animals2 = (List)in1.readObject(),
      animals3 = (List)in2.readObject();
    System.out.println(<font color=#004488>"animals1: "</font> + animals1);
    System.out.println(<font color=#004488>"animals2: "</font> + animals2);
    System.out.println(<font color=#004488>"animals3: "</font> + animals3);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>One thing that&#146;s interesting here is that it&#146;s possible to use object serialization to and from a byte array as a way of doing a &#147;deep copy&#148; of any object that&#146;s <b>Serializable.</b> (A deep copy means that you&#146;re duplicating the entire web of objects, rather than just the basic object and its references.) Object copying is covered in depth in Appendix A. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1763" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Animal</b> objects contain fields of type <b>House</b>. In <b>main(&#160;)</b>, a <b>List</b> of these <b>Animal</b>s is created and it is serialized twice to one stream and then again to a separate stream. When these are deserialized and printed, you see the following results for one run (the objects will be in different memory locations each run): <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0147" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>animals: [Bosco the dog[Animal@1cde100], House@16f0472
, Ralph the hamster[Animal@18d107f], House@16f0472
, Fronk the cat[Animal@360be0], House@16f0472
]
animals1: [Bosco the dog[Animal@e86da0], House@1754ad2
, Ralph the hamster[Animal@1833955], House@1754ad2
, Fronk the cat[Animal@291aff], House@1754ad2
]
animals2: [Bosco the dog[Animal@e86da0], House@1754ad2
, Ralph the hamster[Animal@1833955], House@1754ad2
, Fronk the cat[Animal@291aff], House@1754ad2
]
animals3: [Bosco the dog[Animal@ab95e6], House@fe64b9
, Ralph the hamster[Animal@186db54], House@fe64b9
, Fronk the cat[Animal@a97b0b], House@fe64b9
]</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Of course you expect that the deserialized objects have different addresses from their originals. But notice that in <b>animals1</b> and <b>animals2</b>, the same addresses appear, including the references to the <b>House </b>object that both share. On the other hand, when <b>animals3 </b>is recovered, the system has no way of knowing that the objects in this other stream are aliases of the objects in the first stream, so it makes a completely different web of objects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1764" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As long as you&#146;re serializing everything to a single stream, you&#146;ll be able to recover the same web of objects that you wrote, with no accidental duplication of objects. Of course, you can change the state of your objects in between the time you write the first and the last, but that&#146;s your responsibility; the objects will be written in whatever state they are in (and with whatever connections they have to other objects) at the time you serialize them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1765" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The safest thing to do if you want to save the state of a system is to serialize as an &#147;atomic&#148; operation. If you serialize some things, do some other work, and serialize some more, etc., then you will not be storing the system safely. Instead, put all the objects that comprise the state of your system in a single container and simply write that container out in one operation. Then you can restore it with a single method call as well. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1766" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The following example is an imaginary computer-aided design (CAD) system that demonstrates the approach. In addition, it throws in the issue of <b>static</b> fields; if you look at the JDK documentation you&#146;ll see that <b>Class</b> is <b>Serializable</b>, so it should be easy to store the <b>static</b> fields by simply serializing the <a name="Index1505"></a><a name="Index1506"></a><b>Class</b> object. That seems like a sensible approach, anyway. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0148" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:CADState.java</font>
<font color=#009900>// Saving and restoring the state of a pretend CAD system.</font>
<font color=#009900>// {Clean: CADState.out}</font>
<font color=#009900>//package c12;</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Shape <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> RED = 1, BLUE = 2, GREEN = 3;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> xPos, yPos, dimension;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor);
  <font color=#0000ff>public</font> <font color=#0000ff>abstract</font> <font color=#0000ff>int</font> getColor();
  <font color=#0000ff>public</font> Shape(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    xPos = xVal;
    yPos = yVal;
    dimension = dim;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> getClass() +
      <font color=#004488>"color["</font> + getColor() + <font color=#004488>"] xPos["</font> + xPos +
      <font color=#004488>"] yPos["</font> + yPos + <font color=#004488>"] dim["</font> + dimension + <font color=#004488>"]\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Shape randomFactory() {
    <font color=#0000ff>int</font> xVal = r.nextInt(100);
    <font color=#0000ff>int</font> yVal = r.nextInt(100);
    <font color=#0000ff>int</font> dim = r.nextInt(100);
    <font color=#0000ff>switch</font>(counter++ % 3) {
      <font color=#0000ff>default</font>:
      <font color=#0000ff>case</font> 0: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Circle(xVal, yVal, dim);
      <font color=#0000ff>case</font> 1: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Square(xVal, yVal, dim);
      <font color=#0000ff>case</font> 2: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Line(xVal, yVal, dim);
    }
  }
}

<font color=#0000ff>class</font> Circle <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> Circle(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { color = newColor; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { <font color=#0000ff>return</font> color; }
}

<font color=#0000ff>class</font> Square <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color;
  <font color=#0000ff>public</font> Square(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
    color = RED;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { color = newColor; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { <font color=#0000ff>return</font> color; }
}

<font color=#0000ff>class</font> Line <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  serializeStaticState(ObjectOutputStream os)
  <font color=#0000ff>throws</font> IOException { os.writeInt(color); }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  deserializeStaticState(ObjectInputStream os)
  <font color=#0000ff>throws</font> IOException { color = os.readInt(); }
  <font color=#0000ff>public</font> Line(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { color = newColor; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { <font color=#0000ff>return</font> color; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CADState {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    List shapeTypes, shapes;
    <font color=#0000ff>if</font>(args.length == 0) {
      shapeTypes = <font color=#0000ff>new</font> ArrayList();
      shapes = <font color=#0000ff>new</font> ArrayList();
      <font color=#009900>// Add references to the class objects:</font>
      shapeTypes.add(Circle.<font color=#0000ff>class</font>);
      shapeTypes.add(Square.<font color=#0000ff>class</font>);
      shapeTypes.add(Line.<font color=#0000ff>class</font>);
      <font color=#009900>// Make some shapes:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        shapes.add(Shape.randomFactory());
      <font color=#009900>// Set all the static colors to GREEN:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        ((Shape)shapes.get(i)).setColor(Shape.GREEN);
      <font color=#009900>// Save the state vector:</font>
      ObjectOutputStream out = <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"CADState.out"</font>));
      out.writeObject(shapeTypes);
      Line.serializeStaticState(out);
      out.writeObject(shapes);
    } <font color=#0000ff>else</font> { <font color=#009900>// There's a command-line argument</font>
      ObjectInputStream in = <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(args[0]));
      <font color=#009900>// Read in the same order they were written:</font>
      shapeTypes = (List)in.readObject();
      Line.deserializeStaticState(in);
      shapes = (List)in.readObject();
    }
    <font color=#009900>// Display the shapes:</font>
    System.out.println(shapes);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>Shape</b> class <b>implements </b><a name="Index1507"></a><b>Serializable</b>, so anything that is inherited from <b>Shape</b> is automatically <b>Serializable</b> as well. Each <b>Shape</b> contains data, and each derived <b>Shape</b> class contains a <b>static</b> field that determines the color of all of those types of <b>Shape</b>s. (Placing a <b>static</b> field in the base class would result in only one field, since <b>static</b> fields are not duplicated in derived classes.) Methods in the base class can be overridden to set the color for the various types (<b>static</b> methods are not dynamically bound, so these are normal methods). The <b>randomFactory(&#160;)</b> method creates a different <b>Shape</b> each time you call it, using random values for the <b>Shape</b> data. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1767" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>Circle</b> and <b>Square</b> are straightforward extensions of <b>Shape</b>; the only difference is that <b>Circle</b> initializes <b>color</b> at the point of definition and <b>Square</b> initializes it in the constructor. We&#146;ll leave the discussion of <b>Line</b> for later. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1768" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In <b>main(&#160;)</b>, one <b>ArrayList</b> is used to hold the <b>Class</b> objects and the other to hold the shapes. If you don&#146;t provide a command-line argument, the <b>shapeTypes</b> <b>ArrayList</b> is created and the <b>Class</b> objects are added, and then the <b>shapes</b> <b>ArrayList</b> is created and <b>Shape</b> objects are added. Next, all the <b>static</b> <b>color</b> values are set to <b>GREEN</b>, and everything is serialized to the file <b>CADState.out</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1769" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you provide a command-line argument (presumably <b>CADState.out</b>), that file is opened and used to restore the state of the program. In both situations, the resulting <b>ArrayList</b> of <b>Shape</b>s is printed. The results from one run are:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>$ java CADState
[<font color=#0000ff>class</font> Circlecolor[3] xPos[71] yPos[82] dim[44]
, <font color=#0000ff>class</font> Squarecolor[3] xPos[98] yPos[21] dim[49]
, <font color=#0000ff>class</font> Linecolor[3] xPos[16] yPos[80] dim[37]
, <font color=#0000ff>class</font> Circlecolor[3] xPos[51] yPos[74] dim[7]
, <font color=#0000ff>class</font> Squarecolor[3] xPos[7] yPos[78] dim[98]
, <font color=#0000ff>class</font> Linecolor[3] xPos[38] yPos[79] dim[93]
, <font color=#0000ff>class</font> Circlecolor[3] xPos[84] yPos[12] dim[62]
, <font color=#0000ff>class</font> Squarecolor[3] xPos[16] yPos[51] dim[94]
, <font color=#0000ff>class</font> Linecolor[3] xPos[51] yPos[0] dim[73]
, <font color=#0000ff>class</font> Circlecolor[3] xPos[47] yPos[6] dim[49]
]

$ java CADState CADState.out
[<font color=#0000ff>class</font> Circlecolor[1] xPos[71] yPos[82] dim[44]
, <font color=#0000ff>class</font> Squarecolor[0] xPos[98] yPos[21] dim[49]
, <font color=#0000ff>class</font> Linecolor[3] xPos[16] yPos[80] dim[37]
, <font color=#0000ff>class</font> Circlecolor[1] xPos[51] yPos[74] dim[7]
, <font color=#0000ff>class</font> Squarecolor[0] xPos[7] yPos[78] dim[98]
, <font color=#0000ff>class</font> Linecolor[3] xPos[38] yPos[79] dim[93]
, <font color=#0000ff>class</font> Circlecolor[1] xPos[84] yPos[12] dim[62]
, <font color=#0000ff>class</font> Squarecolor[0] xPos[16] yPos[51] dim[94]
, <font color=#0000ff>class</font> Linecolor[3] xPos[51] yPos[0] dim[73]
, <font color=#0000ff>class</font> Circlecolor[1] xPos[47] yPos[6] dim[49]
]</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that the values of <b>xPos</b>, <b>yPos,</b> and <b>dim</b> were all stored and recovered successfully, but there&#146;s something wrong with the retrieval of the <b>static</b> information. It&#146;s all &#147;3&#148; going in, but it doesn&#146;t come out that way. <b>Circle</b>s have a value of 1 (<b>RED</b>, which is the definition), and <b>Square</b>s have a value of 0 (remember, they are initialized in the constructor). It&#146;s as if the <b>static</b>s didn&#146;t get serialized at all! That&#146;s right&#151;even though class <b>Class</b> is <b>Serializable</b>, it doesn&#146;t do what you expect. So if you want to serialize <b>statics</b>, you must do it yourself. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1770" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This is what the <b>serializeStaticState(&#160;) </b>and <b>deserializeStaticState(&#160;)</b> <b>static </b>methods in <b>Line</b> are for. You can see that they are explicitly called as part of the storage and retrieval process. (Note that the order of writing to the serialize file and reading back from it must be maintained.) Thus to make <b>CADState.java</b> run correctly, you must: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1771" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>Add a <b>serializeStaticState(&#160;)</b> and
<b>deserializeStaticState(&#160;)</b> to the shapes.</li>
<li>Remove the <b>ArrayList</b> <b>shapeTypes</b> and all code related to
it.</li>
<li>Add calls to the new serialize and deserialize static methods in the shapes.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1772"
title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>Another issue you might have to think about is security, since serialization also saves <b>private</b> data. If you have a security issue, those fields should be marked as <b>transient</b>. But then you have to design a secure way to store that information so that when you do a restore you can reset those <b>private</b> variables. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1773" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775823"></a><a name="Heading16176"></a>Preferences<br></h2>
<p><a name="Index1508"></a><a name="Index1509"></a>JDK 1.4 introduced the <i>Preferences </i>API, which is much closer to persistence than object serialization because it automatically stores and retrieves your information. However, its use is restricted to small and limited data sets&#151;you can only hold primitives and <b>Strings</b>, and the length of each stored <b>String</b> can&#146;t be longer than 8K (not tiny, but you don&#146;t want to build anything serious with it, either). As the name suggests, the Preferences API is designed to store and retrieve user preferences and program-configuration settings. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0648" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Preferences are key-value sets (like <b>Map</b>s) stored in a hierarchy of nodes. Although the node hierarchy can be used to create complicated structures, it&#146;s typical to create a single node named after your class and store the information there. Here&#146;s a simple example: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0649" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:PreferencesDemo.java</font>
<font color=#0000ff>import</font> java.util.prefs.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PreferencesDemo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    Preferences prefs = Preferences
      .userNodeForPackage(PreferencesDemo.<font color=#0000ff>class</font>);
    prefs.put(<font color=#004488>"Location"</font>, <font color=#004488>"Oz"</font>);
    prefs.put(<font color=#004488>"Footwear"</font>, <font color=#004488>"Ruby Slippers"</font>);
    prefs.putInt(<font color=#004488>"Companions"</font>, 4);
    prefs.putBoolean(<font color=#004488>"Are there witches?"</font>, <font color=#0000ff>true</font>);
    <font color=#0000ff>int</font> usageCount = prefs.getInt(<font color=#004488>"UsageCount"</font>, 0);
    usageCount++;
    prefs.putInt(<font color=#004488>"UsageCount"</font>, usageCount);
    Iterator it = Arrays.asList(prefs.keys()).iterator();
    <font color=#0000ff>while</font>(it.hasNext()) {
      String key = it.next().toString();
      System.out.println(key + <font color=#004488>": "</font>+ prefs.get(key, <font color=#0000ff>null</font>));
    }
    <font color=#009900>// You must always provide a default value:</font>
    System.out.println(
      <font color=#004488>"How many companions does Dorothy have? "</font> + 
      prefs.getInt(<font color=#004488>"Companions"</font>, 0));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Here, <a name="Index1510"></a><b>userNodeForPackage(&#160;)</b> is used, but you could also choose <a name="Index1511"></a><b>systemNodeForPackage(&#160;)</b>; the choice is somewhat arbitrary, but the idea is that &#147;user&#148; is for individual user preferences, and &#147;system&#148; is for general installation configuration. Since <b>main(&#160;)</b> is <b>static</b>, <b>PreferencesDemo.class</b> is used to identify the node, but inside a non-static method, you&#146;ll usually use <b>getClass(&#160;)</b>. You don&#146;t need to use the current class as the node identifier, but that&#146;s the usual practice. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0650" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once you create the node, it&#146;s available for either loading or reading data. This example loads the node with various types of items and then gets the <b>keys(&#160;)</b>. These come back as a <b>String[]</b>, which you might not expect if you&#146;re used to <b>keys(&#160;)</b> in the collections library. Here, they&#146;re converted to a <b>List</b> that is used to produce an <b>Iterator</b> for printing the keys and values. Notice the second argument to <b>get(&#160;)</b>. This is the default value that is produced if there isn&#146;t any entry for that key value. While iterating through a set of keys, you always know there&#146;s an entry, so using <b>null</b> as the default is safe, but normally you&#146;ll be fetching a named key, as in: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0651" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>prefs.getInt(<font color=#004488>"Companions"</font>, 0));</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>In the normal case, you&#146;ll want to provide a reasonable default value. In fact, a typical idiom is seen in the lines:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> usageCount = prefs.getInt(<font color=#004488>"UsageCount"</font>, 0);
usageCount++;
prefs.putInt(<font color=#004488>"UsageCount"</font>, usageCount);</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This way, the first time you run the program, the <b>UsageCount</b> will be zero, but on subsequent invocations it will be nonzero. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0652" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When you run <b>PreferencesDemo.java</b> you&#146;ll see that the <b>UsageCount</b> does indeed increment every time you run the program, but where is the data stored? There&#146;s no local file that appears after the program is run the first time. The Preferences API uses appropriate system resources to accomplish its task, and these will vary depending on the OS. In Windows, the registry is used (since it&#146;s already a hierarchy of nodes with key-value pairs). But the whole point is that the information is magically stored for you so that you don&#146;t have to worry about how it works from one system to another. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0653" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There&#146;s more to the Preferences API than shown here. Consult the JDK documentation, which is fairly understandable, for further details. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0654" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775824"></a><a name="Heading16218"></a>Regular expressions</h2>
<p>To finish this chapter, we&#146;ll look at <a name="Index1512"></a><a name="Index1513"></a><i>regular expressions</i>, which were added in JDK 1.4 but have been integral to standard Unix utilities like sed and awk, and languages like Python and Perl (some would argue that they are predominant reason for Perl&#146;s success). Technically, these are string manipulation tools (previously delegated to the <b>String</b>, <b>StringBuffer</b>, and <b>StringTokenizer</b> classes in Java), but they are typically used in conjunction with I/O, so it&#146;s not too far-fetched to include them here.<sup><a name="fnB66" href="#fn66">[66]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0605" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Regular expressions are powerful and flexible text-processing tools. They allow you to specify, programmatically, complex patterns of text that can be discovered in an input string. Once you discover these patterns, you can then react to them any way you want. Although the syntax of regular expressions can be intimidating at first, they provide a compact and dynamic language that can be employed to solve all sorts of string processing, matching and selection, editing, and verification problems in a completely general way. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0606" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775825"></a><a name="Heading16222"></a>Creating regular
expressions</h3>
<p>You can begin learning regular expressions with a useful subset of the possible constructs. A complete list of constructs for building regular expressions can be found in the javadocs for the <a name="Index1514"></a><b>Pattern</b> class for package <a name="Index1515"></a><b>java.util.regex</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0607" title="Send BackTalk Comment">Feedback</a></font><br></p>
<div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="431.999892" colspan="2" rowspan="1" valign="top">
<p class="Table" align="center"><b>Characters</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="89.333311" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>B</b><br></p>
</td>
<td width="341.333248" colspan="1" rowspan="1" valign="top">
<p class="Table">The specific character <b>B</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="89.333311" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\xhh</b><br></p>
</td>
<td width="341.333248" colspan="1" rowspan="1" valign="top">
<p class="Table">Character with hex value <b>0xhh</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="89.333311" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\uhhhh</b><br></p>
</td>
<td width="341.333248" colspan="1" rowspan="1" valign="top">
<p class="Table">The Unicode character with hex representation <b>0xhhhh</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="89.333311" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\t</b><br></p>
</td>
<td width="341.333248" colspan="1" rowspan="1" valign="top">
<p class="Table">Tab<br></p>
</td>
</tr>
<tr valign="top">
<td width="89.333311" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\n</b><br></p>
</td>
<td width="341.333248" colspan="1" rowspan="1" valign="top">
<p class="Table">Newline<br></p>
</td>
</tr>
<tr valign="top">
<td width="89.333311" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\r</b><br></p>
</td>
<td width="341.333248" colspan="1" rowspan="1" valign="top">
<p class="Table">Carriage return<br></p>
</td>
</tr>
<tr valign="top">
<td width="89.333311" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\f</b><br></p>
</td>
<td width="341.333248" colspan="1" rowspan="1" valign="top">
<p class="Table">Form feed<br></p>
</td>
</tr>
<tr valign="top">
<td width="89.333311" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\e</b><br></p>
</td>
<td width="341.333248" colspan="1" rowspan="1" valign="top">
<p class="Table">Escape<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">The power of regular expressions begins to appear when defining character classes. Here are some typical ways to create character classes, and some predefined classes: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0608" title="Send BackTalk Comment">Feedback</a></font><br></p>
<div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="443.999889" colspan="2" rowspan="1" valign="top">
<p class="Table" align="center"><b>Character Classes</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>.</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">Represents any character<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>[abc]</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">Any of the characters <b>a</b>, <b>b</b>, or <b>c</b> (same as <b>a|b|c</b>)<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>[^abc]</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">Any character except <b>a</b>, <b>b</b>, and <b>c</b> (negation)<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>[a-zA-Z]</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">Any character <b>a</b> through <b>z</b> or <b>A</b> through <b>Z</b> (range)<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>[abc[hij]]</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">Any of <b>a</b>,<b>b</b>,<b>c</b>,<b>h</b>,<b>i</b>,<b>j</b> (same as <b>a|b|c|h|i|j</b>) (union)<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>[a-z&amp;&amp;[hij]]</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">Either <b>h</b>, <b>i</b>, or <b>j</b> (intersection)<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\s</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">A whitespace character (space, tab, newline, formfeed, carriage return)<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\S</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">A non-whitespace character (<b>[^\s]</b>)<br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\d</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">A numeric digit <b>[0-9]</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\D</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">A non-digit <b>[^0-9]</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\w</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">A word character <b>[a-zA-Z_0-9]</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="131.999967" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\W</b><br></p>
</td>
<td width="311.999922" colspan="1" rowspan="1" valign="top">
<p class="Table">A non-word character <b>[^\w]</b><br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">If you have any experience with regular expressions in other languages, you&#146;ll immediately notice a difference in the way backslashes are handled. In other languages, &#147;<b>\\</b>&#148; means &#147;I want to insert a plain old (literal) backslash in the regular expression. Don&#146;t give it any special meaning.&#148; In Java, &#147;<b>\\</b>&#148; means &#147;I&#146;m inserting a regular expression backslash, so the following character has special meaning.&#148; For example, if you want to indicate one or more word characters, your regular expression string will be &#147;<b>\\w+</b>&#148;. If you want to insert a literal backslash, you say &#147;<b>\\\\</b>&#148;. However, things like newlines and tabs just use a single backslash: &#147;\n\t&#148;. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0609" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>What&#146;s shown here is only a sampling; you&#146;ll want to have the <b>java.util.regex.Pattern</b> JDK documentation page bookmarked or on your &#147;Start&#148; menu so you can easily access all the possible regular expression patterns. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0610" title="Send BackTalk Comment">Feedback</a></font><br></p>
<div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="467.999883" colspan="2" rowspan="1" valign="top">
<p class="Table" align="center"><b>Logical Operators</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="167.999958" colspan="1" rowspan="1" valign="top">
<p class="Table">XY<br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p class="Table">X followed by Y<br></p>
</td>
</tr>
<tr valign="top">
<td width="167.999958" colspan="1" rowspan="1" valign="top">
<p class="Table">X|Y<br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p class="Table">X or Y<br></p>
</td>
</tr>
<tr valign="top">
<td width="167.999958" colspan="1" rowspan="1" valign="top">
<p class="Table">(X)<br></p>
</td>
<td width="299.999925" colspan="1" rowspan="1" valign="top">
<p class="Table">A <i>capturing group</i>. You can refer to the <i>i<sup>th</sup></i><b> </b>captured group later in the expression with \i<br></p>
</td>
</tr>
</table></div>
<p><br></p>
<div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="383.999904" colspan="2" rowspan="1" valign="top">
<p class="Table" align="center"><b>Boundary Matchers</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>^</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Beginning of a line<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>$</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">End of a line<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\b</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Word boundary<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\B</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">Non-word boundary<br></p>
</td>
</tr>
<tr valign="top">
<td width="143.999964" colspan="1" rowspan="1" valign="top">
<p class="Table"><b>\G</b><br></p>
</td>
<td width="239.999940" colspan="1" rowspan="1" valign="top">
<p class="Table">End of the previous match<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">As an example, each of the following represent valid regular expressions, and all will successfully match the character sequence "Rudolph":<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Rudolph
[rR]udolph
[rR][aeiou][a-z]ol.*
R.*</PRE></FONT></BLOCKQUOTE><p><br></p>
<h3>
<a name="_Toc24775826"></a><a name="Heading16294"></a>Quantifiers</h3>
<p>A <a name="Index1516"></a><i>quantifier</i> describes the way that a pattern absorbs input text:<br></p>
<ul>
<li><a name="Index1517"></a><a name="Index1518"></a><i>Greedy</i>: Quantifiers
are greedy unless otherwise altered. A greedy expression finds as many possible
matches for the pattern as possible. A typical cause of problems is to assume
that your pattern will only match the first possible group of characters, when
it&#146;s actually greedy and will keep going. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0611" title="Send BackTalk
Comment">Feedback</a></font></li>
<li><a name="Index1519"></a><a name="Index1520"></a><i>Reluctant</i>: Specified
with a question mark, this quantifier matches the minimum necessary number of
characters to satisfy the pattern. Also called <i>lazy</i>, <i>minimal
matching</i>, <i>non-greedy</i>,<i> </i>or <i>ungreedy</i>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0612" title="Send BackTalk
Comment">Feedback</a></font></li>
<li><a name="Index1521"></a><a name="Index1522"></a><i>Possessive</i>: Currently
only available in Java (not in other languages), and it is more advanced, so you
probably won&#146;t use it right away. As a regular expression is applied to a
string, it generates many states so that it can backtrack if the match fails.
Possessive quantifiers do not keep those intermediate states, and thus prevent
backtracking. They can be used to prevent a regular expression from running away
and also to make it execute more efficiently. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0613" title="Send BackTalk
Comment">Feedback</a></font></li></ul><div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p><b>Greedy</b><br></p>
</td>
<td width="86.666645" colspan="1" rowspan="1" valign="top">
<p><b>Reluctant</b><br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p><b>Possessive</b><br></p>
</td>
<td width="231.999942" colspan="1" rowspan="1" valign="top">
<p><b>Matches</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p>X?<br></p>
</td>
<td width="86.666645" colspan="1" rowspan="1" valign="top">
<p>X??<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p>X?+<br></p>
</td>
<td width="231.999942" colspan="1" rowspan="1" valign="top">
<p>X, one or none<br></p>
</td>
</tr>
<tr valign="top">
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p>X*<br></p>
</td>
<td width="86.666645" colspan="1" rowspan="1" valign="top">
<p>X*?<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p>X*+<br></p>
</td>
<td width="231.999942" colspan="1" rowspan="1" valign="top">
<p>X, zero or more<br></p>
</td>
</tr>
<tr valign="top">
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p>X+<br></p>
</td>
<td width="86.666645" colspan="1" rowspan="1" valign="top">
<p>X+?<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p>X++<br></p>
</td>
<td width="231.999942" colspan="1" rowspan="1" valign="top">
<p>X, one or more<br></p>
</td>
</tr>
<tr valign="top">
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p>X{n}<br></p>
</td>
<td width="86.666645" colspan="1" rowspan="1" valign="top">
<p>X{n}?<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p>X{n}+<br></p>
</td>
<td width="231.999942" colspan="1" rowspan="1" valign="top">
<p>X, exactly n times<br></p>
</td>
</tr>
<tr valign="top">
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p>X{n,}<br></p>
</td>
<td width="86.666645" colspan="1" rowspan="1" valign="top">
<p>X{n,}?<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p>X{n,}+<br></p>
</td>
<td width="231.999942" colspan="1" rowspan="1" valign="top">
<p>X, at least n times<br></p>
</td>
</tr>
<tr valign="top">
<td width="71.999982" colspan="1" rowspan="1" valign="top">
<p>X{n,m}<br></p>
</td>
<td width="86.666645" colspan="1" rowspan="1" valign="top">
<p>X{n,m}?<br></p>
</td>
<td width="93.333310" colspan="1" rowspan="1" valign="top">
<p>X{n,m}+<br></p>
</td>
<td width="231.999942" colspan="1" rowspan="1" valign="top">
<p>X, at least n but not more than m times<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">You should be very aware that the expression &#145;X&#146; will often need to be surrounded in parentheses for it to work the way you desire. For example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>abc+</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Might seem like it would match the sequence &#145;abc&#146; one or more times, and if you apply it to the input string &#145;abcabcabc&#146;, you will in fact get three matches. However, the expression <i>actually</i> says &#147;match &#145;ab&#146; followed by one or more occurrences of &#145;c&#146;.&#148; To match the entire string &#145;abc&#146; one or more times, you must say:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(abc)+</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can easily be fooled when using regular expressions; it&#146;s a new language, on top of Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0614" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading16334"></a>CharSequence</h4>
<p>JDK 1.4 defines a new interface called <a name="Index1523"></a><b>CharSequence</b>, which establishes a definition of a character sequence abstracted from the <b>String</b> or <b>StringBuffer</b> classes:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>interface</font> CharSequence {
  charAt(<font color=#0000ff>int</font> i);
  length();
  subSequence(<font color=#0000ff>int</font> start, <font color=#0000ff>int</font> end);
  toString();
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>String</b>, <b>StringBuffer</b>, and <b>CharBuffer</b> classes have been modified to implement this new <b>CharSequence</b> interface. Many regular expression operations take <b>CharSequence</b> arguments. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0615" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775827"></a><a name="Heading16344"></a>Pattern and Matcher</h3>
<p>As a first example, the following class can be used to test regular expressions against an input string. The first argument is the input string to match against, followed by one or more regular expressions to be applied to the input. Under Unix/Linux, the regular expressions must be quoted on the command line. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0616" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This program can be useful in testing regular expressions as you construct them to see that they produce your intended matching behavior.<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:TestRegularExpression.java</font>
<font color=#009900>// Allows you to easly try out regular expressions.</font>
<font color=#009900>// {Args: abcabcabcdefabc "abc+" "(abc)+" "(abc){2,}" }</font>
<font color=#0000ff>import</font> java.util.regex.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestRegularExpression {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 2) {
      System.out.println(<font color=#004488>"Usage:\n"</font> +
        <font color=#004488>"java TestRegularExpression "</font> +
        <font color=#004488>"characterSequence regularExpression+"</font>);
      System.exit(0);
    }
    System.out.println(<font color=#004488>"Input: \"</font><font color=#004488>" + args[0] + "</font>\<font color=#004488>""</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 1; i &lt; args.length; i++) {
      System.out.println(
        <font color=#004488>"Regular expression: \"</font><font color=#004488>" + args[i] + "</font>\<font color=#004488>""</font>);
      Pattern p = Pattern.compile(args[i]);
      Matcher m = p.matcher(args[0]);
      <font color=#0000ff>while</font>(m.find()) {
        System.out.println(<font color=#004488>"Match \"</font>" + m.group() +
          <font color=#004488>"\"</font> at positions " +
          m.start() + <font color=#004488>"-"</font> + (m.end() - 1));
      }
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Regular expressions are implemented in Java through the <b>Pattern</b> and <a name="Index1524"></a><b>Matcher</b> classes in the package <b>java.util.regex</b>. A <b>Pattern</b> object represents a compiled version of a regular expression. The static <b>compile(&#160;)</b> method compiles a regular expression string into a <b>Pattern</b> object. As seen in the preceding example, you can use the <b>matcher(&#160;) </b>method and the input string to produce a <b>Matcher</b> object from the compiled <b>Pattern</b> object. <b>Pattern</b> also has a <br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>static</font> <font color=#0000ff>boolean</font> (&#160;regex, &#160;input)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>for quickly discerning if <b>regex</b> can be found in <b>input</b>, and a <b>split(&#160;)</b> method that produces an array of <b>String</b> that has been broken around matches of the <b>regex</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0617" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A <b>Matcher</b> object is generated by calling <b>Pattern.matcher(&#160;)</b> with the input string as an argument. The <b>Matcher </b>object is then used to access the results, using methods to evaluate the success or failure of different types of matches:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>boolean</font> matches()
<font color=#0000ff>boolean</font> lookingAt()
<font color=#0000ff>boolean</font> find()
<font color=#0000ff>boolean</font> find(<font color=#0000ff>int</font> start)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>matches(&#160;)</b> method is successful if the pattern matches the entire input string, while <b>lookingAt(&#160;) </b>is successful if the input string, starting at the beginning, is a match to the pattern. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0620" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading16386"></a>find(&#160;)</h4>
<p><b>Matcher.find(&#160;)</b> can be used to discover multiple pattern matches in the <b>CharSequence</b> to which it is applied. For example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:FindDemo.java</font>
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FindDemo {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Matcher m = Pattern.compile(<font color=#004488>"\\w+"</font>)
      .matcher(<font color=#004488>"Evening is full of the linnet's wings"</font>);
    <font color=#0000ff>while</font>(m.find())
      System.out.println(m.group());
    <font color=#0000ff>int</font> i = 0;
    <font color=#0000ff>while</font>(m.find(i)) {
      System.out.print(m.group() + <font color=#004488>" "</font>);
      i++;
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Evening"</font>,
      <font color=#004488>"is"</font>,
      <font color=#004488>"full"</font>,
      <font color=#004488>"of"</font>,
      <font color=#004488>"the"</font>,
      <font color=#004488>"linnet"</font>,
      <font color=#004488>"s"</font>,
      <font color=#004488>"wings"</font>,
      <font color=#004488>"Evening vening ening ning ing ng g is is s full "</font> +
      <font color=#004488>"full ull ll l of of f the the he e linnet linnet "</font> +
      <font color=#004488>"innet nnet net et t s s wings wings ings ngs gs s "</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The pattern &#147;<b>\\w+</b>&#148; indicates &#147;one or more word characters,&#148; so it will simply split up the input into words. <b>find(&#160;)</b> is like an iterator, moving forward through the input string. However, the second version of <b>find(&#160;)</b> can be given an integer argument that tells it the character position for the beginning of the search&#151;this version resets the search position to the value of the argument, as you can see from the output. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0621" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading16422"></a>Groups<br></h4>
<p><a name="Index1525"></a>Groups are regular expressions set off by parentheses that can be called up later with their group number. Group zero indicates the whole expression match, group one is the first parenthesized group, etc. Thus in<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>A(B(C))D</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>there are three groups: Group 0 is <b>ABCD</b>, group 1 is <b>BC</b>, and group 2 is <b>C</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0622" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>Matcher</b> object has methods to give you information about groups:<br></p>
<p><b>public int groupCount(&#160;)</b> returns the number of groups in this matcher's pattern. Group zero is not included in this count.<br></p>
<p><b>public String group(&#160;)</b> returns group zero (the entire match) from the previous match operation (<b>find(&#160;)</b>, for example).<br></p>
<p><b>public String group(int i)</b> returns the given group number during the previous match operation. If the match was successful, but the group specified failed to match any part of the input string, then null is returned.<br></p>
<p><b>public int start(int group)</b> returns the start index of the group found in the previous match operation.<br></p>
<p><b>public int end(int group)</b> returns the index of the last character, plus one, of the group found in the previous match operation. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0623" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example of regular expression groups:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Groups.java</font>
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Groups {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>static</font> <font color=#0000ff>public</font> <font color=#0000ff>final</font> String poem =
    <font color=#004488>"Twas brillig, and the slithy toves\n"</font> +
    <font color=#004488>"Did gyre and gimble in the wabe.\n"</font> +
    <font color=#004488>"All mimsy were the borogoves,\n"</font> +
    <font color=#004488>"And the mome raths outgrabe.\n\n"</font> +
    <font color=#004488>"Beware the Jabberwock, my son,\n"</font> +
    <font color=#004488>"The jaws that bite, the claws that catch.\n"</font> +
    <font color=#004488>"Beware the Jubjub bird, and shun\n"</font> +
    <font color=#004488>"The frumious Bandersnatch."</font>;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Matcher m =
      Pattern.compile(<font color=#004488>"(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$"</font>)
        .matcher(poem);
    <font color=#0000ff>while</font>(m.find()) {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt;= m.groupCount(); j++)
        System.out.print(<font color=#004488>"["</font> + m.group(j) + <font color=#004488>"]"</font>);
      System.out.println();
    }
    monitor.expect(<font color=#0000ff>new</font> String[]{
      <font color=#004488>"[the slithy toves]"</font> +
      <font color=#004488>"[the][slithy toves][slithy][toves]"</font>,
      <font color=#004488>"[in the wabe.][in][the wabe.][the][wabe.]"</font>,
      <font color=#004488>"[were the borogoves,]"</font> +
      <font color=#004488>"[were][the borogoves,][the][borogoves,]"</font>,
      <font color=#004488>"[mome raths outgrabe.]"</font> +
      <font color=#004488>"[mome][raths outgrabe.][raths][outgrabe.]"</font>,
      <font color=#004488>"[Jabberwock, my son,]"</font> +
      <font color=#004488>"[Jabberwock,][my son,][my][son,]"</font>,
      <font color=#004488>"[claws that catch.]"</font> +
      <font color=#004488>"[claws][that catch.][that][catch.]"</font>,
      <font color=#004488>"[bird, and shun][bird,][and shun][and][shun]"</font>,
      <font color=#004488>"[The frumious Bandersnatch.][The]"</font> +
      <font color=#004488>"[frumious Bandersnatch.][frumious][Bandersnatch.]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The poem is the first part of Lewis Carroll&#146;s &#147;Jabberwocky,&#148; from <i>Through the Looking Glass</i>. You can see that the regular expression pattern has a number of parenthesized groups, consisting of any number of non-whitespace characters (&#145;<b>\S+</b>&#146;) followed by any number of whitespace characters (&#145;<b>\s+</b>&#146;). The goal is to capture the last three words on each line; the end of a line is delimited by &#145;<b>$</b>&#146;. However, the normal behavior is to match &#145;<b>$</b>&#146; with the end of the entire input sequence, so we must explicitly tell the regular expression to pay attention to newlines within the input. This is accomplished with the &#145;<b>(?m)</b>&#146; pattern flag at the beginning of the sequence (pattern flags will be shown shortly). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0624" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading16478"></a>start(&#160;) and end(&#160;)</h4>
<p>Following a successful matching operation, <b>start(&#160;)</b> returns the start index of the previous match, and <b>end(&#160;) </b>returns the index of the last character matched, plus one. Invoking either <b>start(&#160;)</b> or <b>end(&#160;)</b> following an unsuccessful matching operation (or prior to a matching operation being attempted) produces an <b>IllegalStateException</b>. The following program also demonstrates <b>matches(&#160;)</b> and <b>lookingAt(&#160;)</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0625" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:StartEnd.java</font>
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StartEnd {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] input = <font color=#0000ff>new</font> String[] {
      <font color=#004488>"Java has regular expressions in 1.4"</font>,
      <font color=#004488>"regular expressions now expressing in Java"</font>,
      <font color=#004488>"Java represses oracular expressions"</font>
    };
    Pattern
      p1 = Pattern.compile(<font color=#004488>"re\\w*"</font>),
      p2 = Pattern.compile(<font color=#004488>"Java.*"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; input.length; i++) {
      System.out.println(<font color=#004488>"input "</font> + i + <font color=#004488>": "</font> + input[i]);
      Matcher
        m1 = p1.matcher(input[i]),
        m2 = p2.matcher(input[i]);
      <font color=#0000ff>while</font>(m1.find())
        System.out.println(<font color=#004488>"m1.find() '"</font> + m1.group() +
          <font color=#004488>"' start = "</font>+ m1.start() + <font color=#004488>" end = "</font> + m1.end());
      <font color=#0000ff>while</font>(m2.find())
        System.out.println(<font color=#004488>"m2.find() '"</font> + m2.group() +
          <font color=#004488>"' start = "</font>+ m2.start() + <font color=#004488>" end = "</font> + m2.end());
      <font color=#0000ff>if</font>(m1.lookingAt()) <font color=#009900>// No reset() necessary</font>
        System.out.println(<font color=#004488>"m1.lookingAt() start = "</font>
          + m1.start() + <font color=#004488>" end = "</font> + m1.end());
      <font color=#0000ff>if</font>(m2.lookingAt())
        System.out.println(<font color=#004488>"m2.lookingAt() start = "</font>
          + m2.start() + <font color=#004488>" end = "</font> + m2.end());
      <font color=#0000ff>if</font>(m1.matches()) <font color=#009900>// No reset() necessary</font>
        System.out.println(<font color=#004488>"m1.matches() start = "</font>
          + m1.start() + <font color=#004488>" end = "</font> + m1.end());
      <font color=#0000ff>if</font>(m2.matches())
        System.out.println(<font color=#004488>"m2.matches() start = "</font>
          + m2.start() + <font color=#004488>" end = "</font> + m2.end());
    }
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"input 0: Java has regular expressions in 1.4"</font>,
      <font color=#004488>"m1.find() 'regular' start = 9 end = 16"</font>,
      <font color=#004488>"m1.find() 'ressions' start = 20 end = 28"</font>,
      <font color=#004488>"m2.find() 'Java has regular expressions in 1.4'"</font> +
      <font color=#004488>" start = 0 end = 35"</font>,
      <font color=#004488>"m2.lookingAt() start = 0 end = 35"</font>,
      <font color=#004488>"m2.matches() start = 0 end = 35"</font>,
      <font color=#004488>"input 1: regular expressions now "</font> +
      <font color=#004488>"expressing in Java"</font>,
      <font color=#004488>"m1.find() 'regular' start = 0 end = 7"</font>,
      <font color=#004488>"m1.find() 'ressions' start = 11 end = 19"</font>,
      <font color=#004488>"m1.find() 'ressing' start = 27 end = 34"</font>,
      <font color=#004488>"m2.find() 'Java' start = 38 end = 42"</font>,
      <font color=#004488>"m1.lookingAt() start = 0 end = 7"</font>,
      <font color=#004488>"input 2: Java represses oracular expressions"</font>,
      <font color=#004488>"m1.find() 'represses' start = 5 end = 14"</font>,
      <font color=#004488>"m1.find() 'ressions' start = 27 end = 35"</font>,
      <font color=#004488>"m2.find() 'Java represses oracular expressions' "</font> +
      <font color=#004488>"start = 0 end = 35"</font>,
      <font color=#004488>"m2.lookingAt() start = 0 end = 35"</font>,
      <font color=#004488>"m2.matches() start = 0 end = 35"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Notice that <b>find(&#160;)</b> will locate the regular expression anywhere in the input, but <b>lookingAt(&#160;)</b> and <b>matches(&#160;)</b> only succeed if the regular expression starts matching at the very beginning of the input. While <b>matches(&#160;)</b> only succeeds if the <i>entire</i> input matches the regular expression, <b>lookingAt(&#160;)<sup><a name="fnB67" href="#fn67">[67]</a></sup></b> succeeds if only the first part of the input matches. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0626" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading16547"></a>Pattern flags</h4>
<p>An alternative <b>compile(&#160;)</b> method accepts flags that affect the behavior of regular expression matching:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Pattern Pattern.compile(String regex, <font color=#0000ff>int</font> flag)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>where <b>flag</b> is drawn from among the following <b>Pattern</b> class constants:<br></p>
<div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="227.999943" colspan="1" rowspan="1" valign="top">
<p><b>Compile Flag</b><br></p>
</td>
<td width="258.666602" colspan="1" rowspan="1" valign="top">
<p><b>Effect</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="227.999943" colspan="1" rowspan="1" valign="top">
<p><b>Pattern.CANON_EQ</b><br></p>
</td>
<td width="258.666602" colspan="1" rowspan="1" valign="top">
<p>Two characters will be considered to match if, and only if, their full canonical decompositions match. The expression &#147;a\u030A&#148;, for example, will match the string &#147;?&#148; when this flag is specified. By default, matching does not take canonical equivalence into account.<br></p>
</td>
</tr>
<tr valign="top">
<td width="227.999943" colspan="1" rowspan="1" valign="top">
<p><b>Pattern.CASE_INSENSITIVE</b><br><b>(?i)</b><br></p>
</td>
<td width="258.666602" colspan="1" rowspan="1" valign="top">
<p>By default, case-insensitive matching assumes that only characters in the US-ASCII character set are being matched. This flag allows your pattern to match without regard to case (upper or lower). Unicode-aware case-insensitive matching can be enabled by specifying the <b>UNICODE_CASE</b> flag in conjunction with this flag.<br></p>
</td>
</tr>
<tr valign="top">
<td width="227.999943" colspan="1" rowspan="1" valign="top">
<p><b>Pattern.COMMENTS</b><br><b>(?x)</b><br></p>
</td>
<td width="258.666602" colspan="1" rowspan="1" valign="top">
<p>In this mode, whitespace is ignored, and embedded comments starting with # are ignored until the end of a line. Unix lines mode can also be enabled via the embedded flag expression.<br></p>
</td>
</tr>
<tr valign="top">
<td width="227.999943" colspan="1" rowspan="1" valign="top">
<p><b>Pattern.DOTALL</b><br><b>(?s)</b><br></p>
</td>
<td width="258.666602" colspan="1" rowspan="1" valign="top">
<p>In dotall mode, the expression &#145;<b>.</b>&#146; matches any character, including a line terminator. By default, the &#145;<b>.</b>&#146; expression does not match line terminators.<br></p>
</td>
</tr>
<tr valign="top">
<td width="227.999943" colspan="1" rowspan="1" valign="top">
<p><b>Pattern.MULTILINE</b><br><b>(?m)</b><br></p>
</td>
<td width="258.666602" colspan="1" rowspan="1" valign="top">
<p>In multiline mode, the expressions &#145;<b>^</b>&#146; and &#145;<b>$</b>&#146; match the beginning and ending of a line, respectively. &#145;<b>^</b>&#146; also matches the beginning of the input string, and &#145;<b>$</b>&#146; also matches the end of the input string. By default, these expressions only match at the beginning and the end of the entire input string.<br></p>
</td>
</tr>
<tr valign="top">
<td width="227.999943" colspan="1" rowspan="1" valign="top">
<p><b>Pattern.UNICODE_CASE</b><br><b>(?u)</b><br></p>
</td>
<td width="258.666602" colspan="1" rowspan="1" valign="top">
<p>When this flag is specified, case-insensitive matching, when enabled by the <b>CASE_INSENSITIVE</b> flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII character set are being matched.<br></p>
</td>
</tr>
<tr valign="top">
<td width="227.999943" colspan="1" rowspan="1" valign="top">
<p><b>Pattern.UNIX_LINES</b><br><b>(?d)</b><br></p>
</td>
<td width="258.666602" colspan="1" rowspan="1" valign="top">
<p>In this mode, only the &#145;<b>\n</b>&#146; line terminator is recognized in the behavior of &#145;<b>.</b>&#146;, &#145;<b>^</b>&#146;, and &#145;<b>$</b>&#146;.<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">Particularly useful among these flags are <b>Pattern.CASE_INSENSITIVE</b>, <b>Pattern.MULTILINE</b>, and <b>Pattern.COMMENTS</b> (which is helpful for clarity and/or documentation). Note that the behavior of most of the flags can also be obtained by inserting the parenthesized characters, shown in the table beneath the flags, into your regular expression preceding the place where you want the mode to take effect. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0627" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can combine the effect of these and other flags through an "OR" (&#145;<b>|</b>&#146;) operation:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:ReFlags.java</font>
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ReFlags {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Pattern p =  Pattern.compile(<font color=#004488>"^java"</font>,
      Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
    Matcher m = p.matcher(
      <font color=#004488>"java has regex\nJava has regex\n"</font> +
      <font color=#004488>"JAVA has pretty good regular expressions\n"</font> +
      <font color=#004488>"Regular expressions are in Java"</font>);
    <font color=#0000ff>while</font>(m.find())
      System.out.println(m.group());
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"java"</font>,
      <font color=#004488>"Java"</font>,
      <font color=#004488>"JAVA"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This creates a pattern that will match lines starting with &#147;java,&#148; &#147;Java,&#148; &#147;JAVA,&#148; etc., and attempt a match for each line within a multiline set (matches starting at the beginning of the character sequence and following each line terminator within the character sequence). Note that the <b>group(&#160;)</b> method only produces the matched portion. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0628" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775828"></a><a name="Heading16594"></a>split(&#160;)</h3>
<p>Splitting divides an input string into an array of <b>String</b> objects, delimited by the regular expression.<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>String[] split(CharSequence charseq)
String[] split(CharSequence charseq, <font color=#0000ff>int</font> limit)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This is a quick and handy way of breaking up input text over a common boundary:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:SplitDemo.java</font>
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SplitDemo {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String input =
      <font color=#004488>"This!!unusual use!!of exclamation!!points"</font>;
    System.out.println(Arrays.asList(
      Pattern.compile(<font color=#004488>"!!"</font>).split(input)));
    <font color=#009900>// Only do the first three:</font>
    System.out.println(Arrays.asList(
      Pattern.compile(<font color=#004488>"!!"</font>).split(input, 3)));
    System.out.println(Arrays.asList(
      <font color=#004488>"Aha! String has a split() built in!"</font>.split(<font color=#004488>" "</font>)));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"[This, unusual use, of exclamation, points]"</font>,
      <font color=#004488>"[This, unusual use, of exclamation!!points]"</font>,
      <font color=#004488>"[Aha!, String, has, a, split(), built, in!]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The second form of <b>split(&#160;)</b> limits the number of splits that occur. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0629" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Notice that regular expressions are so valuable that some operations have also been added to the <b>String</b> class, including <b>split(&#160;)</b> (shown here), <b>matches(&#160;)</b>, <b>replaceFirst(&#160;)</b>, and <b>replaceAll(&#160;)</b>. These behave like their <b>Pattern</b> and <b>Matcher</b> counterparts. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0630" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775829"></a><a name="Heading16627"></a>Replace operations</h3>
<p>Regular expressions become especially useful when you begin replacing text. Here are the available methods:<br></p>
<p><b>replaceFirst(String replacement)</b> replaces the first matching part of the input string with <b>replacement</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0631" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>replaceAll(String replacement)</b> replaces every matching part of the input string with <b>replacement</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0632" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>appendReplacement(StringBuffer sbuf, String replacement)</b> performs step-by-step replacements into <b>sbuf</b>, rather than replacing only the first one or all of them, as in <b>replaceFirst(&#160;)</b> and <b>replaceAll(&#160;)</b>, respectively. This is a <i>very</i> important method, because it allows you to call methods and perform other processing in order to produce <b>replacement</b> (<b>replaceFirst(&#160;)</b> and <b>replaceAll(&#160;)</b> are only able to put in fixed strings). With this method, you can programmatically pick apart the groups and create powerful replacements. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0633" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>appendTail(StringBuffer sbuf, String replacement)</b> is invoked after one or more invocations of the <b>appendReplacement(&#160;)</b> method in order to copy the remainder of the input string. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0634" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example that shows the use of all the replace operations. In addition, the block of commented text at the beginning is extracted and processed with regular expressions for use as input in the rest of the example:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:TheReplacements.java</font>
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#009900>/*! Here's a block of text to use as input to
    the regular expression matcher. Note that we'll
    first extract the block of text by looking for
    the special delimiters, then process the
    extracted block. !*/</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TheReplacements {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    String s = TextFile.read(<font color=#004488>"TheReplacements.java"</font>);
    <font color=#009900>// Match the specially-commented block of text above:</font>
    Matcher mInput =
      Pattern.compile(<font color=#004488>"</font><font color=#004488>/\\*!(.*)!\\*</font><font color=#004488>/"</font>, Pattern.DOTALL)
        .matcher(s);
    <font color=#0000ff>if</font>(mInput.find())
      s = mInput.group(1); <font color=#009900>// Captured by parentheses</font>
    <font color=#009900>// Replace two or more spaces with a single space:</font>
    s = s.replaceAll(<font color=#004488>" {2,}"</font>, <font color=#004488>" "</font>);
    <font color=#009900>// Replace one or more spaces at the beginning of each</font>
    <font color=#009900>// line with no spaces. Must enable MULTILINE mode:</font>
    s = s.replaceAll(<font color=#004488>"(?m)^ +"</font>, <font color=#004488>""</font>);
    System.out.println(s);
    s = s.replaceFirst(<font color=#004488>"[aeiou]"</font>, <font color=#004488>"(VOWEL1)"</font>);
    StringBuffer sbuf = <font color=#0000ff>new</font> StringBuffer();
    Pattern p = Pattern.compile(<font color=#004488>"[aeiou]"</font>);
    Matcher m = p.matcher(s);
    <font color=#009900>// Process the find information as you</font>
    <font color=#009900>// perform the replacements:</font>
    <font color=#0000ff>while</font>(m.find())
      m.appendReplacement(sbuf, m.group().toUpperCase());
    <font color=#009900>// Put in the remainder of the text:</font>
    m.appendTail(sbuf);
    System.out.println(sbuf);
    monitor.expect(<font color=#0000ff>new</font> String[]{
      <font color=#004488>"Here's a block of text to use as input to"</font>,
      <font color=#004488>"the regular expression matcher. Note that we'll"</font>,
      <font color=#004488>"first extract the block of text by looking for"</font>,
      <font color=#004488>"the special delimiters, then process the"</font>,
      <font color=#004488>"extracted block. "</font>,
      <font color=#004488>"H(VOWEL1)rE's A blOck Of tExt tO UsE As InpUt tO"</font>,
      <font color=#004488>"thE rEgUlAr ExprEssIOn mAtchEr. NOtE thAt wE'll"</font>,
      <font color=#004488>"fIrst ExtrAct thE blOck Of tExt by lOOkIng fOr"</font>,
      <font color=#004488>"thE spEcIAl dElImItErs, thEn prOcEss thE"</font>,
      <font color=#004488>"ExtrActEd blOck. "</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The file is opened and read using the <b>TextFile.read(&#160;)</b> method introduced earlier in this chapter. <b>mInput</b> is created to match all the text (notice the grouping parentheses) between &#145;<b>/*!</b>&#146; and &#145;<b>!*/</b>&#146;. Then, more than two spaces are reduced to a single space, and any space at the beginning of each line is removed (in order to do this on all lines and not just the beginning of the input, multiline mode must be enabled). These two replacements are performed with the equivalent (but more convenient, in this case) <b>replaceAll(&#160;)</b> that&#146;s part of <b>String</b>. Note that since each replacement is only used once in the program, there&#146;s no extra cost to doing it this way rather than precompiling it as a <b>Pattern</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0635" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>replaceFirst(&#160;)</b> only performs the first replacement that it finds. In addition, the replacement strings in <b>replaceFirst(&#160;)</b> and <b>replaceAll(&#160;)</b> are just literals, so if you want to perform some processing on each replacement they don&#146;t help. In that case, you need to use <b>appendReplacement(&#160;)</b>, which allows you to write any amount of code in the process of performing the replacement. In the preceding example, a <b>group(&#160;)</b> is selected and processed&#151;in this situation, setting the vowel found by the regular expression to upper case&#151;as the resulting <b>sbuf</b> is being built. Normally, you would step through and perform all the replacements and then call <b>appendTail(&#160;)</b>, but if you wanted to simulate <b>replaceFirst(&#160;)</b> (or &#147;replace n&#148;), you would just do the replacement one time and then call <b>appendTail(&#160;)</b> to put the rest into <b>sbuf</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0636" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>appendReplacement(&#160;)</b> also allows you to refer to captured groups directly in the replacement string by saying &#147;$g&#148; where &#145;g&#146; is the group number. However, this is for simpler processing and wouldn&#146;t give you the desired results in the preceding program. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0637" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775830"></a><a name="Heading16691"></a>reset(&#160;)</h3>
<p>An existing <b>Matcher</b> object can be applied to a new character sequence Using the <b>reset(&#160;)</b> methods:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:Resetting.java</font>
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Resetting {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    Matcher m = Pattern.compile(<font color=#004488>"[frb][aiu][gx]"</font>)
      .matcher(<font color=#004488>"fix the rug with bags"</font>);
    <font color=#0000ff>while</font>(m.find())
      System.out.println(m.group());
    m.reset(<font color=#004488>"fix the rig with rags"</font>);
    <font color=#0000ff>while</font>(m.find())
      System.out.println(m.group());
    monitor.expect(<font color=#0000ff>new</font> String[]{
      <font color=#004488>"fix"</font>,
      <font color=#004488>"rug"</font>,
      <font color=#004488>"bag"</font>,
      <font color=#004488>"fix"</font>,
      <font color=#004488>"rig"</font>,
      <font color=#004488>"rag"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>reset(&#160;)</b> without any arguments sets the <b>Matcher</b> to the beginning of the current sequence. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0638" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775831"></a><a name="Heading16720"></a>Regular expressions and
Java I/O</h3>
<p>Most of the examples so far have shown regular expressions applied to static strings. The following example shows one way to apply regular expressions to search for matches in a file. Inspired by Unix&#146;s <i>grep</i>, <b>JGrep.java</b> takes two arguments: a filename and the regular expression that you want to match. The output shows each line where a match occurs and the match position(s) within the line. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0639" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:JGrep.java</font>
<font color=#009900>// A very simple version of the "grep" program.</font>
<font color=#009900>// {Args: JGrep.java "\\b[Ssct]\\w+"}</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> JGrep {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    <font color=#0000ff>if</font>(args.length &lt; 2) {
      System.out.println(<font color=#004488>"Usage: java JGrep file regex"</font>);
      System.exit(0);
    }
    Pattern p = Pattern.compile(args[1]);
    <font color=#009900>// Iterate through the lines of the input file:</font>
    ListIterator it = <font color=#0000ff>new</font> TextFile(args[0]).listIterator();
    <font color=#0000ff>while</font>(it.hasNext()) {
      Matcher m = p.matcher((String)it.next());
      <font color=#0000ff>while</font>(m.find())
        System.out.println(it.nextIndex() + <font color=#004488>": "</font> +
          m.group() + <font color=#004488>": "</font> + m.start());
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The file is opened as a <b>TextFile </b>object (these were introduced earlier in this chapter). Since a <b>TextFile</b> contains the lines of the file in an <b>ArrayList</b>, from that array a <b>ListIterator</b> is produced. The result is an iterator that will allow you to move through the lines of the file (forward and backward). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0640" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Each input line is used to produce a <b>Matcher</b>, and the result is scanned with <b>find(&#160;)</b>. Note that the <b>ListIterator.nextIndex(&#160;)</b> keeps track of the line numbers. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0641" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The test arguments open the <b>JGrep.java</b> file to read as input, and search for words starting with <b>[Ssct]</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0642" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775832"></a><a name="Heading16751"></a>Is StringTokenizer
needed?</h3>
<p>The new capabilities provided with regular expressions might prompt you to wonder whether the original <a name="Index1526"></a><b>StringTokenizer</b> class is still necessary. Before JDK 1.4, the way to split a string into parts was to &#147;tokenize&#148; it with <b>StringTokenizer</b>. But now it&#146;s much easier and more succinct to do the same thing with regular expressions:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c12:ReplacingStringTokenizer.java</font>
<font color=#0000ff>import</font> java.util.regex.*;
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ReplacingStringTokenizer {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String input = <font color=#004488>"But I'm not dead yet! I feel happy!"</font>;
    StringTokenizer stoke = <font color=#0000ff>new</font> StringTokenizer(input);
    <font color=#0000ff>while</font>(stoke.hasMoreElements())
      System.out.println(stoke.nextToken());
    System.out.println(Arrays.asList(input.split(<font color=#004488>" "</font>)));
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"But"</font>,
      <font color=#004488>"I'm"</font>,
      <font color=#004488>"not"</font>,
      <font color=#004488>"dead"</font>,
      <font color=#004488>"yet!"</font>,
      <font color=#004488>"I"</font>,
      <font color=#004488>"feel"</font>,
      <font color=#004488>"happy!"</font>,
      <font color=#004488>"[But, I'm, not, dead, yet!, I, feel, happy!]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>With regular expressions, you can also split a string into parts using more complex patterns&#151;something that&#146;s much more difficult with <b>StringTokenizer</b>. It seems safe to say that regular expressions replace any tokenizing classes in earlier versions of Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0643" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can learn much more about regular expressions in <i>Mastering Regular Expressions, 2<sup>nd</sup> Edition</i>, by Jeffrey E. F. Friedl (O&#146;Reilly, 2002). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0644" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775833"></a><a name="Heading16782"></a>Summary</h2>
<p>The Java I/O stream library does satisfy the basic requirements: you can perform reading and writing with the console, a file, a block of memory, or even across the Internet. With inheritance, you can create new types of input and output objects. And you can even add a simple extensibility to the kinds of objects a stream will accept by redefining the <b>toString(&#160;)</b> method that&#146;s automatically called when you pass an object to a method that&#146;s expecting a <b>String</b> (Java&#146;s limited &#147;automatic type conversion&#148;). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1807" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There are questions left unanswered by the documentation and design of the I/O stream library. For example, it would have been nice if you could say that you want an exception thrown if you try to overwrite a file when opening it for output&#151;some programming systems allow you to specify that you want to open an output file, but only if it doesn&#146;t already exist. In Java, it appears that you are supposed to use a <b>File</b> object to determine whether a file exists, because if you open it as a <b>FileOutputStream</b> or <b>FileWriter</b>,<b> </b>it will always get overwritten. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1808" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The I/O stream library brings up mixed feelings; it does much of the job and it&#146;s portable. But if you don&#146;t already understand the decorator pattern, the design is not intuitive, so there&#146;s extra overhead in learning and teaching it. It&#146;s also incomplete; for example, I shouldn&#146;t have to write utilities like <b>TextFile</b>, and there&#146;s no support for the kind of output formatting that virtually every other language&#146;s I/O package supports. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1809" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>However, once you <i>do</i> understand the decorator pattern and begin using the library in situations that require its flexibility, you can begin to benefit from this design, at which point its cost in extra lines of code may not bother you as much. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1810" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you do not find what you&#146;re looking for in this chapter (which has only been an introduction and is not meant to be comprehensive), you can find in-depth coverage in <i>Java I/O</i>, by Elliotte Rusty Harold (O&#146;Reilly, 1999). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1811" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545401"></a><a name="_Toc24775834"></a><a name="Heading16788"></a>Exercises</h2>
<p>Solutions to selected exercises can be found in the electronic document <i>The Thinking in Java Annotated Solution Guide</i>, available for a small fee from <i>www.BruceEckel.com</i>.<br></p>
<ol>
<li>	Open a text file so that you can read the file one line at a time. Read
each line as a <b>String </b>and place that <b>String </b>object into a
<b>LinkedList</b>. Print all of the lines in the <b>LinkedList</b> in reverse
order. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1812" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify Exercise 1 so that the name of the file you read is provided as a
command-line argument. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1813" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify Exercise 2 to also open a text file so you can write text into it.
Write the lines in the <b>ArrayList</b>, along with line numbers (do not attempt
to use the &#147;LineNumber&#148; classes), out to the file. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1814"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Modify Exercise 2 to force all the lines in the <b>ArrayList</b> to
uppercase and send the results to <b>System.out</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1815" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify Exercise 2 to take additional command-line arguments of words to
find in the file. Print all lines in which any of the words match. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1816"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Modify <b>DirList.java</b> so that the <b>FilenameFilter</b> actually opens
each file and accepts the file based on whether any of the trailing arguments on
the command line exist in that file. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1817" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>DirList.java</b> to produce all the file names in the current
directory <i>and subdirectories</i> that satisfy the given regular expression.
Hint: use recursion to traverse the subdirectories.</li>
<li>	Create a class called <b>SortedDirList</b> with a constructor that takes
file path information and builds a sorted directory list from the files at that
path. Create two overloaded <b>list(&#160;) </b>methods that will either produce
the whole list or a subset of the list based on an argument. Add a
<b>size(&#160;)</b> method that takes a file name and produces the size of that
file. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1818" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>WordCount.java</b> so that it produces an alphabetic sort
instead, using the tool from Chapter 11. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1819" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>WordCount.java</b> so that it uses a class containing a
<b>String</b> and a count value to store each different word, and a <b>Set</b>
of these objects to maintain the list of words. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1820" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>IOStreamDemo.java</b> so that it uses <b>LineNumberReader</b> to
keep track of the line count. Note that it&#146;s much easier to just keep
track programmatically. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1821" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Starting with section 4 of <b>IOStreamDemo.java</b>, write a program that
compares the performance of writing to a file when using buffered and unbuffered
I/O. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1822" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify section 5 of <b>IOStreamDemo.java</b> to eliminate the spaces in the
line produced by the first call to <b>in5.readUTF(&#160;)</b>. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1823"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Repair the program <b>CADState.java</b> as described in the text. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1824"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	In <b>Blips.java</b>, copy the file and rename it to <b>BlipCheck.java
</b>and rename the class <b>Blip2</b> to <b>BlipCheck </b>(making it
<b>public</b> and removing the public scope from the class <b>Blips</b> in the
process). Remove the <b>//!</b> marks in the file and execute the program
including the offending lines. Next, comment out the default constructor for
<b>BlipCheck</b>. Run it and explain why it works. Note that after compiling,
you must execute the program with &#147;<b>java Blips</b>&#148; because the
<b>main(&#160;)</b> method is still in class <b>Blips</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1825" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	In <b>Blip3.java</b>, comment out the two lines after the phrases
&#147;You must do this:&#148; and run the program. Explain the result and why
it differs from when the two lines are in the program. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1826" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	(Intermediate) In Chapter 8, locate the <b>GreenhouseController.java</b>
example, which consists of four files. <b>GreenhouseController</b> contains a
hard-coded set of events. Change the program so that it reads the events and
their relative times from a text file. (Challenging: use a design patterns
<i>factory method </i>to build the events&#151;see <i>Thinking in Patterns
(with Java)</i> at <i>www.BruceEckel.com.</i>) <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap11_1827" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Create and test a utility method to print the contents of a
<b>CharBuffer</b> up to the point where the characters are no longer printable.
<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0669"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Experiment with changing the <b>ByteBuffer.allocate(&#160;)</b> statements
in the examples in this chapter to <b>ByteBuffer.allocateDirect(&#160;)</b>.
Demonstrate performance differences, but also notice whether the startup time of
the programs noticeably changes. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0670" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	For the phrase &#147;Java now has regular expressions&#148; evaluate
whether the following expressions will find a match: <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0671" title="Send BackTalk
Comment">Feedback</a></font></li></ol>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>^Java
\Breg.*
n.w\s+h(a|i)s
s?
s*
s+
s{4}
s{1.}
s{0,3}</PRE></FONT></BLOCKQUOTE><p><br></p>
<ol>
<li>	Apply the regular expression <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0672" title="Send BackTalk
Comment">Feedback</a></font></li></ol>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE> (?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>to<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#004488>"Arline ate eight apples and one orange while Anita hadn't any"</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<ol>
<li>	Modify <b>JGrep.java</b> to accept flags as arguments (e.g.,
<b>Pattern.CASE_INSENSITIVE</b>, <b>Pattern.MULTILINE</b>). <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0673" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>JGrep.java</b> to use Java <b>nio</b> memory-mapped files. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0674" title="Send
BackTalk Comment">Feedback</a></font></li>
<li>	Modify <b>JGrep.java</b> to accept a directory name or a file name as
argument (if a directory is provided, search should include all files in the
directory). Hint: you can generate a list of filenames with: <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0675" title="Send BackTalk
Comment">Feedback</a></font></li></ol>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>String[] filenames = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>).list();</PRE></FONT></BLOCKQUOTE><p><br></p>
<hr><p class="footnote text"><sup><a name="fn61" href="#fnB61">[61]</a></sup> <i>Design Patterns</i>, Erich Gamma <i>et al.</i>, Addison-Wesley 1995.<br></p>
<p class="footnote text"><sup><a name="fn62" href="#fnB62">[62]</a></sup> It&#146;s not clear that this was a good design decision, especially compared to the simplicity of I/O libraries in other languages. But it&#146;s the justification for the decision.<br></p>
<p class="footnote text"><sup><a name="fn63" href="#fnB63">[63]</a></sup> XML is another way to solve the problem of moving data across different computing platforms, and does not depend on having Java on all platforms. JDK 1.4 contains XML tools in <b>javax.xml.*</b> libraries. These are covered in <i>Thinking in Enterprise Java</i>, at <i>www.MindView.net</i>.<br></p>
<p class="footnote text"><sup><a name="fn64" href="#fnB64">[64]</a></sup> Chapter 13 shows an even more convenient solution for this: a GUI program with a scrolling text area.<br></p>
<p class="footnote text"><sup><a name="fn65" href="#fnB65">[65]</a></sup> Chintan Thakker contributed to this section.<br></p>
<p class="footnote text"><sup><a name="fn66" href="#fnB66">[66]</a></sup> A chapter dedicated to strings will have to wait until the 4<sup>th</sup> edition. Mike Shea contributed to this section.<br></p>
<p class="footnote text"><sup><a name="fn67" href="#fnB67">[67]</a></sup> I have no idea how they came up with this method name, or what it&#146;s supposed to refer to. But it&#146;s reassuring to know that whoever comes up with nonintuitive method names is still employed at Sun. And that their apparent policy of not reviewing code designs is still in place. Sorry for the sarcasm, but this kind of thing gets tiresome after a few years.<br></p>

<!-- <hr><b>Placeholder</b> -->

<hr>

<div align="CENTER"><a href="TIJ313.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ315.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>

</font></body>

</html>

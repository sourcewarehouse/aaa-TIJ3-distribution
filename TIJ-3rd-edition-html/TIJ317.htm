<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en">
<!--
This document was converted from RTF source: 
By r2net 5.8 r2netcmd Windows 
See http://www.logictran.com
-->
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Thinking in Java, 3rd ed. Revision 4.0: 15: Discovering Problems</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css"></head>

<body >
   <CENTER>     <a href="http://www.MindView.net">     <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>     <Font FACE="Verdana, Tahoma, Arial, Helvetica, Sans">     <h2>Thinking in Java, 3<sup>rd</sup> ed. Revision 4.0</h2>     <FONT size = "-1"><br>     [ <a href="README.txt">Viewing Hints</a> ]     [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]     [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>     [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]     [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]     [ <a href="http://www.mindview.net/Services">Consulting</a> ] <br><br>     </FONT></FONT>   </CENTER> 
<font face="Georgia"><div align="CENTER"><a href="TIJ316.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ318.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>
<hr>

<h1>
<a name="_Toc375545491"></a><a name="_Toc24272654"></a><a name="_Toc24775931"></a><a name="Heading22248"></a>15:
Discovering Problems</h1>
<p class="Intro">Before C was tamed into ANSI C, we had a little joke: &#147;My code compiles, so it should run!&#148; (Ha ha!)<br></p>
<p>This was funny only if you understood C, because at that time the C compiler would accept just about anything; C was truly a &#147;portable assembly language&#148; created to see if it was possible to develop a portable operating system (Unix) that could be moved from one machine architecture to another without rewriting it from scratch in the new machine&#146;s assembly language. So C was actually created as a side-effect of building Unix and not as a general-purpose programming language. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0159" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Because C was targeted at programmers who wrote operating systems in assembly language, it was implicitly assumed that those programmers knew what they were doing and didn&#146;t need safety nets. For example, assembly-language programmers didn&#146;t need the compiler to check argument types and usage, and if they decided to use a data type in a different way than it was originally intended, they certainly must have good reason to do so, and the compiler didn&#146;t get in the way. Thus, getting your pre-ANSI C program to compile was only the first step in the long process of developing a bug-free program. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0160" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The development of ANSI C along with stronger rules about what the compiler would accept came after lots of people used C for projects other than writing operating systems, and after the appearance of C++, which greatly improved your chances of having a program run decently once it compiled. Much of this improvement came through <a name="Index2008"></a><a name="Index2009"></a><a name="Index2010"></a><i>strong static type checking</i>: &#147;strong&#148; because the compiler prevented you from abusing the type, &#147;static&#148; because ANSI C and C++ perform type checking at compile time. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0161" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To many people (myself included), the improvement was so dramatic that it appeared that strong static type checking was the answer to a large portion of our problems. Indeed, one of the motivations for Java was that C++&#146;s type checking wasn&#146;t strong <i>enough</i> (primarily because C++ had to be backward-compatible with C, and so was chained to its limitations). Thus Java has gone even further to take advantage of the benefits of type checking, and since Java has language-checking mechanisms that exist at run time (C++ doesn&#146;t; what&#146;s left at run time is basically assembly language&#151;very fast, but with no self-awareness), it isn&#146;t restricted to only static type checking.<sup><a name="fnB86" href="#fn86">[86]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0162" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It seems, however, that language-checking mechanisms can take us only so far in our quest to develop a correctly-working program. C++ gave us programs that worked a lot sooner than C programs, but often still had problems such as memory leaks and subtle, buried bugs. Java went a long way toward solving those problems, yet it&#146;s still quite possible to write a Java program containing nasty bugs. In addition (despite the amazing performance claims always touted by the flaks at Sun), all the safety nets in Java added additional overhead, so sometimes we run into the challenge of getting our Java programs to run fast enough for a particular need (although it&#146;s usually more important to have a working program than one that runs at a particular speed). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0163" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This chapter presents tools to solve the problems that the compiler doesn&#146;t. In a sense, we are admitting that the compiler can take us only so far in the creation of robust programs, so we are moving beyond the compiler and creating a build system and code that know more about what a program is and isn&#146;t supposed to do. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0204" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One of the biggest steps forward is the incorporation of <i>automated unit testing.</i> This means writing tests and incorporating those tests into a build system that compiles your code and runs the tests every single time, as if the tests were part of the compilation process (you&#146;ll soon start relying upon them as if they are). For this book, a custom testing system was developed to ensure the correctness of the program output (and to display the output directly in the code listing), but the defacto standard <b>JUnit</b> testing system will also be used when appropriate. To make sure that testing is automatic, tests are run as part of the build process using Ant, an open-source tool that has also become a defacto standard in Java development, and CVS, another open-source tool that maintains a repository containing all your source code for a particular project. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0164" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>JDK 1.4 introduced an <i>assertion</i> mechanism to aid in the verification of code at run time. One of the more compelling uses of assertions is <i>Design by Contract</i> (DBC), a formalized way to describe the correctness of a class. In conjunction with automated testing, DBC can be a powerful tool. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0203" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Sometimes unit testing isn&#146;t enough, and you need to track down problems in a program that runs, but doesn&#146;t run right. In JDK 1.4, the <i>logging API</i> was introduced to allow you to easily report information about your program. This is a significant improvement over adding and removing <b>println(&#160;)</b> statements in order to track down a problem, and this section will go into enough detail to give you a thorough grounding in this API. This chapter also provides an introduction to debugging, showing the information a typical debugger can provide to aid you in the discovery of subtle problems. Finally, you&#146;ll learn about profiling and how to discover the bottlenecks that cause your program to run too slowly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0165" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775932"></a><a name="Heading22260"></a>Unit Testing<br></h2>
<p><a name="Index2011"></a><a name="Index2012"></a><a name="Index2013"></a>A recent realization in programming practice is the dramatic value of unit testing. This is the process of building integrated tests into all the code that you create and running those tests every time you do a build. That way, the build process can check for more than just syntax errors, since you teach it how to check for semantic errors as well. C-style programming languages, and C++ in particular, have typically valued performance over programming safety. The reason that developing programs in Java is so much faster than in C++ (roughly twice as fast, by most accounts) is because of Java&#146;s safety net: features like garbage collection and improved type checking. By integrating unit testing into your build process, you can extend this safety net, resulting in faster development. You can also be bolder in the changes that you make, more easily refactor your code when you discover design or implementation flaws, and in general produce a better product, more quickly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0001" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The effect of unit testing on development is so significant that it is used throughout this book, not only to validate the code in the book, but also to display the expected output. My own experience with unit testing began when I realized that, to guarantee the correctness of code in a book, every program in that book must be automatically extracted and organized into a source tree, along with an appropriate build system. The build system used in this book is <i>Ant </i>(described later in this chapter), and after you install it, you can just type <b>ant</b> to build all the code for the book. The effect of the automatic extraction and compilation process on the code quality of the book was so immediate and dramatic that it soon became (in my mind) a requisite for any programming book&#151;how can you trust code that you didn&#146;t compile? I also discovered that if I wanted to make sweeping changes, I could do so using search-and-replace throughout the book or just by bashing the code around. I knew that if I introduced a flaw, the code extractor and the build system would flush it out. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0183" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As programs became more complex, however, I also found that there was a serious hole in my system. Being able to successfully compile programs is clearly an important first step, and for a published book it seems a fairly revolutionary one; usually because of the pressures of publishing, it&#146;s quite typical to randomly open a programming book and discover a coding flaw. However, I kept getting messages from readers reporting semantic problems in my code. These problems could be discovered only by running the code. Naturally, I understood this and took some early faltering steps toward implementing a system that would perform automatic execution tests, but I had succumbed to publishing schedules, all the while knowing that there was definitely something wrong with my process and that it would come back to bite me in the form of embarrassing bug reports (in the open source world,<sup><a name="fnB87" href="#fn87">[87]</a></sup> embarrassment is one of the prime motivating factors towards increasing the quality of one&#146;s code!). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0002" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The other problem was that I lacked a structure for the testing system. Eventually, I started hearing about unit testing and JUnit, which provided a basis for a testing structure. I found the initial versions of JUnit to be intolerable because they required the programmer to write too much code to create even the simplest test suite. More recent versions have significantly reduced this required code by using reflection, so they are much more satisfactory. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0184" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>I needed to solve another problem, however, and that was to validate the output of a program and to show the validated output in the book. I had gotten regular complaints that I didn&#146;t show enough program output in the book. My attitude was that the reader should be running the programs while reading the book, and many readers did just that and benefited from it. A hidden reason for that attitude, however, was that I didn&#146;t have a way to test that the output shown in the book was correct. From experience, I knew that over time, something would happen so that the output was no longer correct (or, I wouldn&#146;t get it right in the first place). The simple testing framework shown here not only captures the console output of the program&#151;and most programs in this book produce console output&#151;but it also compares it to the expected output that is printed in the book as part of the source-code listing, so readers can see what the output will be and also know that this output has been verified by the build process, and that they can verify it themselves. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0186" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>I wanted to see if the test system could be even easier and simpler to use, applying the Extreme Programming principle of &#147;do the simplest thing that could possibly work&#148; as a starting point, and then evolving the system as usage demands. (In addition, I wanted to try to reduce the amount of test code in an attempt to fit more functionality in less code for screen presentations.) The result<sup><a name="fnB88" href="#fn88">[88]</a></sup> is the simple testing framework described next. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0003" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775933"></a><a name="Heading22269"></a>A Simple Testing
Framework<br></h3>
<p><a name="Index2014"></a>The primary goal of this framework<sup><a name="fnB89" href="#fn89">[89]</a></sup> is to verify the output of the examples in the book. You have already seen lines such as<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>at the beginning of most classes that contain a <b>main(&#160;)</b> method. The task of the <b>monitor</b> object is to intercept and save a copy of standard output and standard error into a text file. This file is then used to verify the output of an example program by comparing the contents of the file to the expected output. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0005" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>We start by defining the exceptions that will be thrown by this test system. The general-purpose exception for the library is the base class for the others. Note that it extends <a name="Index2015"></a><b>RuntimeException</b> so that checked exceptions are not involved:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:simpletest:SimpleTestException.java</font>
<font color=#0000ff>package</font> com.bruceeckel.simpletest;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleTestException <font color=#0000ff>extends</font> RuntimeException {
  <font color=#0000ff>public</font> SimpleTestException(String msg) {
    <font color=#0000ff>super</font>(msg);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>A basic test is to verify that the number of lines sent to the console by the program is the same as the expected number of lines:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:simpletest:NumOfLinesException.java</font>
<font color=#0000ff>package</font> com.bruceeckel.simpletest;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NumOfLinesException
<font color=#0000ff>extends</font> SimpleTestException {
  <font color=#0000ff>public</font> NumOfLinesException(<font color=#0000ff>int</font> exp, <font color=#0000ff>int</font> out) {
    <font color=#0000ff>super</font>(<font color=#004488>"Number of lines of output and "</font>
      + <font color=#004488>"expected output did not match.\n"</font> +
      <font color=#004488>"expected: &lt;"</font> + exp + <font color=#004488>"&gt;\n"</font> +
      <font color=#004488>"output:   &lt;"</font> + out + <font color=#004488>"&gt; lines)"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Or, the number of lines might be correct, but one or more lines might not match:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:simpletest:LineMismatchException.java</font>
<font color=#0000ff>package</font> com.bruceeckel.simpletest;
<font color=#0000ff>import</font> java.io.PrintStream;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LineMismatchException
  <font color=#0000ff>extends</font> SimpleTestException {
  <font color=#0000ff>public</font> LineMismatchException(
    <font color=#0000ff>int</font> lineNum, String expected, String output) {
    <font color=#0000ff>super</font>(<font color=#004488>"line "</font> + lineNum +
      <font color=#004488>" of output did not match expected output\n"</font> +
      <font color=#004488>"expected: &lt;"</font> + expected + <font color=#004488>"&gt;\n"</font> +
      <font color=#004488>"output:   &lt;"</font> + output + <font color=#004488>"&gt;"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This test system works by intercepting the console output using the <b>TestStream</b> class to replace the standard console output and console error:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:simpletest:TestStream.java</font>
<font color=#009900>// Simple utility for testing program output. Intercepts</font>
<font color=#009900>// System.out to print both to the console and a buffer.</font>
<font color=#0000ff>package</font> com.bruceeckel.simpletest;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.regex.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestStream <font color=#0000ff>extends</font> PrintStream {
  <font color=#0000ff>protected</font> <font color=#0000ff>int</font> numOfLines;
  <font color=#0000ff>private</font> PrintStream
    console = System.out,
    err = System.err,
    fout;
  <font color=#009900>// To store lines sent to System.out or err</font>
  <font color=#0000ff>private</font> InputStream stdin;
  <font color=#0000ff>private</font> String className;
  <font color=#0000ff>public</font> TestStream(String className) {
    <font color=#0000ff>super</font>(System.out, <font color=#0000ff>true</font>); <font color=#009900>// Autoflush</font>
    System.setOut(<font color=#0000ff>this</font>);
    System.setErr(<font color=#0000ff>this</font>);
    stdin = System.in; <font color=#009900>// Save to restore in dispose()</font>
    <font color=#009900>// Replace the default version with one that</font>
    <font color=#009900>// automatically produces input on demand:</font>
    System.setIn(<font color=#0000ff>new</font> BufferedInputStream(<font color=#0000ff>new</font> InputStream(){
      <font color=#0000ff>char</font>[] input = (<font color=#004488>"test\n"</font>).toCharArray();
      <font color=#0000ff>int</font> index = 0;
      <font color=#0000ff>public</font> <font color=#0000ff>int</font> read() {
        <font color=#0000ff>return</font>
          (<font color=#0000ff>int</font>)input[index = (index + 1) % input.length];
      }
    }));
    <font color=#0000ff>this</font>.className = className;
    openOutputFile();
  }
  <font color=#009900>// public PrintStream getConsole() { return console; }</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> dispose() {
    System.setOut(console);
    System.setErr(err);
    System.setIn(stdin);
  }
  <font color=#009900>// This will write over an old Output.txt file:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> openOutputFile() {
    <font color=#0000ff>try</font> {
      fout = <font color=#0000ff>new</font> PrintStream(<font color=#0000ff>new</font> FileOutputStream(
        <font color=#0000ff>new</font> File(className + <font color=#004488>"Output.txt"</font>)));
    } <font color=#0000ff>catch</font> (FileNotFoundException e) {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
    }
  }
  <font color=#009900>// Override all possible print/println methods to send</font>
  <font color=#009900>// intercepted console output to both the console and</font>
  <font color=#009900>// the Output.txt file:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(<font color=#0000ff>boolean</font> x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(<font color=#0000ff>boolean</font> x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(<font color=#0000ff>char</font> x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(<font color=#0000ff>char</font> x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(<font color=#0000ff>int</font> x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(<font color=#0000ff>int</font> x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(<font color=#0000ff>long</font> x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(<font color=#0000ff>long</font> x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(<font color=#0000ff>float</font> x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(<font color=#0000ff>float</font> x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(<font color=#0000ff>double</font> x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(<font color=#0000ff>double</font> x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(<font color=#0000ff>char</font>[] x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(<font color=#0000ff>char</font>[] x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(String x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(String x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> print(Object x) {
    console.print(x);
    fout.print(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println(Object x) {
    numOfLines++;
    console.println(x);
    fout.println(x);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> println() {
    <font color=#0000ff>if</font>(<font color=#0000ff>false</font>) console.print(<font color=#004488>"println"</font>);
    numOfLines++;
    console.println();
    fout.println();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font>
  write(<font color=#0000ff>byte</font>[] buffer, <font color=#0000ff>int</font> offset, <font color=#0000ff>int</font> length) {
    console.write(buffer, offset, length);
    fout.write(buffer, offset, length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> write(<font color=#0000ff>int</font> b) {
    console.write(b);
    fout.write(b);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The constructor for <b>TestStream</b>, after calling the constructor for the base class, first saves references to standard output and standard error, and then redirects both streams to the <b>TestStream</b> object. The static methods <b>setOut(&#160;)</b> and <b>setErr(&#160;)</b> both take a <b>PrintStream</b> argument. <a name="Index2016"></a><b>System.out</b> and <a name="Index2017"></a><b>System.err</b> references are unplugged from their normal object and instead are plugged into the <b>TestStream</b> object, so <b>TestStream</b> must also be a <b>PrintStream</b> (or equivalently, something inherited from <b>PrintStream</b>). The original standard output <b>PrintStream</b> reference is captured in the console reference inside <b>TestStream</b>, and every time console output is intercepted, it is sent to the original console as well as to an output file. The <b>dispose(&#160;)</b> method is used to set standard I/O references back to their original objects when <b>TestStream</b> is finished with them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0185" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>For automatic testing of examples that require user input from the console, the constructor redirects calls to standard input. The current standard input is stored in a reference so that <b>dispose(&#160;) </b>can restore it to its original state. Using <b>System.setIn(&#160;)</b>, an anonymous inner class is set to handle any requests for input by the program under test. The <b>read(&#160;)</b> method of this inner class produces the letters &#147;test&#148; followed by a newline. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0187" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>TestStream</b> overrides a variety of <b>PrintStream</b> <b>print(&#160;)</b> and <b>println(&#160;)</b> methods for each type. Each of these methods writes both to the &#147;standard&#148; output and to an output file. The <b>expect(&#160;)</b> method can then be used to test whether output produced by a program matches the expected output provided as argument to <b>expect(&#160;)</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0205" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>These tools are used in the <b>Test</b> class:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:simpletest:Test.java</font>
<font color=#009900>// Simple utility for testing program output. Intercepts</font>
<font color=#009900>// System.out to print both to the console and a buffer.</font>
<font color=#0000ff>package</font> com.bruceeckel.simpletest;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.regex.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Test {
  <font color=#009900>// Bit-shifted so they can be added together:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font>
    EXACT = 1 &lt;&lt; 0, <font color=#009900>// Lines must match exactly</font>
    AT_LEAST = 1 &lt;&lt; 1, <font color=#009900>// Must be at least these lines</font>
    IGNORE_ORDER = 1 &lt;&lt; 2, <font color=#009900>// Ignore line order</font>
    WAIT = 1 &lt;&lt; 3; <font color=#009900>// Delay until all lines are output</font>
  <font color=#0000ff>private</font> String className;
  <font color=#0000ff>private</font> TestStream testStream;
  <font color=#0000ff>public</font> Test() {
    <font color=#009900>// Discover the name of the class this</font>
    <font color=#009900>// object was created within:</font>
    className =
      <font color=#0000ff>new</font> Throwable().getStackTrace()[1].getClassName();
    testStream = <font color=#0000ff>new</font> TestStream(className);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> List fileToList(String fname) {
    ArrayList list = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>try</font> {
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(<font color=#0000ff>new</font> FileReader(fname));
      <font color=#0000ff>try</font> {
        String line;
        <font color=#0000ff>while</font>((line = in.readLine()) != <font color=#0000ff>null</font>) {
          <font color=#0000ff>if</font>(fname.endsWith(<font color=#004488>".txt"</font>))
            list.add(line);
          <font color=#0000ff>else</font>
            list.add(<font color=#0000ff>new</font> TestExpression(line));
        }
      } <font color=#0000ff>finally</font> {
        in.close();
      }
    } <font color=#0000ff>catch</font> (IOException e) {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
    }
    <font color=#0000ff>return</font> list;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> List arrayToList(Object[] array) {
    List l = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; array.length; i++) {
      <font color=#0000ff>if</font>(array[i] <font color=#0000ff>instanceof</font> TestExpression) {
        TestExpression re = (TestExpression)array[i];
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; re.getNumber(); j++)
          l.add(re);
      } <font color=#0000ff>else</font> {
        l.add(<font color=#0000ff>new</font> TestExpression(array[i].toString()));
      }
    }
    <font color=#0000ff>return</font> l;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> expect(Object[] exp, <font color=#0000ff>int</font> flags) {
    <font color=#0000ff>if</font>((flags &amp; WAIT) != 0)
      <font color=#0000ff>while</font>(testStream.numOfLines &lt; exp.length) {
        <font color=#0000ff>try</font> {
          Thread.sleep(1000);
        } <font color=#0000ff>catch</font> (InterruptedException e) {
          <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
        }
      }
      List output = fileToList(className + <font color=#004488>"Output.txt"</font>);
      <font color=#0000ff>if</font>((flags &amp; IGNORE_ORDER) == IGNORE_ORDER)
        OutputVerifier.verifyIgnoreOrder(output, exp);
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>((flags &amp; AT_LEAST) == AT_LEAST)
        OutputVerifier.verifyAtLeast(output,
          arrayToList(exp));
      <font color=#0000ff>else</font>
        OutputVerifier.verify(output, arrayToList(exp));
    <font color=#009900>// Clean up the output file - see c06:Detergent.java</font>
    testStream.openOutputFile();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> expect(Object[] expected) {
    expect(expected, EXACT);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> expect(Object[] expectFirst,
    String fname, <font color=#0000ff>int</font> flags) {
    List expected = fileToList(fname);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; expectFirst.length; i++)
      expected.add(i, expectFirst[i]);
    expect(expected.toArray(), flags);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> expect(Object[] expectFirst, String fname) {
    expect(expectFirst, fname, EXACT);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> expect(String fname) {
    expect(<font color=#0000ff>new</font> Object[] {}, fname, EXACT);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>There are several overloaded versions of <b>expect(&#160;)</b> provided for convenience (so the client programmer can, for example, provide the name of the file containing the expected output instead of an array of expected output lines). These overloaded methods all call the main <b>expect(&#160;)</b> method, which takes as arguments an array of <b>Objects</b> containing expected output lines and an <b>int</b> containing various flags. Flags are implemented using bit shifting, with each bit corresponding to a particular flag as defined at the beginning of <b>Test.java</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0206" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>expect(&#160;)</b> method first inspects the <b>flags</b> argument to see if it should delay processing to allow a slow program to catch up. It then calls a <b>static</b> method <b>fileToList(&#160;)</b>, which converts the contents of the output file produced by a program into a <b>List</b>. The <b>fileToList(&#160;)</b> method also wraps each <b>String</b> object in an <b>OutputLine</b> object; the reason for this will become clear. Finally, the <b>expect(&#160;)</b> method calls the appropriate <b>verify(&#160;)</b> method based on the flags argument. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0645" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There are three verifiers: <b>verify(&#160;)</b>, <b>verifyIgnoreOrder(&#160;)</b>, and <b>verifyAtLeast(&#160;)</b>, corresponding to <b>EXACT</b>, <b>IGNORE_ORDER</b>, and <b>AT_LEAST</b> modes, respectively:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:simpletest:OutputVerifier.java</font>
<font color=#0000ff>package</font> com.bruceeckel.simpletest;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.io.PrintStream;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> OutputVerifier {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> verifyLength(
    <font color=#0000ff>int</font> output, <font color=#0000ff>int</font> expected, <font color=#0000ff>int</font> compare) {
    <font color=#0000ff>if</font>((compare == Test.EXACT &amp;&amp; expected != output)
      || (compare == Test.AT_LEAST &amp;&amp; output &lt; expected))
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NumOfLinesException(expected, output);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> verify(List output, List expected) {
    verifyLength(output.size(),expected.size(),Test.EXACT);
    <font color=#0000ff>if</font>(!expected.equals(output)) {
      <font color=#009900>//find the line of mismatch</font>
      ListIterator it1 = expected.listIterator();
      ListIterator it2 = output.listIterator();
      <font color=#0000ff>while</font>(it1.hasNext()
        &amp;&amp; it2.hasNext()
        &amp;&amp; it1.next().equals(it2.next()));
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> LineMismatchException(
        it1.nextIndex(), it1.previous().toString(),
        it2.previous().toString());
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  verifyIgnoreOrder(List output, Object[] expected) {
    verifyLength(expected.length,output.size(),Test.EXACT);
    <font color=#0000ff>if</font>(!(expected <font color=#0000ff>instanceof</font> String[]))
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(
        <font color=#004488>"IGNORE_ORDER only works with String objects"</font>);
    String[] out = <font color=#0000ff>new</font> String[output.size()];
    Iterator it = output.iterator();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; out.length; i++)
      out[i] = it.next().toString();
    Arrays.sort(out);
    Arrays.sort(expected);
    <font color=#0000ff>int</font> i =0;
    <font color=#0000ff>if</font>(!Arrays.equals(expected, out)) {
      <font color=#0000ff>while</font>(expected[i].equals(out[i])) {i++;}
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> SimpleTestException(
        ((String) out[i]).compareTo(expected[i]) &lt; 0
          ? <font color=#004488>"output: &lt;"</font> + out[i] + <font color=#004488>"&gt;"</font>
          : <font color=#004488>"expected: &lt;"</font> + expected[i] + <font color=#004488>"&gt;"</font>);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  verifyAtLeast(List output, List expected) {
    verifyLength(output.size(), expected.size(),
      Test.AT_LEAST);
    <font color=#0000ff>if</font>(!output.containsAll(expected)) {
      ListIterator it = expected.listIterator();
      <font color=#0000ff>while</font>(output.contains(it.next())) {}
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> SimpleTestException(
        <font color=#004488>"expected: &lt;"</font> + it.previous().toString() + <font color=#004488>"&gt;"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The &#147;verify&#148; methods test whether the output produced by a program matches the expected output as specified by the particular mode. If this is not the case, the &#147;verify&#148; methods raise an exception that aborts the build process. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0647" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Each of the &#147;verify&#148; methods uses <b>verifyLength(&#160;) </b>to test the number of lines of output. <b>EXACT</b> mode requires that both output and expected output arrays be the same size, and that each output line is equal to the corresponding line in the expected output array. <b>IGNORE_ORDER</b> still requires that both arrays be the same size, but the actual order of appearance of the lines is disregarded (the two output arrays must be permutations of one another). <b>IGNORE_ORDER</b> mode is used to test threading examples where, due to non-deterministic scheduling of threads by the JVM, it is possible that the sequence of output lines produced by a program cannot be predicted. <b>AT_LEAST</b> mode does not require the two arrays to be the same size, but each line of expected output must be contained in the actual output produced by a program, regardless of order. This feature is particularly useful for testing program examples that contain output lines that may or may not be printed, as is the case with most of the examples dealing with garbage collection. Notice that the three modes are canonical; that is, if a test passes in <b>IGNORE_ORDER</b> mode, then it will also pass in <b>AT_LEAST</b> mode, and if it passes in <b>EXACT</b> mode, it will also pass in the other two modes. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0010" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Notice how simple the implementation of the &#147;verify&#148; methods is. <b>verify(&#160;)</b>, for example, simply calls the <b>equals(&#160;)</b> method provided by the <b>List</b> class, and <b>verifyAtLeast(&#160;)</b> calls <b>List.containsAll(&#160;)</b>. Remember that the two output <b>List</b>s can contain both <b>OutputLine</b> or <b>RegularExpression</b> objects. The reason for wrapping the simple <b>String</b> object in <b>OutputLines</b> should now become clear; this approach allows us to override the <b>equals(&#160;)</b> method, which is necessary in order to take advantage of the Java <b>Collections</b> API. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0207" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Objects in the <b>expect(&#160;) </b>array can be either <b>Strings</b> or <b>TestExpression</b>s, which can encapsulate a regular expression (described in Chapter 12), which is useful for testing examples that produce random output. The <b>TestExpression</b> class encapsulates a <b>String</b> representing a particular regular expression. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0007" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:simpletest:TestExpression.java</font>
<font color=#009900>// Regular expression for testing program output lines</font>
<font color=#0000ff>package</font> com.bruceeckel.simpletest;
<font color=#0000ff>import</font> java.util.regex.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestExpression <font color=#0000ff>implements</font> Comparable {
  <font color=#0000ff>private</font> Pattern p;
  <font color=#0000ff>private</font> String expression;
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> isRegEx;
  <font color=#009900>// Default to only one instance of this expression:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> duplicates = 1;
  <font color=#0000ff>public</font> TestExpression(String s) {
    <font color=#0000ff>this</font>.expression = s;
    <font color=#0000ff>if</font>(expression.startsWith(<font color=#004488>"%% "</font>)) {
      <font color=#0000ff>this</font>.isRegEx = <font color=#0000ff>true</font>;
      expression = expression.substring(3);
      <font color=#0000ff>this</font>.p = Pattern.compile(expression);
    }
  }
  <font color=#009900>// For duplicate instances:</font>
  <font color=#0000ff>public</font> TestExpression(String s, <font color=#0000ff>int</font> duplicates) {
    <font color=#0000ff>this</font>(s);
    <font color=#0000ff>this</font>.duplicates = duplicates;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>if</font>(isRegEx) <font color=#0000ff>return</font> p.pattern();
    <font color=#0000ff>return</font> expression;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object obj) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == obj) <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
    <font color=#0000ff>if</font>(isRegEx) <font color=#0000ff>return</font> (compareTo(obj) == 0);
    <font color=#0000ff>return</font> expression.equals(obj.toString());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object obj) {
    <font color=#0000ff>if</font>((isRegEx) &amp;&amp; (p.matcher(obj.toString()).matches()))
      <font color=#0000ff>return</font> 0;
    <font color=#0000ff>return</font>
      expression.compareTo(obj.toString());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getNumber() {  <font color=#0000ff>return</font> duplicates; }
  <font color=#0000ff>public</font> String getExpression() { <font color=#0000ff>return</font> expression;}
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isRegEx() { <font color=#0000ff>return</font> isRegEx; }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>TestExpression </b>can distinguish regular expression patterns from <b>String</b> literals. The second constructor allows multiple identical expression lines to be wrapped in a single object for convenience. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0189" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This test system has been reasonably useful, and the exercise of creating it and putting it into use has been invaluable. However, in the end I&#146;m not that pleased with it and have ideas that will probably be implemented in the next edition of the book (or possibly sooner). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0646" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775934"></a><a name="Heading22680"></a>JUnit</h3>
<p>Although the testing framework just described allows you to verify program output simply and easily, in some cases you may want to perform more extensive functionality testing on a program. <a name="Index2018"></a><i>JUnit</i>, available at <i>www.junit.org</i>, is a quickly emerging standard for writing repeatable tests for Java programs, and provides both simple and complex testing. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0191" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The original JUnit was presumably based on JDK 1.0 and thus could not make use of Java&#146;s reflection facilities. As a result, writing unit tests with the old JUnit was a rather busy and wordy activity, and I found the design to be unpleasant. Because of this, I wrote my own unit testing framework for Java,<sup><a name="fnB90" href="#fn90">[90]</a></sup> going to the other extreme and &#147;doing the simplest thing that could possibly work.&#148;<sup><a name="fnB91" href="#fn91">[91]</a></sup> Since then, JUnit has been modified and uses reflection to greatly simplify the process of writing unit test code. Although you still have the option of writing code the &#147;old&#148; way with test suites and all the other complex details, I believe that in the great majority of cases you can follow the simple approach shown here (and make your life more pleasant). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0195" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the simplest approach to using JUnit, you put all your tests in a subclass of <b>TestCase</b>. Each test must be <b>public</b>, take no arguments, return <b>void</b>, and have a method name beginning with the word &#147;test.&#148; Junit&#146;s reflection will identify these methods as individual tests and set up and run them one at a time, taking measures to avoid side effects between the tests. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0194" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Traditionally, the <a name="Index2019"></a><b>setUp(&#160;)</b> method creates and initializes a common set of objects that will be used in all the tests; however, you can also just put all such initialization in the constructor for the test class. JUnit creates an object for each test to ensure there will be no side effects between test runs. However, all the objects for all the tests are created at once (rather than creating the object right before the test), so the only difference between using <b>setUp(&#160;) </b>and the constructor is that <b>setUp(&#160;) </b>is called directly before the test. In most situations this will not be an issue, and you can use the constructor approach for simplicity. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0192" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you need to perform any cleanup after each test (if you modify any statics that need to be restored, open files that need to be closed, open network connections, etc.), you write a <a name="Index2020"></a><b>tearDown(&#160;)</b> method. This is also optional. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0011" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The following example uses this simple approach to create JUnit tests that exercise the standard Java <a name="Index2021"></a><b>ArrayList</b> class. To trace how JUnit creates and cleans up its test objects, <b>CountedList</b> is inherited from <b>ArrayList</b> and tracking information is added: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0196" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:JUnitDemo.java</font>
<font color=#009900>// Simple use of JUnit to test ArrayList</font>
<font color=#009900>// {Depends: junit.jar}</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> junit.framework.*;

<font color=#009900>// So we can see the list objects being created,</font>
<font color=#009900>// and keep track of when they are cleaned up:</font>
<font color=#0000ff>class</font> CountedList <font color=#0000ff>extends</font> ArrayList {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> id = counter++;
  <font color=#0000ff>public</font> CountedList() {
    System.out.println(<font color=#004488>"CountedList #"</font> + id);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getId() { <font color=#0000ff>return</font> id; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> JUnitDemo <font color=#0000ff>extends</font> TestCase {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> com.bruceeckel.simpletest.Test monitor =
    <font color=#0000ff>new</font> com.bruceeckel.simpletest.Test();
  <font color=#0000ff>private</font> CountedList list = <font color=#0000ff>new</font> CountedList();
  <font color=#009900>// You can use the constructor instead of setUp():</font>
  <font color=#0000ff>public</font> JUnitDemo(String name) {
    <font color=#0000ff>super</font>(name);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      list.add(<font color=#004488>""</font> + i);
  }
  <font color=#009900>// Thus, setUp() is optional, but is run right</font>
  <font color=#009900>// before the test:</font>
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> setUp() {
    System.out.println(<font color=#004488>"Set up for "</font> + list.getId());
  }
  <font color=#009900>// tearDown() is also optional, and is called after</font>
  <font color=#009900>// each test. setUp() and tearDown() can be either</font>
  <font color=#009900>// protected or public:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> tearDown() {
    System.out.println(<font color=#004488>"Tearing down "</font> + list.getId());
  }
  <font color=#009900>// All tests have method names beginning with "test":</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> testInsert() {
    System.out.println(<font color=#004488>"Running testInsert()"</font>);
    assertEquals(list.size(), 3);
    list.add(1, <font color=#004488>"Insert"</font>);
    assertEquals(list.size(), 4);
    assertEquals(list.get(1), <font color=#004488>"Insert"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> testReplace() {
    System.out.println(<font color=#004488>"Running testReplace()"</font>);
    assertEquals(list.size(), 3);
    list.set(1, <font color=#004488>"Replace"</font>);
    assertEquals(list.size(), 3);
    assertEquals(list.get(1), <font color=#004488>"Replace"</font>);
  }
  <font color=#009900>// A "helper" method to reduce code duplication. As long</font>
  <font color=#009900>// as the name doesn't start with "test," it will not</font>
  <font color=#009900>// be automatically executed by JUnit.</font>
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> compare(ArrayList lst, String[] strs) {
    Object[] array = lst.toArray();
    assertTrue(<font color=#004488>"Arrays not the same length"</font>,
      array.length == strs.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; array.length; i++)
      assertEquals(strs[i], (String)array[i]);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> testOrder() {
    System.out.println(<font color=#004488>"Running testOrder()"</font>);
    compare(list, <font color=#0000ff>new</font> String[] { <font color=#004488>"0"</font>, <font color=#004488>"1"</font>, <font color=#004488>"2"</font> });
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> testRemove() {
    System.out.println(<font color=#004488>"Running testRemove()"</font>);
    assertEquals(list.size(), 3);
    list.remove(1);
    assertEquals(list.size(), 2);
    compare(list, <font color=#0000ff>new</font> String[] { <font color=#004488>"0"</font>, <font color=#004488>"2"</font> });
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> testAddAll() {
    System.out.println(<font color=#004488>"Running testAddAll()"</font>);
    list.addAll(Arrays.asList(<font color=#0000ff>new</font> Object[] {
      <font color=#004488>"An"</font>, <font color=#004488>"African"</font>, <font color=#004488>"Swallow"</font>}));
    assertEquals(list.size(), 6);
    compare(list, <font color=#0000ff>new</font> String[] { <font color=#004488>"0"</font>, <font color=#004488>"1"</font>, <font color=#004488>"2"</font>,
       <font color=#004488>"An"</font>, <font color=#004488>"African"</font>, <font color=#004488>"Swallow"</font> });
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Invoke JUnit on the class:</font>
    junit.textui.TestRunner.run(JUnitDemo.<font color=#0000ff>class</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"CountedList #0"</font>,
      <font color=#004488>"CountedList #1"</font>,
      <font color=#004488>"CountedList #2"</font>,
      <font color=#004488>"CountedList #3"</font>,
      <font color=#004488>"CountedList #4"</font>,
      <font color=#009900>// '.' indicates the beginning of each test:</font>
      <font color=#004488>".Set up for 0"</font>,
      <font color=#004488>"Running testInsert()"</font>,
      <font color=#004488>"Tearing down 0"</font>,
      <font color=#004488>".Set up for 1"</font>,
      <font color=#004488>"Running testReplace()"</font>,
      <font color=#004488>"Tearing down 1"</font>,
      <font color=#004488>".Set up for 2"</font>,
      <font color=#004488>"Running testOrder()"</font>,
      <font color=#004488>"Tearing down 2"</font>,
      <font color=#004488>".Set up for 3"</font>,
      <font color=#004488>"Running testRemove()"</font>,
      <font color=#004488>"Tearing down 3"</font>,
      <font color=#004488>".Set up for 4"</font>,
      <font color=#004488>"Running testAddAll()"</font>,
      <font color=#004488>"Tearing down 4"</font>,
      <font color=#004488>""</font>,
      <font color=#004488>"%% Time: .*"</font>,
      <font color=#004488>""</font>,
      <font color=#004488>"OK (5 tests)"</font>,
      <font color=#004488>""</font>,
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>To set up unit testing, you must only <b>import junit.framework.*</b> and extend <b>TestCase</b>, as <b>JUnitDemo</b> does. In addition, you must create a constructor that takes a <b>String</b> argument and passes it to its <b>super</b> constructor. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0198" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>For each test, a new <b>JUnitDemo </b>object will be created, and thus all the non-<b>static </b>members will also be created. This means a new <b>CountedList</b> object (<b>list</b>)<b> </b>will be created and initialized for each test, since it is a field of <b>JUnitDemo</b>. In addition, the constructor will be called for each test, so <b>list</b> will be initialized with the strings &#147;0&#148;, &#147;1&#148;, and &#147;2&#148; before each test is run. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0199" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To observe the behavior of <b>setUp(&#160;) </b>and <b>tearDown(&#160;)</b>, these methods are created to display information about the test that&#146;s being initialized or cleaned up. Note that the base-class methods are <b>protected</b>, so the overridden methods may be either <b>protected</b> or <b>public</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0200" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>testInsert(&#160;)</b> and <b>testReplace(&#160;)</b> demonstrate typical test methods, since they follow the required signature and naming convention. JUnit discovers these methods using reflection and runs each one as a test. Inside the methods, you perform any desired operations and use JUnit assertion methods (which all start with the name &#147;assert&#148;) to verify the correctness of your tests (the full range of &#147;assert&#148; statements can be found in the JUnit javadocs for <b>junit.framework.Assert</b>). If the assertion fails, the expression and values that caused the failure will be displayed. This is usually enough, but you can also use the overloaded version of each JUnit assertion statement and include a <b>String</b> that will be printed if the assertion fails. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0201" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The assertion statements are not required; you can also just run the test without assertions and consider it a success if no exceptions are thrown. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0202" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>compare(&#160;)</b> method is an example of a &#147;helper&#148; method that is not executed by JUnit but instead is used by other tests in the class. As long as the method name doesn&#146;t begin with &#147;test,&#148; JUnit doesn&#146;t run it or expect it to have a particular signature. Here, <b>compare(&#160;)</b> is <b>private</b> to emphasize that it is only used within the test class, but it could also be public. The remaining test methods eliminate duplicate code by refactoring it into the <b>compare(&#160;)</b> method. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0012" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To execute the JUnit tests, the static method <b>TestRunner.run(&#160;)</b> is invoked in <b>main(&#160;)</b>. This method is handed the class that contains the collection of tests, and it automatically sets up and runs all the tests. From the <b>expect(&#160;)</b> output, you can see that all the objects needed to run all the tests are created first, in a batch&#151;this is where the construction happens.<sup><a name="fnB92" href="#fn92">[92]</a></sup> Before each test, the <b>setUp(&#160;)</b> method is called. Then the test is run, followed by the <b>tearDown(&#160;)</b> method. JUnit demarcates each test with a &#145;<b>.</b>&#146;. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0013" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Although you can probably survive easily by only using the simplest approach to JUnit as shown in the preceding example, JUnit was originally designed with a plethora of complicated structures. If you are curious, you can easily learn more about them, because the JUnit download from <i>www.JUnit.org</i> comes with documentation and tutorials. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0197" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775935"></a><a name="Heading22814"></a>Improving reliability with
assertions<br></h2>
<p><a name="Index2022"></a><a name="Index2023"></a><i>Assertions</i>, which you&#146;ve seen used in earlier examples in this book, were added to the JDK 1.4 version of Java in order to aid programmers in improving the reliability of their programs. Properly used, assertions can add to program robustness by verifying that certain conditions are satisfied during the execution of your program. For example, suppose you have a numerical field in an object that represents the month on the Julian calendar. You know that this value must always be in the range 1-12, and an assertion can be used to check this and report an error if it somehow falls outside of that range. If you&#146;re inside a method, you can check the validity of an argument with an assertion. These are important tests to make sure that your program is correct, but they cannot be performed by compile-time checking, and they do not fall into the purview of unit testing. In this section, we&#146;ll look at the mechanics of the assertion mechanism, and the way that you can use assertions to partially implement the <i>design by contract</i> concept. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0208" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775936"></a><a name="Heading22816"></a>Assertion syntax</h3>
<p>Since you can simulate the effect of assertions using other programming constructs, it can be argued that the whole point of adding assertions to Java is that they are easy to write. Assertion statements come in two forms: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0209" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>assert <font color=#0000ff>boolean</font>-expression;
assert <font color=#0000ff>boolean</font>-expression: information-expression;</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Both of these statements say &#147;I assert that the boolean-expression will produce a <b>true</b> value.&#148; If this is not the case, the assertion will produce an <b>AssertionError</b> exception. This is a <b>Throwable</b> subclass, and as such doesn&#146;t require an exception specification. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0210" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Unfortunately, the first form of assertion does <i>not</i> produce any information containing the boolean-expression in the exception produced by a failed assertion (in contrast with most other languages&#146; assertion mechanisms). Here&#146;s an example showing the use of the first form: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0211" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:Assert1.java</font>
<font color=#009900>// Non-informative style of assert</font>
<font color=#009900>// Compile with: javac -source 1.4 Assert1.java</font>
<font color=#009900>// {JVMArgs: -ea} // Must run with -ea</font>
<font color=#009900>// {ThrowsException}</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Assert1 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    assert <font color=#0000ff>false</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Assertions are turned off in JDK 1.4 by default (this is annoying, but the designers managed to convince themselves it was a good idea). To prevent compile-time errors, you must compile with the flag: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0212" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>-source 1.4</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>If you don&#146;t use this flag, you&#146;ll get a chatty message saying that <b>assert</b> is a keyword in JDK 1.4 and cannot be used as an identifier anymore. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0213" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you just run the program the way you normally do, without any special assertion flags, nothing will happen. You must enable assertions when you run the program. The easiest way to do this is with the <b>-ea</b> flag, but you can also spell it out: <b>-enableassertions</b>. This will run the program and execute any assertion statements, so you&#146;ll get: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0214" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Exception in thread <font color=#004488>"main"</font> java.lang.AssertionError
        at Assert1.main(Assert1.java:8)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that the output doesn&#146;t contain much in the way of useful information. On the other hand, if you use the information-expression, you&#146;ll produce a helpful message when the assertion fails. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0215" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To use the second form, you provide an information-expression that will be displayed as part of the exception stack trace. This information-expression can produce any data type at all. However, the most useful information-expression will typically be a string with text that is useful to the programmer. Here&#146;s an example: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0216" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:Assert2.java</font>
<font color=#009900>// Assert with an informative message</font>
<font color=#009900>// {JVMArgs: -ea}</font>
<font color=#009900>// {ThrowsException}</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Assert2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    assert <font color=#0000ff>false</font>: <font color=#004488>"Here's a message saying what happened"</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Now the output is:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Exception in thread <font color=#004488>"main"</font> java.lang.AssertionError: Here's a message saying what happened
        at Assert2.main(Assert2.java:6)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Although what you see here is just a simple <b>String</b> object, the information-expression can produce any kind of object, so you will typically construct a more complex string containing, for example, the value(s) of objects that were involved with the failed assertion. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0217" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Because the only way to see useful information from a failed assertion is to use the information-expression, that is the form that is always used in this book, and the first form will be considered to be a poor choice. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0218" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can also decide to turn assertions on and off based on class name or package name (that is, you can enable or disable assertions in an entire package). You can find the details in the JDK 1.4 documentation on assertions. This can be useful if you have a large project instrumented with assertions and you want to turn some of them off. However, logging or debugging (both described later in this chapter) are probably better tools for capturing that kind of information. This book will just turn on all assertions when necessary, so we will ignore the fine-grained control of assertions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0219" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There&#146;s one other way you can control assertions: programmatically, by hooking into the <b>ClassLoader</b> object. JDK 1.4 added several new methods to <b>ClassLoader</b> that allow the dynamic enabling and disabling of assertions, including <b>setDefaultAssertionStatus(&#160;)</b>, which sets the assertion status for all the classes loaded afterward. So you might think you could almost silently turn on all assertions like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0220" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:LoaderAssertions.java</font>
<font color=#009900>// Using the class loader to enable assertions</font>
<font color=#009900>// Compile with: javac -source 1.4 LoaderAssertions.java</font>
<font color=#009900>// {ThrowsException}</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LoaderAssertions {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ClassLoader.getSystemClassLoader()
      .setDefaultAssertionStatus(<font color=#0000ff>true</font>);
    <font color=#0000ff>new</font> Loaded().go();
  }
}

<font color=#0000ff>class</font> Loaded {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> go() {
    assert <font color=#0000ff>false</font>: <font color=#004488>"Loaded.go()"</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Although this does eliminate the need to use the <b>-ea</b> flag on the command line when the Java program is run, it&#146;s not a complete solution because you must still compile everything with the <b>-source 1.4</b> flag. It may be just as straightforward to enable assertions using command-line arguments; when delivering a standalone product, you probably have to set up an execution script for the user to start the program anyway, in order to configure other startup parameters. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0221" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It does make sense, however, to decide that you want to <i>require</i> assertions to be enabled when the program is run. You can accomplish this with the following <b>static </b>clause, placed in the main class of your system: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0222" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>static</font> {
  <font color=#0000ff>boolean</font> assertionsEnabled = <font color=#0000ff>false</font>;
  <font color=#009900>// Note intentional side effect of assignment:</font>
  assert assertionsEnabled = <font color=#0000ff>true</font>;
  <font color=#0000ff>if</font> (!assertionsEnabled)
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(<font color=#004488>"Assertions disabled"</font>);
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>If assertions are enabled, then the <b>assert</b> statement will be executed and <b>assertionsEnabled</b> will be set to <b>true</b>. The assertion will never fail, because the return value of the assignment is the assigned value. If assertions are not enabled, the <b>assert</b> statement will not be executed and <b>assertionsEnabled</b> will remain <b>false</b>, resulting in the exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0223" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775937"></a><a name="Heading22894"></a>Using Assertions for
<i>Design by Contract</i><br></h3>
<p><a name="Index2024"></a><a name="Index2025"></a><a name="Index2026"></a><i>Design by Contract</i> (DBC) is a concept developed by Bertrand Meyer, creator of the Eiffel programming language, to help in the creation of robust programs by guaranteeing that objects follow certain rules that cannot be verified by compile-time type checking.<sup><a name="fnB93" href="#fn93">[93]</a></sup> These rules are determined by the nature of the problem that is being solved, which is outside the scope of what the compiler can know about and test. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0224" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Although assertions do not directly implement DBC (as does the Eiffel language), they can be used to create an informal style of DBC programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0225" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The fundamental idea of DBC is that a clearly-specified contract exists between the supplier of a service and the consumer or client of that service. In object-oriented programming, services are usually supplied by objects, and the boundary of the object&#151;the division between the supplier and consumer&#151;is the interface of the object&#146;s class. When clients call a particular public method, they are expecting certain behavior from that call: a state change in the object, and a predictable return value. Meyer&#146;s thesis is that: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0226" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>This behavior can be clearly specified, as if it were a contract.</li>
<li>This behavior can be guaranteed by implementing certain run-time checks,
which he calls <i>preconditions</i>, <i>postconditions</i> and
<i>invariants</i>.</li></ol><p>Whether or not you agree that point 1 is always true, it does appear to be true for enough situations to make DBC an interesting approach. (I believe that, like any solution, there are boundaries to its usefulness. But if you know these boundaries, you know when to try to apply it.) In particular, a very valuable part of the design process is the expression of the DBC constraints for a particular class; if you are unable to specify the constraints, you probably don&#146;t know enough about what you&#146;re trying to build. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0227" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading22902"></a>Check instructions</h4>
<p>Before going into in-depth DBC facilities, consider the simplest use for assertions, which Meyer calls the <a name="Index2027"></a><i>check instruction</i>. A check instruction expresses your conviction that a particular property will be satisfied at this point in your code. The idea of the check instruction is to express non-obvious conclusions in code, not only to verify the test, but also as documentation to future readers of the code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0228" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>For example, in a chemistry process, you may be titrating one clear liquid into another, and when you reach a certain point, everything turns blue. This is not obvious from the color of the two liquids; it is part of a complex reaction. A useful check instruction at the completion of the titration process would assert that the resulting liquid is blue. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0229" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Another example is the <b>Thread.holdsLock(&#160;)</b> method introduced in JDK 1.4. This is used for complex threading situations (such as iterating through a collection in a thread-safe way) where you must rely on the client programmer or another class in your system using the library properly, rather than on the <b>synchronized</b> keyword alone. To ensure that the code is properly following the dictates of your library design, you can assert that the current thread does indeed hold the lock: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0230" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>assert Thread.holdsLock(<font color=#0000ff>this</font>); <font color=#009900>// lock-status assertion</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Check instructions are a valuable addition to your code. Since assertions can be disabled, check instructions should be used whenever you have non-obvious knowledge about the state of your object or program. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0231" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading22909"></a>Preconditions</h4>
<p>A precondition is a test to make sure that the client (the code calling this method) has fulfilled its part of the contract. This almost always means checking the arguments at the very beginning of a method call (before you do anything else in that method) to make sure that those arguments are appropriate for use in the method. Since you never know what a client is going to hand you, precondition checks are always a good idea. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0232" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Index2028"></a><a name="Heading22911"></a>Postconditions</h4>
<p>A postcondition test checks the results of what you did in the method. This code is placed at the end of the method call, before the <a name="Index2029"></a><b>return</b> statement, if there is one. For long, complex methods where the result of the calculations should be verified before returning them (that is, in situations where for some reason you cannot always trust the results), postcondition checks are essential, but any time you can describe constraints on the result of the method, it&#146;s wise to express those constraints in code as a postcondition. In Java these are coded as assertions, but the assertion statements will vary from one method to another. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0233" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading22913"></a>Invariants</h4>
<p>An invariant gives guarantees about the state of the object that will be maintained between method calls. However, it doesn&#146;t restrain a method from temporarily diverging from those guarantees during the execution of the method. It just says that the state information of the object will always obey these rules: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0234" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li><a name="Index2030"></a>Upon entry to the method.</li>
<li>Before leaving the
method.</li></ol><p>In addition, the invariant is a guarantee about the state of the object after construction. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0235" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>According to the this description, an effective invariant would be defined as a method, probably named <b>invariant(&#160;)</b>, which would be invoked after construction, and at the beginning and end of each method. The method could be invoked as:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>assert invariant();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This way, if you chose to disable assertions for performance reasons, there would be no overhead at all. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0236" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading22922"></a>Relaxing DBC</h4>
<p>Although he emphasizes the importance of being able to express preconditions, postconditions, and invariants, and the value of using these during development, Meyer admits that it is not always practical to include all DBC code in a shipping product. You may relax DBC checking based on the amount of trust you can place in the code at a particular point. Here is the order of relaxation, from safest to least safe: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0237" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>The invariant check at the beginning of each method may be disabled first,
since the invariant check at the end of each method will guarantee that the
object&#146;s state will be valid at the beginning of every method call. That
is, you can generally trust that the state of the object will not change between
method calls. This one is such a safe assumption that you might choose to write
code with invariant checks only at the end. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0238" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>The postcondition check may be disabled next, if you have reasonable unit
testing that verifies that your methods are returning appropriate values. Since
the invariant check is watching the state of the object, the postcondition check
is only validating the results of the calculation during the method, and
therefore may be discarded in favor of unit testing. The unit testing will not
be as safe as a run-time postcondition check, but it may be enough, especially
if you have enough confidence in the code. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0239" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>The invariant check at the end of a method call may be disabled if you have
enough certainty that the method body does not put the object into an invalid
state. It may be possible to verify this with white-box unit testing (that is,
unit tests that have access to private fields, so they may validate the object
state). Thus, although it may not be quite as robust as calls to
<b>invariant(&#160;)</b>, it is possible to &#147;migrate&#148; the invariant
checking from run-time tests to build-time tests (via unit testing), just as
with postconditions. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0240" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Finally, as a last resort you may disable precondition checks. This is the
least safe and least advisable thing to do, because although you know and have
control over your own code, you have no control over what arguments the client
may pass to a method. However, in a situation where (a) performance is
desperately needed and profiling has pointed at precondition checks as a
bottleneck and (b) you have some kind of reasonable assurance that the client
will not violate preconditions (as in the case where you&#146;ve written the
client code yourself) it may be acceptable to disable precondition checks. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0241" title="Send
BackTalk
Comment">Feedback</a></font></li></ol><p>You shouldn&#146;t remove the code that performs the checks described here as you disable the checks. If a bug is discovered, you&#146;ll want to easily turn on the checks so that you can rapidly discover the problem. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0242" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775938"></a><a name="Heading22929"></a>Example: DBC + white-box
unit testing</h3>
<p>The following example demonstrates the potency of combining concepts from Design by Contract with unit testing. It shows a small first-in, first-out (FIFO) queue class that is implemented as a &#147;circular&#148; array&#151;that is, an array used in a circular fashion. When the end of the array is reached, the class wraps back around to the beginning. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0243" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2031"></a><a name="Index2032"></a>We can make a number of contractual definitions for this queue:<br></p>
<ol>
<li>Precondition (for a <b>put(&#160;)</b>): Null elements are not allowed to be
added to the queue. </li>
<li>Precondition (for a <b>put(&#160;)</b>): It is illegal to put elements into
a full queue.</li>
<li>Precondition (for a <b>get(&#160;)</b>): It is illegal to try to get
elements from an empty queue.</li>
<li>Postcondition (for a <b>get(&#160;)</b>): Null elements cannot be produced
from the array.</li>
<li>Invariant: The region in the array that contains objects cannot contain any
null elements.</li>
<li>Invariant: The region in the array that doesn&#146;t contain objects must
have only null
values.</li></ol><p>Here is one way you could implement these rules, using explicit method calls for each type of DBC element: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0244" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:Queue.java</font>
<font color=#009900>// Demonstration of Design by Contract (DBC) combined</font>
<font color=#009900>// with white-box unit testing.</font>
<font color=#009900>// {Depends: junit.jar}</font>
<font color=#0000ff>import</font> junit.framework.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Queue {
  <font color=#0000ff>private</font> Object[] data;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font>
    in = 0, <font color=#009900>// Next available storage space</font>
    out = 0; <font color=#009900>// Next gettable object</font>
  <font color=#009900>// Has it wrapped around the circular queue?</font>
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> wrapped = <font color=#0000ff>false</font>;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font>
  QueueException <font color=#0000ff>extends</font> RuntimeException {
    <font color=#0000ff>public</font> QueueException(String why) { <font color=#0000ff>super</font>(why); }
  }
  <font color=#0000ff>public</font> Queue(<font color=#0000ff>int</font> size) {
    data = <font color=#0000ff>new</font> Object[size];
    assert invariant(); <font color=#009900>// Must be true after construction</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> empty() {
    <font color=#0000ff>return</font> !wrapped &amp;&amp; in == out;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> full() {
    <font color=#0000ff>return</font> wrapped &amp;&amp; in == out;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> put(Object item) {
    precondition(item != <font color=#0000ff>null</font>, <font color=#004488>"put() null item"</font>);
    precondition(!full(), <font color=#004488>"put() into full Queue"</font>);
    assert invariant();
    data[in++] = item;
    <font color=#0000ff>if</font>(in &gt;= data.length) {
      in = 0;
      wrapped = <font color=#0000ff>true</font>;
    }
    assert invariant();
  }
  <font color=#0000ff>public</font> Object get() {
    precondition(!empty(), <font color=#004488>"get() from empty Queue"</font>);
    assert invariant();
    Object returnVal = data[out];
    data[out] = <font color=#0000ff>null</font>;
    out++;
    <font color=#0000ff>if</font>(out &gt;= data.length) {
      out = 0;
      wrapped = <font color=#0000ff>false</font>;
    }
    assert postcondition(
      returnVal != <font color=#0000ff>null</font>, <font color=#004488>"Null item in Queue"</font>);
    assert invariant();
    <font color=#0000ff>return</font> returnVal;
  }
  <font color=#009900>// Design-by-contract support methods:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  precondition(<font color=#0000ff>boolean</font> cond, String msg) {
    <font color=#0000ff>if</font>(!cond) <font color=#0000ff>throw</font> <font color=#0000ff>new</font> QueueException(msg);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>boolean</font>
  postcondition(<font color=#0000ff>boolean</font> cond, String msg) {
    <font color=#0000ff>if</font>(!cond) <font color=#0000ff>throw</font> <font color=#0000ff>new</font> QueueException(msg);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> invariant() {
    <font color=#009900>// Guarantee that no null values are in the</font>
    <font color=#009900>// region of 'data' that holds objects:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = out; i != in; i = (i + 1) % data.length)
      <font color=#0000ff>if</font>(data[i] == <font color=#0000ff>null</font>)
        <font color=#0000ff>throw</font> <font color=#0000ff>new</font> QueueException(<font color=#004488>"null in queue"</font>);
    <font color=#009900>// Guarantee that only null values are outside the</font>
    <font color=#009900>// region of 'data' that holds objects:</font>
    <font color=#0000ff>if</font>(full()) <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = in; i != out; i = (i + 1) % data.length)
      <font color=#0000ff>if</font>(data[i] != <font color=#0000ff>null</font>)
        <font color=#0000ff>throw</font> <font color=#0000ff>new</font> QueueException(
          <font color=#004488>"non-null outside of queue range: "</font> + dump());
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>private</font> String dump() {
    <font color=#0000ff>return</font> <font color=#004488>"in = "</font> + in +
      <font color=#004488>", out = "</font> + out +
      <font color=#004488>", full() = "</font> + full() +
      <font color=#004488>", empty() = "</font> + empty() +
      <font color=#004488>", queue = "</font> + Arrays.asList(data);
  }
  <font color=#009900>// JUnit testing.</font>
  <font color=#009900>// As an inner class, this has access to privates:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> WhiteBoxTest <font color=#0000ff>extends</font> TestCase {
    <font color=#0000ff>private</font> Queue queue = <font color=#0000ff>new</font> Queue(10);
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 0;
    <font color=#0000ff>public</font> WhiteBoxTest(String name) {
      <font color=#0000ff>super</font>(name);
      <font color=#0000ff>while</font>(i &lt; 5) <font color=#009900>// Preload with some data</font>
        queue.put(<font color=#004488>""</font> + i++);
    }
    <font color=#009900>// Support methods:</font>
    <font color=#0000ff>private</font> <font color=#0000ff>void</font> showFullness() {
      assertTrue(queue.full());
      assertFalse(queue.empty());
      <font color=#009900>// Dump is private, white-box testing allows access:</font>
      System.out.println(queue.dump());
    }
    <font color=#0000ff>private</font> <font color=#0000ff>void</font> showEmptiness() {
      assertFalse(queue.full());
      assertTrue(queue.empty());
      System.out.println(queue.dump());
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> testFull() {
      System.out.println(<font color=#004488>"testFull"</font>);
      System.out.println(queue.dump());
      System.out.println(queue.get());
      System.out.println(queue.get());
      <font color=#0000ff>while</font>(!queue.full())
        queue.put(<font color=#004488>""</font> + i++);
      String msg = <font color=#004488>""</font>;
      <font color=#0000ff>try</font> {
        queue.put(<font color=#004488>""</font>);
      } <font color=#0000ff>catch</font>(QueueException e) {
        msg = e.getMessage();
        System.out.println(msg);
      }
      assertEquals(msg, <font color=#004488>"put() into full Queue"</font>);
      showFullness();
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> testEmpty() {
      System.out.println(<font color=#004488>"testEmpty"</font>);
      <font color=#0000ff>while</font>(!queue.empty())
        System.out.println(queue.get());
      String msg = <font color=#004488>""</font>;
      <font color=#0000ff>try</font> {
        queue.get();
      } <font color=#0000ff>catch</font>(QueueException e) {
        msg = e.getMessage();
        System.out.println(msg);
      }
      assertEquals(msg, <font color=#004488>"get() from empty Queue"</font>);
      showEmptiness();
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> testNullPut() {
      System.out.println(<font color=#004488>"testNullPut"</font>);
      String msg = <font color=#004488>""</font>;
      <font color=#0000ff>try</font> {
        queue.put(<font color=#0000ff>null</font>);
      } <font color=#0000ff>catch</font>(QueueException e) {
        msg = e.getMessage();
        System.out.println(msg);
      }
      assertEquals(msg, <font color=#004488>"put() null item"</font>);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> testCircularity() {
      System.out.println(<font color=#004488>"testCircularity"</font>);
      <font color=#0000ff>while</font>(!queue.full())
        queue.put(<font color=#004488>""</font> + i++);
      showFullness();
      <font color=#009900>// White-box testing accesses private field:</font>
      assertTrue(queue.wrapped);
      <font color=#0000ff>while</font>(!queue.empty())
        System.out.println(queue.get());
      showEmptiness();
      <font color=#0000ff>while</font>(!queue.full())
        queue.put(<font color=#004488>""</font> + i++);
      showFullness();
      <font color=#0000ff>while</font>(!queue.empty())
        System.out.println(queue.get());
      showEmptiness();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    junit.textui.TestRunner.run(Queue.WhiteBoxTest.<font color=#0000ff>class</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>in</b> counter indicates the place in the array where the next object will go into, and the <b>out</b> counter indicates where the next object will come from. The <b>wrapped</b> flag shows that <b>in</b> has gone &#147;around the circle&#148; and is now coming up from behind <b>out</b>. When <b>in</b> and <b>out</b> coincide, the queue is empty (if <b>wrapped</b> is false) or full (if <b>wrapped</b> is true). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0245" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can see that the <b>put(&#160;)</b> and <b>get(&#160;)</b> methods call the methods <b>precondition(&#160;)</b>, <b>postcondition(&#160;)</b>, and <b>invariant(&#160;)</b>, which are <b>private</b> methods defined further down in the class. <b>precondition(&#160;)</b> and <b>postcondition(&#160;)</b> are helper methods designed to clarify the code. Note that <b>precondition(&#160;)</b> returns <b>void</b>, because it is not used with <b>assert</b>. As previously noted, you&#146;ll generally want to keep preconditions in your code; however, by wrapping them in a <b>precondition(&#160;)</b> method call, you have better options if you are reduced to the dire move of turning them off. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0246" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>postcondition(&#160;)</b> and <b>invariant(&#160;) </b>return a Boolean value so that they can be used in <b>assert</b> statements. Then, if assertions are disabled for performance reasons, there will be no method calls at all. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0247" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>invariant(&#160;)</b> performs internal validity checks on the object. You can see that this is an expensive operation to do at both the beginning and ending of every method call, as Meyer suggests. However, it&#146;s very valuable to have this clearly represented in code, and it helped me get the implementation to be correct. In addition, if you make any changes to the implementation, the <b>invariant(&#160;)</b> will ensure that you haven&#146;t broken the code. But you can see that it would be fairly trivial to move the invariant tests from the method calls into the unit test code. If your unit tests are reasonably thorough, you can have a reasonable level of confidence that the invariants will be respected. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0248" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Notice that the <b>dump(&#160;)</b> helper method returns a string containing all the data rather than printing the data directly. This approach allows many more options as to how the information can be used. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0249" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>TestCase</b> subclass <a name="Index2033"></a><b>WhiteBoxTest</b> is created as an inner class so that it has access to the <b>private</b> elements of <b>Queue</b> and is thus able to validate the underlying implementation, not just the behavior of the class as in a white-box test. The constructor adds some data so that the <b>Queue</b> is partially full for each test. The support methods <b>showFullness(&#160;)</b> and <b>showEmptiness(&#160;)</b> are meant to be called to verify that the <b>Queue</b> is full or empty, respectively. Each of the four test methods ensures that a different aspect of the <b>Queue</b> operation functions correctly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0250" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that by combining DBC with unit testing, you not only get the best of both worlds, but you also have a migration path&#151;you can move DBC tests to unit tests rather than simply disabling them, so you still have some level of testing. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0251" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775939"></a><a name="Heading23119"></a>Building with Ant<br></h2>
<p><a name="Index2034"></a><a name="Index2035"></a><a name="Index2036"></a>I began my career writing assembly-language programs that controlled real-time devices. These programs usually fit into a single file, so when I was introduced to the <b>make </b>utility, I wasn&#146;t too excited, because the most complex thing I had ever needed to do was run an assembler or a C compiler on a few files of code. Back then, building a project wasn&#146;t the difficult part of my task, and it wasn&#146;t too cumbersome to run everything by hand. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0252" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Time passed, and two events occurred. First, I started to create more complex projects comprising many more files. Keeping track of which files needed compilation became more than I was able (or wanted) to think about. Second, because of this complexity I began to realize that no matter how simple the build process might be, if you do something more than a couple of times, you begin to get sloppy, and parts of the process start to fall through the cracks. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0253" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775940"></a><a name="Heading23122"></a>Automate everything</h3>
<p>I came to realize that for a system to be built in a robust and reliable fashion, I needed to automate <i>everything</i> that goes into the build process. This requires some concentration up front, just like writing a program requires concentration, but the payoff is that you solve the problems <i>once</i>, and you rely on your build configuration to take care of the details from then on. It&#146;s a variation of the fundamental programming principle of <i>abstraction</i>: We raise ourselves up from the grinding details by hiding those details inside a process and giving that process a name. For many years, the name of that process was <b>make</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0254" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <a name="Index2037"></a><b>make</b> utility appeared along with C as a tool to create the Unix operating system. <b>make</b>&#146;s primary function is to compare the date of two files and to perform some operation that will bring those two files up-to-date with each other. The relationships between all the files in your projects and the rules necessary to bring them up-to-date (the rule is usually running the C/C++ compiler on a source file) are contained in a <a name="Index2038"></a><i>makefile</i>. The programmer creates a makefile containing the description of how to build the system. When you want to bring the system up-to-date, you simply type <b>make</b> at the command line. To this day, installing Unix/Linux programs consists of unpacking them and typing <b>make</b> commands. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0255" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775941"></a><a name="Heading23125"></a>Problems with
<b>make</b></h3>
<p>The concept of <b>make</b> is clearly a good idea, and this idea proliferated to produce many versions of <b>make</b>. C and C++ compiler vendors typically included their own variation of <b>make</b> along with their compiler&#151;these variations often took liberties with what people considered to be the standard makefile rules, so the resulting makefiles wouldn&#146;t run with each other. The problem was finally solved (as has often been the case) by a <b>make</b> that was, and still is, superior to all the other <b>make</b>s, and is also free, so there&#146;s no resistance to using it: GNU <a name="Index2039"></a><b>make</b>.<sup><a name="fnB94" href="#fn94">[94]</a></sup> This tool has a significantly better feature set than the other versions of <b>make</b> and is available on all platforms. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0256" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In the previous two editions of <i>Thinking in Java</i>, I used makefiles to build all the code in the book&#146;s source-code tree. I automatically generated these makefiles&#151;one in each directory, and a master makefile in the root directory that would call the rest&#151;using a tool that I originally wrote in C++ (in about 2 weeks) for <i>Thinking in C++</i>,<i> </i>and later rewrote in Python (in about half a day) called <b>MakeBuilder.py</b>.<sup><a name="fnB95" href="#fn95">[95]</a></sup> It worked for both Windows and Linux/Unix, but I had to write extra code to make this happen, and I never tried it on the Macintosh. Therein lies the first problem with <b>make</b>: You <i>can</i> get it to work on multiple platforms, but it&#146;s not inherently cross-platform. So for a language that&#146;s supposed to be &#147;write once, run anywhere&#148; (that is, Java), you can spend a lot of effort getting the same behavior in the build system if you use <b>make</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0257" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The rest of the problems with <b>make</b> can probably be summarized by saying that it is like a lot of tools developed for Unix; the person creating the tool couldn&#146;t resist the temptation to create their own language syntax, and as a result, Unix is filled with tools that are all remarkably different, and equally incomprehensible. That is to say, the <b>make</b> syntax is quite difficult to understand in its entirety&#151;I&#146;ve been learning it for years&#151;and has lots of annoying things like its insistence on tabs instead of spaces.<sup><a name="fnB96" href="#fn96">[96]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0258" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>All that said, note that I still find GNU <b>make</b> indispensable for many of the projects I create. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0259" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775942"></a><a name="Heading23133"></a>Ant: the defacto
standard</h3>
<p>All of these issues with <b>make</b> irritated a Java programmer named James Duncan Davidson enough to cause him to create Ant as an open-source tool that migrated to the Apache project at <i>http://jakarta.apache.org/ant</i>. This site contains the full download including the Ant<b> </b>executable and documentation. Ant has grown and improved until it is now generally accepted as the defacto standard build tool for Java projects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0260" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To make Ant cross-platform, the format for the project description files is XML (covered in <i>Thinking in Enterprise Java</i>). Instead of a makefile, you create a buildfile, which is named by default <a name="Index2040"></a><a name="Index2041"></a><b>build.xml</b> (this allows you to just say &#145;<b>ant</b>&#146; on the command line. If you name your buildfile something else, you have to specify that name with a command-line flag). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0261" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The only rigid requirement for your buildfile is that it be a valid XML file. Ant<b> </b>compensates for platform-specific issues like end-of-line characters and directory path separators. You can use tabs or spaces in the buildfile as you prefer. In addition, the syntax and tag names used in buildfiles result in readable, understandable (and thus, maintainable) code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0262" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>On top of all this, Ant is designed to be extensible, with a standard interface that allows you to write your own tasks if the ones that come with Ant aren&#146;t enough (however, they usually are, and the arsenal is regularly expanding). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0263" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Unlike <b>make</b>, the learning curve for Ant is reasonably gentle. You don&#146;t need to know much in order to create a buildfile that compiles Java code in a directory. Here&#146;s a very basic <b>build.xml</b> file, for example, from Chapter 2 of this book: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0264" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;?xml version=<font color=#004488>"1.0"</font>?&gt;

&lt;project name=<font color=#004488>"Thinking in Java (c02)"</font> 
  <font color=#0000ff>default</font>=<font color=#004488>"c02.run"</font> basedir=<font color=#004488>"."</font>&gt;
  &lt;!-- build all classes in <font color=#0000ff>this</font> directory --&gt;
  &lt;target name=<font color=#004488>"c02.build"</font>&gt;
    &lt;javac
      srcdir=<font color=#004488>"${basedir}"</font>
      classpath=<font color=#004488>"${basedir}</font><font color=#004488>/.."</font>
      source=<font color=#004488>"1.4"</font>
    /&gt;
  &lt;/target&gt;

  &lt;!-- run all classes in <font color=#0000ff>this</font> directory --&gt;
  &lt;target name=<font color=#004488>"c02.run"</font> depends=<font color=#004488>"c02.build"</font>&gt;
    &lt;antcall target=<font color=#004488>"HelloDate.run"</font>/&gt;
  &lt;/target&gt;

  &lt;target name=<font color=#004488>"HelloDate.run"</font>&gt;
    &lt;java
      taskname=<font color=#004488>"HelloDate"</font>
      classname=<font color=#004488>"HelloDate"</font>
      classpath=<font color=#004488>"${basedir};${basedir}</font><font color=#004488>/.."</font>
      fork=<font color=#004488>"true"</font>
      failonerror=<font color=#004488>"true"</font>
    /&gt;
  &lt;/target&gt;

  &lt;!-- delete all <font color=#0000ff>class</font> files --&gt;
  &lt;target name=<font color=#004488>"clean"</font>&gt;
    &lt;delete&gt;
      &lt;fileset dir=<font color=#004488>"${basedir}"</font> includes=<font color=#004488>"**</font><font color=#004488>/*.class"</font>/&gt;
      &lt;fileset dir=<font color=#004488>"${basedir}"</font> includes=<font color=#004488>"**</font><font color=#004488>/*Output.txt"</font>/&gt;
    &lt;/delete&gt;
    &lt;echo message=<font color=#004488>"clean successful"</font>/&gt;
  &lt;/target&gt;

&lt;/project&gt;</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The first line states that this file conforms to version 1.0 of XML. XML looks a lot like HTML (notice the comment syntax is identical), except that you can make up your own tag names and the format must strictly conform to XML rules. For example, an opening tag like <b>&lt;project </b>must either end within the tag at its closing angle brace with a slash (<b>/&gt;</b>) or have a matching closing tag like you see at the end of the file (<b>&lt;/project&gt;</b>). Within a tag you can have <i>attributes</i>, but the attribute values must be surrounded in quotes. XML allows free formatting, but indentation like you see here is typical. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0265" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Each buildfile can manage a single project described by its <b>&lt;project&gt;</b> tag. The project has an optional <b>name</b> attribute that is used when displaying information about the build. The <b>default</b> attribute is required and refers to the <i>target</i> that is built when you just type <b>ant</b> at the command line without giving a specific target name. The directory reference <b>basedir </b>can be used in other places in the buildfile. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0266" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A target has <a name="Index2042"></a><i>dependencies</i> and <a name="Index2043"></a><i>tasks</i>. The dependencies say &#147;which other targets must be built before this target can be built?&#148; You&#146;ll notice that the <b>default</b> target to build is <b>c02.run</b>, and the <b>c02.run</b> <b>target</b> says that it in turn depends on <b>c02.build</b>. Thus, the <b>c02.build</b> target must be executed before <b>c02.run </b>can be executed. Partitioning the buildfile this way not only makes it easier to understand, but it also allows you to choose what you want to do via the Ant command line; if you say &#145;<b>ant c02.build</b>,&#146; then it will only compile the code, but if you say &#145;<b>ant co2.run</b>&#146; (or, because of the default target, just &#145;<b>ant</b>&#146;), then it will first make sure things have been built, and then run the examples. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0267" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>So, for the project to be successful, targets <b>c02.build</b> and <b>c02.run</b> must first succeed, in that order. The <b>c02.build</b> target contains a single <i>task</i>, which is a command that actually does the work of bringing things up-to-date. This task runs the <b>javac</b> compiler on all the Java files in this current base directory; notice the <b>${}</b> syntax used to produce the value of a previously-defined variable, and that the orientation of slashes in directory paths is not important, since Ant compensates depending on the operating system you run it on. The <a name="Index2044"></a><b>classpath</b> attribute gives a directory list to <i>add</i> to Ant&#146;s classpath, and <b>source</b> specifies the compiler to use (this is actually only noticed by JDK 1.4 and beyond). Note that the Java compiler is responsible for sorting out the dependencies between the classes themselves, so you don&#146;t have to explicitly state inter-file dependencies like you must with <b>make</b> and C/C++ (this saves a lot of effort). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0268" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To run the programs in the directory (which, in this case, is only the single program <b>HelloDate</b>), this buildfile uses a task named <a name="Index2045"></a><b>antcall</b>. This task does a recursive invocation of Ant on another target, which in this case just uses <b>java</b> to execute the program. Note that the <b>java</b> task has a <b>taskname</b> attribute; this attribute is actually available for all tasks, and is used when Ant outputs logging information. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0269" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>As you might expect, the <b>java</b> tag also has options to establish the class name to be executed, and the classpath. In addition, the <br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>fork=<font color=#004488>"true"</font>
failonerror=<font color=#004488>"true"</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>attributes tell Ant to fork off a new process to run this program, and to fail the Ant build if the program fails. You can look up all the different tasks and their attributes in the documentation that comes with the Ant download. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0270" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The last target is one that&#146;s typically found in every buildfile; it allows you to say <b>ant clean</b> and delete all the files that have been created in order to perform this build. Whenever you create a buildfile, you should be careful to include a <b>clean</b> target, because you&#146;re the person who typically knows the most about what can be deleted and what should be preserved. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0271" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>clean</b> target introduces some new syntax. You can delete single items with the one-line version of this task, like this:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;delete file=<font color=#004488>"${basedir}</font><font color=#004488>/HelloDate.class"</font>/&gt;</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The multiline version of the task allows you to specify a <i>fileset</i>, which is a more complex description of a set of files and may specify files to include and exclude by using wildcards. In this example, the filesets to delete include all files in this directory and all subdirectories that have a <b>.class</b> extension, and all files in the current subdirectory that end with <b>Output.txt</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0272" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The buildfile shown here is fairly simple; within this book&#146;s source code tree (which is downloadable from www.BruceEckel.com) you&#146;ll find more complex buildfiles. Also, Ant is capable of doing much more that what we use for this book. For the full details of its capabilities, see the documentation that comes with the Ant installation. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0273" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading23194"></a>Ant extensions</h4>
<p>Ant comes with an extension API so that you can create your own tasks by writing them in Java. You can find full details in the official Ant documentation and in the published books on Ant. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0274" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2046"></a>As an alternative, you can simply write a Java program and call it from Ant; this way, you don&#146;t have to learn the extension API. For example, to compile the code in this book, we need to verify that the version of Java that the user is running is JDK 1.4 or greater, so we created the following program: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0275" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:tools:CheckVersion.java</font>
<font color=#009900>// {RunByHand}</font>
<font color=#0000ff>package</font> com.bruceeckel.tools;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CheckVersion {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String version = System.getProperty(<font color=#004488>"java.version"</font>);
    <font color=#0000ff>char</font> minor = version.charAt(2);
    <font color=#0000ff>char</font> point = version.charAt(4);
    <font color=#0000ff>if</font>(minor &lt; '4' || point &lt; '1')
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(<font color=#004488>"JDK 1.4.1 or higher "</font> +
        <font color=#004488>"is required to run the examples in this book."</font>);
    System.out.println(<font color=#004488>"JDK version "</font>+ version + <font color=#004488>" found"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This simply uses <b>System.getProperty(&#160;)</b> to discover the Java version, and throws an exception if it isn&#146;t at least 1.4. When Ant sees the exception, it will halt. Now you can include the following in any buildfile where you want to check the version number: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0276" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    &lt;java
      taskname=<font color=#004488>"CheckVersion"</font>
      classname=<font color=#004488>"com.bruceeckel.tools.CheckVersion"</font>
      classpath=<font color=#004488>"${basedir}"</font>
      fork=<font color=#004488>"true"</font>
      failonerror=<font color=#004488>"true"</font>
    /&gt;</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>If you use this approach to adding tools, you can write them and test them quickly, and if it&#146;s justified, you can invest the extra effort and write an Ant extension. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0277" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775943"></a><a name="Heading23223"></a>Version control with
CVS</h3>
<p>A <a name="Index2047"></a><a name="Index2048"></a><a name="Index2049"></a><i>revision control system</i> is a class of tool that has been developed over many years to help manage large team programming projects. It has also turned out to be fundamental to the success of virtually all open-source projects, because open-source teams are almost always distributed globally via the Internet. So even if there are only two people working on a project, they benefit from using a revision control system. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0278" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The defacto standard revision control system for open-source projects is called Concurrent Versions System (CVS), available at <i>www.cvshome.org</i>. Because it is open-source and so many people know how to use it, CVS is also a common choice for closed projects. Some projects even use CVS as a way to distribute the system. CVS has the usual benefits of a popular open-source project: the code has been thoroughly reviewed, it&#146;s available for your review and modification, and flaws are rapidly corrected. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0279" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>CVS keeps your code in a repository on a server. This server may be on a local area network, but it is typically available on the Internet so that people on the team can get updates without being at a particular location. To connect to CVS, you must have an assigned user name and password, so there&#146;s a reasonable level of security; for more security, you can use the <b>ssh</b> protocol (although these are Linux tools, they are readily available in Windows using Cygwin&#151;see <i>www.cygwin.com</i>). Some graphical development environments (like the free Eclipse editor; see <i>www.eclipse.org</i>) provide excellent integration with CVS. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0280" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once the repository is initialized by your system administrator, team members may get a copy of the code tree by checking it out. For example, once your machine is logged into the appropriate CVS server (details of which are omitted here), you can perform the initial checkout with a command like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0281" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cvs &#150;z5 co TIJ3</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This will connect with the CVS server and negotiate the checkout (&#145;<b>co</b>&#146;) of the code repository called <b>TIJ3</b>. The &#145;<b>-z5</b>&#146; argument tells the CVS programs at both ends to communicate using a gzip compression level of 5 in order to speed up the transfer over the network. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0282" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once this command is completed, you&#146;ll have a copy of the code repository on your local machine. In addition, you&#146;ll see that each directory in the repository has an additional subdirectory named CVS. This is where all the CVS information about the files in that directory are stored. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0283" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Now that you have your own copy of the CVS repository, you can make changes to the files in order to develop the project. Typically, these changes include corrections and feature additions along with test code and modified buildfiles necessary to compile and run the tests. You&#146;ll find that it&#146;s very unpopular to check in code that doesn&#146;t successfully run all its tests, because then everyone else on the team will get the broken code (and thus fail their builds). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0284" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When you&#146;ve made your improvements and you&#146;re ready to check them in, you must go through a two-step process that is the crux of CVS code synchronization. First, you update your local repository to synchronize it with the main CVS repository by moving into the root of your local code repository and running this command: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0285" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cvs update &#150;dP</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>At this point, you aren&#146;t required to log in because the CVS subdirectory keeps the login information for the remote repository, and the remote repository keeps signature information about your machine as a double check to verify your identity. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0286" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The &#145;<b>-dP</b>&#146; flag is optional; &#145;<b>-d</b>&#146; tells CVS to create any new directories on your local machine that might have been added to the main repository, and &#145;<b>-P</b>&#146; tells CVS to prune off any directories on your local machine that have been emptied on the main repository. Neither of these things happens by default. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0287" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The main activity of <a name="Index2050"></a><b>update</b>, however, is quite interesting. You should actually run <b>update</b> on a regular basis, not just before you do a checkin, because it synchronizes your local repository with the main repository. If it finds any files in the main repository that are newer than files on your local repository, it brings the changes onto your local machine. However, it doesn&#146;t just copy the files, but instead does a line-by-line comparison of the files and patches the changes from the main repository into your local version. If you&#146;ve made some changes to a file and someone else has made changes to the same file, CVS will patch the changes together as long as the changes don&#146;t happen to the same lines of code (CVS matches the <i>contents</i> of the lines, and not just the line numbers, so even if line numbers change, it will be able to synchronize properly). Thus, you can be working on the same file as someone else, and when you do an <b>update</b>, any changes the other person has committed to the main repository will be merged with your changes. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0288" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Of course, it&#146;s possible that two people might make changes to the same lines of the same file. This is an accident due to lack of communication; normally you&#146;ll tell each other what you&#146;re working on so as not to tread on each other&#146;s code (also, if files are so big that it makes sense for two different people to work on different parts of the same file, you might consider breaking up the big files into smaller files for easier project management). If this happens, CVS simply notes the collision and forces you to resolve it by fixing the lines of code that collide. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0289" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note that no files from your machine are moved into the main repository during an <b>update</b>. The <b>update</b> brings only changed files from the main repository onto your machine and patches in any modifications you&#146;ve made. So how do your modifications get into the main repository? This is the second step: the <a name="Index2051"></a><b>commit</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0290" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When you type<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cvs commit</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>CVS will start up your default editor and ask you to write a description of your modification. This description will be entered into the repository so that others will know what&#146;s been changed. After that, your modified files will be placed into the main repository so they are available to everyone else the next time they do an <b>update</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0291" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>CVS has other capabilities, but checking out, updating, and committing are what you&#146;ll be doing most of the time. For detailed information about CVS, books are available, and the main CVS Web site has full documentation: <i>www.cvshome.org</i>. In addition, you can search on the Internet using Google or other search engines; there are some very nice condensed introductions to CVS that can get you started without bogging you down with too many details (the &#147;Gentoo Linux CVS Tutorial&#148; by Daniel Robbins (<i>www.gentoo.org/doc/cvs-tutorial.html</i>) is particularly straightforward). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0292" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775944"></a><a name="Heading23246"></a>Daily builds</h3>
<p>By incorporating compilation and testing into your buildfiles, you can follow the practice of performing <a name="Index2052"></a><a name="Index2053"></a><i>daily builds</i>, advocated by the Extreme Programming folks and others. Regardless of the number of features that you currently have implemented, you always keep your system in a state in which it can be successfully built, so that if someone performs a checkout and runs Ant, the buildfile will perform all the compilations and run all the tests without failing. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0293" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2054"></a>This is a powerful technique. It means that you always have, as a baseline, a system that compiles and passes all its tests. At any time, you can always see what the true state of the development process is by examining the features that are actually implemented in the running system. One of the timesavers of this approach is that no one has to waste time coming up with a report explaining what is going on with the system; everybody can see for themselves by checking out a current build and running the program. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0294" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Running builds daily, or more often, also ensures that if someone (accidentally, we presume) checks in changes that cause tests to fail, you&#146;ll know about it in short order, before those bugs have a chance to propagate further problems in the system. Ant even has a task that will send email, because many teams set up their buildfile as a <b>cron</b><sup><a name="fnB97" href="#fn97">[97]</a></sup> job to automatically run daily, or even several times a day, and send email if it fails. There is also an open-source tool that automatically performs builds and provides a Web page to show the project status; see <i>http://cruisecontrol.sourceforge.net</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0295" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775945"></a><a name="Heading23251"></a>Logging<br></h2>
<p><a name="Index2055"></a><a name="Index2056"></a><a name="Index2057"></a><i>Logging</i> is the process of reporting information about a running program. In a debugged program, this information can be ordinary status data that describes the progress of the program (for example, if you have an installation program, you may log the steps taken during installation, the directories where you stored files, startup values for the program, etc.). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0014" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Logging is also very useful during debugging. Without logging, you might try to decipher the behavior of a program by inserting <b>println(&#160;)</b> statements. Many examples in this book use that very technique, and in the absence of a debugger (a topic that will be introduced shortly), it&#146;s about all you have. However, once you decide the program is working properly, you&#146;ll probably take the <b>println(&#160;) </b>statements out. Then if you run into more bugs, you may need to put them back in. It&#146;s much nicer if you can put in some kind of output statements, which will only be used when necessary. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0015" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Prior to the availability of the logging API in JDK 1.4, programmers would often use a technique that relies on the fact that the Java compiler will optimize away code that will never be called. If <b>debug </b>is a <b>static final</b> <b>boolean </b>and you say: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0016" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(debug) {
  System.out.println(<font color=#004488>"Debug info"</font>);
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>then when <b>debug</b> is <b>false</b>, the compiler will completely remove the code within the braces (thus the code doesn&#146;t cause any run-time overhead at all when it isn&#146;t used). Using this technique, you can place trace code throughout your program and easily turn it on and off. One drawback to the technique, however, is that you must recompile your code in order to turn your trace statements on and off, whereas it&#146;s generally more convenient to be able to turn on the trace without recompiling the program by using a configuration file that you can change to modify the logging properties. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0017" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The logging API in JDK 1.4 provides a more sophisticated facility to report information about your program with almost the same efficiency of the technique in the preceding example. For very simple informational logging, you can do something like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0018" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:InfoLogging.java</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InfoLogging {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"InfoLogging"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    logger.info(<font color=#004488>"Logging an INFO-level message"</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% .* InfoLogging main"</font>,
      <font color=#004488>"INFO: Logging an INFO-level message"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The output during one run is:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Jul 7, 2002 6:59:46 PM InfoLogging main
INFO: Logging an INFO-level message</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Notice that the logging system has detected the class name and method name from which the log message originated. It&#146;s not guaranteed that these names will be correct, so you shouldn&#146;t rely on their accuracy. If you want to ensure that the proper class name and method are printed, you can use a more complex method to log the message, like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0019" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:InfoLogging2.java</font>
<font color=#009900>// Guaranteeing proper class and method names</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InfoLogging2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"InfoLogging2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    logger.logp(Level.INFO, <font color=#004488>"InfoLogging2"</font>, <font color=#004488>"main"</font>,
      <font color=#004488>"Logging an INFO-level message"</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% .* InfoLogging2 main"</font>,
      <font color=#004488>"INFO: Logging an INFO-level message"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>logp(&#160;)</b> method takes arguments of the logging level (you&#146;ll learn about this next), the class name and method name, and the logging string. You can see that it&#146;s much simpler to just rely on the automatic approach if the class and method names reported during logging are not critical. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0020" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775946"></a><a name="Heading23305"></a>Logging Levels</h3>
<p>The logging API provides multiple levels of reporting and the ability to change to a different level during program execution. Thus, you can dynamically set the logging level to any of the following states: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0021" title="Send BackTalk Comment">Feedback</a></font><br></p>
<div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>Level</b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p><b>Effect</b><br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p><b>Numeric Value</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>OFF</b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>No logging messages are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p><b>Integer.MAX_VALUE</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>SEVERE </b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>Only logging messages with the level SEVERE are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p>1000<br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>WARNING </b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>Logging messages with levels of WARNING and SEVERE are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p>900<br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>INFO </b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>Logging messages with levels of INFO and above are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p>800<br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>CONFIG </b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>Logging messages with levels of CONFIG and above are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p>700<br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>FINE </b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>Logging messages with levels of FINE and above are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p>500<br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>FINER </b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>Logging messages with levels of FINER and above are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p>400<br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>FINEST </b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>Logging messages with levels of FINEST and above are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p>300<br></p>
</td>
</tr>
<tr valign="top">
<td width="94.666643" colspan="1" rowspan="1" valign="top">
<p><b>ALL</b><br></p>
</td>
<td width="162.666626" colspan="1" rowspan="1" valign="top">
<p>All logging messages are reported.<br></p>
</td>
<td width="177.333289" colspan="1" rowspan="1" valign="top">
<p><b>Integer.MIN_VALUE</b><br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">You can even inherit from <b>java.util.Logging.Level</b> (which has <b>protected</b> constructors) and define your own level. This could, for example, have a value of less than 300, so the level is less than FINEST. Then logging messages at your new level would not appear when the level is FINEST. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0296" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can see the effect of trying out the different levels of logging in the following example: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0022" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:LoggingLevels.java</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.Level;
<font color=#0000ff>import</font> java.util.logging.Logger;
<font color=#0000ff>import</font> java.util.logging.Handler;
<font color=#0000ff>import</font> java.util.logging.LogManager;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LoggingLevels {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger
    lgr = Logger.getLogger(<font color=#004488>"com"</font>),
    lgr2 = Logger.getLogger(<font color=#004488>"com.bruceeckel"</font>),
    util = Logger.getLogger(<font color=#004488>"com.bruceeckel.util"</font>),
    test = Logger.getLogger(<font color=#004488>"com.bruceeckel.test"</font>),
    rand = Logger.getLogger(<font color=#004488>"random"</font>);
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> logMessages() {
    lgr.info(<font color=#004488>"com : info"</font>);
    lgr2.info(<font color=#004488>"com.bruceeckel : info"</font>);
    util.info(<font color=#004488>"util : info"</font>);
    test.severe(<font color=#004488>"test : severe"</font>);
    rand.info(<font color=#004488>"random : info"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    lgr.setLevel(Level.SEVERE);
    System.out.println(<font color=#004488>"com level: SEVERE"</font>);
    logMessages();
    util.setLevel(Level.FINEST);
    test.setLevel(Level.FINEST);
    rand.setLevel(Level.FINEST);
    System.out.println(<font color=#004488>"individual loggers set to FINEST"</font>);
    logMessages();
    lgr.setLevel(Level.SEVERE);
    System.out.println(<font color=#004488>"com level: SEVERE"</font>);
    logMessages();
    monitor.expect(<font color=#004488>"LoggingLevels.out"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The first few lines of <b>main(&#160;)</b> are necessary because the default level of logging messages that will be reported is <b>INFO</b> and greater (more severe). If you do not change this, then the messages of level <b>CONFIG</b> and below will not be reported (try taking out the lines to see this happen).<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0023" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can have multiple logger objects in your program, and these loggers are organized into a hierarchical tree, which can be programmatically associated with the package namespace. Child loggers keep track of their immediate parent and by default pass the logging records up to the parent. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0024" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The &#147;root&#148; logger object is always created by default, and is the base of the tree of logger objects. You get a reference to the root logger by calling the static method <b>Logger.getLogger("")</b>. Notice that it takes an empty string rather than no arguments. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0025" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Each <b>Logger</b> object can have one or more <b>Handler</b> objects associated with it. Each <b>Handler</b> object provides a <i>strategy<sup><a name="fnB98" href="#fn98">[98]</a></sup></i> for publishing the logging information, which is contained in <b>LogRecord</b> objects. To create a new type of <b>Handler</b>, you simply inherit from the <b>Handler</b> class and override the <b>publish(&#160;)</b> method (along with <b>flush(&#160;)</b> and <b>close(&#160;)</b>, to deal with any streams you may use in the <b>Handler</b>).<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0026" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The root logger always has one associated handler by default, which sends output to the console. In order to access the handlers, you call <b>getHandlers(&#160;)</b> on the <b>Logger</b> object. In the preceding example, we know that there&#146;s only one handler so we don&#146;t technically need to iterate through the list, but it&#146;s safer to do so in general because someone else may have added other handlers to the root logger. The default level of each handler is <b>INFO</b>, so in order to see all the messages, we set the level to <b>ALL</b> (which is the same as <b>FINEST</b>).<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0027" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>levels</b> array allows easy testing of all the <b>Level</b> values. The <b>logger</b> is set to each value and all the different logging levels are attempted. In the output you can see that only messages at the currently selected logging level, and those messages that are more severe, are reported. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0028" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775947"></a><a name="Heading23384"></a>LogRecords</h3>
<p>A <b>LogRecord</b> is an example of a <a name="Index2058"></a><i>Messenger</i> object,<sup><a name="fnB99" href="#fn99">[99]</a></sup> whose job is simply to carry information from one place to another. All the methods in the <b>LogRecord</b> are getters and setters. Here&#146;s an example that dumps all the information stored in a <b>LogRecord</b> using the getter methods: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0029" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:PrintableLogRecord.java</font>
<font color=#009900>// Override LogRecord toString()</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.ResourceBundle;
<font color=#0000ff>import</font> java.util.logging.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintableLogRecord <font color=#0000ff>extends</font> LogRecord {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>public</font> PrintableLogRecord(Level level, String str) {
    <font color=#0000ff>super</font>(level, str);
  }
  <font color=#0000ff>public</font> String toString() {
    String result = <font color=#004488>"Level&lt;"</font> + getLevel() + <font color=#004488>"&gt;\n"</font>
      + <font color=#004488>"LoggerName&lt;"</font> + getLoggerName() + <font color=#004488>"&gt;\n"</font>
      + <font color=#004488>"Message&lt;"</font> + getMessage() + <font color=#004488>"&gt;\n"</font>
      + <font color=#004488>"CurrentMillis&lt;"</font> + getMillis() + <font color=#004488>"&gt;\n"</font>
      + <font color=#004488>"Params"</font>;
    Object[] objParams = getParameters();
    <font color=#0000ff>if</font>(objParams == <font color=#0000ff>null</font>)
      result += <font color=#004488>"&lt;null&gt;\n"</font>;
    <font color=#0000ff>else</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; objParams.length; i++)
        result += <font color=#004488>"  Param # &lt;"</font> + i + <font color=#004488>" value "</font> +
          objParams[i].toString() + <font color=#004488>"&gt;\n"</font>;
    result += <font color=#004488>"ResourceBundle&lt;"</font> + getResourceBundle()
      + <font color=#004488>"&gt;\nResourceBundleName&lt;"</font> + getResourceBundleName()
      + <font color=#004488>"&gt;\nSequenceNumber&lt;"</font> + getSequenceNumber()
      + <font color=#004488>"&gt;\nSourceClassName&lt;"</font> + getSourceClassName()
      + <font color=#004488>"&gt;\nSourceMethodName&lt;"</font> + getSourceMethodName()
      + <font color=#004488>"&gt;\nThread Id&lt;"</font> + getThreadID()
      + <font color=#004488>"&gt;\nThrown&lt;"</font> + getThrown() + <font color=#004488>"&gt;"</font>;
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    PrintableLogRecord logRecord = <font color=#0000ff>new</font> PrintableLogRecord(
      Level.FINEST, <font color=#004488>"Simple Log Record"</font>);
    System.out.println(logRecord);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"Level&lt;FINEST&gt;"</font>,
      <font color=#004488>"LoggerName&lt;null&gt;"</font>,
      <font color=#004488>"Message&lt;Simple Log Record&gt;"</font>,
      <font color=#004488>"%% CurrentMillis&lt;.+&gt;"</font>,
      <font color=#004488>"Params&lt;null&gt;"</font>,
      <font color=#004488>"ResourceBundle&lt;null&gt;"</font>,
      <font color=#004488>"ResourceBundleName&lt;null&gt;"</font>,
      <font color=#004488>"SequenceNumber&lt;0&gt;"</font>,
      <font color=#004488>"SourceClassName&lt;null&gt;"</font>,
      <font color=#004488>"SourceMethodName&lt;null&gt;"</font>,
      <font color=#004488>"Thread Id&lt;10&gt;"</font>,
      <font color=#004488>"Thrown&lt;null&gt;"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>PrintableLogRecord</b> is a simple extension of <b>LogRecord</b> that overrides <b>toString(&#160;)</b> to call all the getter methods available in <b>LogRecord</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0030" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775948"></a><a name="Heading23442"></a>Handlers</h3>
<p>As noted previously, you can easily create your own handler by inheriting from <b>Handler</b> and defining <b>publish(&#160;)</b> to perform your desired operations. However, there are predefined handlers that will probably satisfy your needs without doing any extra work: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0031" title="Send BackTalk Comment">Feedback</a></font><br></p>
<div style="position:relative; left: 18"><table border="1">
<tr valign="top">
<td width="151.999962" colspan="1" rowspan="1" valign="top">
<p><b>StreamHandler</b><br></p>
</td>
<td width="334.666583" colspan="1" rowspan="1" valign="top">
<p>Writes formatted records to an <b>OutputStream</b><br></p>
</td>
</tr>
<tr valign="top">
<td width="151.999962" colspan="1" rowspan="1" valign="top">
<p><b>ConsoleHandler</b><br></p>
</td>
<td width="334.666583" colspan="1" rowspan="1" valign="top">
<p>Writes formatted records to <b>System.err</b> <br></p>
</td>
</tr>
<tr valign="top">
<td width="151.999962" colspan="1" rowspan="1" valign="top">
<p><b>FileHandler</b><br></p>
</td>
<td width="334.666583" colspan="1" rowspan="1" valign="top">
<p>Writes formatted log records either to a single file, or to a set of rotating log files<br></p>
</td>
</tr>
<tr valign="top">
<td width="151.999962" colspan="1" rowspan="1" valign="top">
<p><b>SocketHandler</b><br></p>
</td>
<td width="334.666583" colspan="1" rowspan="1" valign="top">
<p>Writes formatted log records to remote TCP ports<br></p>
</td>
</tr>
<tr valign="top">
<td width="151.999962" colspan="1" rowspan="1" valign="top">
<p><b>MemoryHandler</b><br></p>
</td>
<td width="334.666583" colspan="1" rowspan="1" valign="top">
<p>Buffers log records in memory<br></p>
</td>
</tr>
</table></div>
<p class="TableFollower">For example, you often want to store logging output to a file. The <b>FileHandler</b> makes this easy: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0032" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:LogToFile.java</font>
<font color=#009900>// {Clean: LogToFile.xml,LogToFile.xml.lck}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LogToFile {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"LogToFile"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    logger.addHandler(<font color=#0000ff>new</font> FileHandler(<font color=#004488>"LogToFile.xml"</font>));
    logger.info(<font color=#004488>"A message logged to the file"</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% .* LogToFile main"</font>,
      <font color=#004488>"INFO: A message logged to the file"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>When you run this program, you&#146;ll notice two things. First, even though we&#146;re sending output to a file, you&#146;ll still see console output. That&#146;s because each message is converted to a <b>LogRecord</b>, which is first used by the local <b>logger</b> object, which passes it to its own handlers. At this point the <b>LogRecord </b>is passed to the parent object, which has its own handlers. This process continues until the root logger is reached. The root logger comes with a default <b>ConsoleHandler</b>, so the message appears on the screen as well as appearing in the log file (you can turn off this behavior by calling <b>setUseParentHandlers(false)</b>).<font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0033" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The second thing you&#146;ll notice is that the contents of the log file is in XML format, which will look something like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0034" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;?xml version=<font color=#004488>"1.0"</font> standalone=<font color=#004488>"no"</font>?&gt;
&lt;!DOCTYPE log SYSTEM <font color=#004488>"logger.dtd"</font>&gt;
&lt;log&gt;
&lt;record&gt;
  &lt;date&gt;2002-07-08T12:18:17&lt;/date&gt;
  &lt;millis&gt;1026152297750&lt;/millis&gt;
  &lt;sequence&gt;0&lt;/sequence&gt;
  &lt;logger&gt;LogToFile&lt;/logger&gt;
  &lt;level&gt;INFO&lt;/level&gt;
  &lt;<font color=#0000ff>class</font>&gt;LogToFile&lt;/<font color=#0000ff>class</font>&gt;
  &lt;method&gt;main&lt;/method&gt;
  &lt;thread&gt;10&lt;/thread&gt;
  &lt;message&gt;A message logged to the file&lt;/message&gt;
&lt;/record&gt;
&lt;/log&gt;</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The default output format for a <b>FileHandler</b> is XML. If you want to change the format, you must attach a different <b>Formatter</b> object to the handler. Here, a <b>SimpleFormatter</b> is used for the file in order to output as plain text format: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0035" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:LogToFile2.java</font>
<font color=#009900>// {Clean: LogToFile2.txt,LogToFile2.txt.lck}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LogToFile2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"LogToFile2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    FileHandler logFile= <font color=#0000ff>new</font> FileHandler(<font color=#004488>"LogToFile2.txt"</font>);
    logFile.setFormatter(<font color=#0000ff>new</font> SimpleFormatter());
    logger.addHandler(logFile);
    logger.info(<font color=#004488>"A message logged to the file"</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% .* LogToFile2 main"</font>,
      <font color=#004488>"INFO: A message logged to the file"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>LogToFile2.txt</b> file will look like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0036" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Jul 8, 2002 12:35:17 PM LogToFile2 main
INFO: A message logged to the file</PRE></FONT></BLOCKQUOTE><p><br></p>
<h4>
<a name="Heading23518"></a>Multiple Handlers</h4>
<p>You can register multiple handlers with each <b>Logger</b> object. When a logging request comes to the <b>Logger</b>, it notifies all the handlers that have been registered with it,<sup><a name="fnB100" href="#fn100">[100]</a></sup> as long as the logging level for the <b>Logger</b> is greater than or equal to that of the logging request. Each handler, in turn, has its own logging level; if the level of the <b>LogRecord</b> is greater than or equal to the level of the handler, then that handler publishes the record. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0037" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an example that adds a <b>FileHandler</b> and a <b>ConsoleHandler</b> to the <b>Logger</b> object: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0038" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:MultipleHandlers.java</font>
<font color=#009900>// {Clean: MultipleHandlers.xml,MultipleHandlers.xml.lck}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MultipleHandlers {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"MultipleHandlers"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    FileHandler logFile =
      <font color=#0000ff>new</font> FileHandler(<font color=#004488>"MultipleHandlers.xml"</font>);
    logger.addHandler(logFile);
    logger.addHandler(<font color=#0000ff>new</font> ConsoleHandler());
    logger.warning(<font color=#004488>"Output to multiple handlers"</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% .* MultipleHandlers main"</font>,
      <font color=#004488>"WARNING: Output to multiple handlers"</font>,
      <font color=#004488>"%% .* MultipleHandlers main"</font>,
      <font color=#004488>"WARNING: Output to multiple handlers"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p class="Body Text 2">When you run the program, you&#146;ll notice that the console output occurs twice; that&#146;s because the root logger&#146;s default behavior is still enabled. If you want to turn this off, make a call to <b>setUseParentHandlers(false)</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:MultipleHandlers2.java</font>
<font color=#009900>// {Clean: MultipleHandlers2.xml,MultipleHandlers2.xml.lck}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MultipleHandlers2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"MultipleHandlers2"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    FileHandler logFile =
      <font color=#0000ff>new</font> FileHandler(<font color=#004488>"MultipleHandlers2.xml"</font>);
    logger.addHandler(logFile);
    logger.addHandler(<font color=#0000ff>new</font> ConsoleHandler());
    logger.setUseParentHandlers(<font color=#0000ff>false</font>);
    logger.warning(<font color=#004488>"Output to multiple handlers"</font>);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% .* MultipleHandlers2 main"</font>,
      <font color=#004488>"WARNING: Output to multiple handlers"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Now you&#146;ll see only one console message. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0039" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading23571"></a>Writing your own Handlers</h4>
<p>You can easily write custom handlers by inheriting from the <b>Handler</b> class. To do this, you must not only implement the <b>publish(&#160;)</b> method (which performs the actual reporting), but also <b>flush(&#160;)</b> and <b>close(&#160;)</b>, which ensure that the stream used for reporting is properly cleaned up. Here&#146;s an example that stores information from the <b>LogRecord</b> into another object (a <b>List</b> of <b>String</b>). At the end of the program, the object is printed to the console: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0040" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:CustomHandler.java</font>
<font color=#009900>// How to write custom handler</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CustomHandler {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"CustomHandler"</font>);
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> List strHolder = <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    logger.addHandler(<font color=#0000ff>new</font> Handler() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> publish(LogRecord logRecord) {
        strHolder.add(logRecord.getLevel() + <font color=#004488>":"</font>);
        strHolder.add(logRecord.getSourceClassName()+<font color=#004488>":"</font>);
        strHolder.add(logRecord.getSourceMethodName()+<font color=#004488>":"</font>);
        strHolder.add(<font color=#004488>"&lt;"</font> + logRecord.getMessage() + <font color=#004488>"&gt;"</font>);
        strHolder.add(<font color=#004488>"\n"</font>);
      }
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> flush() {}
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> close() {}
    });
    logger.warning(<font color=#004488>"Logging Warning"</font>);
    logger.info(<font color=#004488>"Logging Info"</font>);
    System.out.print(strHolder);
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% .* CustomHandler main"</font>,
      <font color=#004488>"WARNING: Logging Warning"</font>,
      <font color=#004488>"%% .* CustomHandler main"</font>,
      <font color=#004488>"INFO: Logging Info"</font>,
      <font color=#004488>"[WARNING:, CustomHandler:, main:, "</font> +
      <font color=#004488>"&lt;Logging Warning&gt;, "</font>,
      <font color=#004488>", INFO:, CustomHandler:, main:, &lt;Logging Info&gt;, "</font>,
      <font color=#004488>"]"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The console output comes from the root logger. When the <b>ArrayList</b> is printed, you can see that only selected information has been captured into the object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0041" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775949"></a><a name="Heading23613"></a>Filters</h3>
<p>When you write the code to send a logging message to a <b>Logger</b> object, you often decide, at the time you&#146;re writing the code, what level the logging message should be (the logging API certainly allows you to devise more complex systems wherein the level of the message can be determined dynamically, but this is less common in practice). The <b>Logger</b> object has a level that can be set so that it can decide what level of message to accept; all others will be ignored. This can be thought of as a basic filtering functionality, and it&#146;s often all you need. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0042" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Sometimes, however, you need more sophisticated filtering so that you can decide whether to accept or reject a message based on something more than just the current level. To accomplish this you can write custom <b>Filter</b> objects. <b>Filter</b> is an <b>interface</b> that has a single method, <b>boolean </b><a href="file:///C:/ProgTools/Java/docs/api/java/util/logging/Filter.html#isLoggable(java.util.logging.LogRecord)">isLoggable</a><b>(</b><a href="file:///C:/ProgTools/Java/docs/api/java/util/logging/LogRecord.html">LogRecord</a><b>&#160;record)</b>, which decides whether or not this particular <b>LogRecord</b> is interesting enough to report. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0043" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once you create a <b>Filter</b>, you register it with either a <b>Logger</b> or a <b>Handler</b> by using the <b>setFilter(&#160;)</b> method. For example, suppose you&#146;d like to only log reports about <b>Duck</b>s: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0044" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:SimpleFilter.java</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleFilter {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"SimpleFilter"</font>);
  <font color=#0000ff>static</font> <font color=#0000ff>class</font> Duck {};
  <font color=#0000ff>static</font> <font color=#0000ff>class</font> Wombat {};
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> sendLogMessages() {
    logger.log(Level.WARNING,
      <font color=#004488>"A duck in the house!"</font>, <font color=#0000ff>new</font> Duck());
    logger.log(Level.WARNING,
      <font color=#004488>"A Wombat at large!"</font>, <font color=#0000ff>new</font> Wombat());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    sendLogMessages();
    logger.setFilter(<font color=#0000ff>new</font> Filter() {
      <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isLoggable(LogRecord record) {
        Object[] params = record.getParameters();
        <font color=#0000ff>if</font>(params == <font color=#0000ff>null</font>)
          <font color=#0000ff>return</font> <font color=#0000ff>true</font>; <font color=#009900>// No parameters</font>
        <font color=#0000ff>if</font>(record.getParameters()[0] <font color=#0000ff>instanceof</font> Duck)
          <font color=#0000ff>return</font> <font color=#0000ff>true</font>;  <font color=#009900>// Only log Ducks</font>
        <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
      }
    });
    logger.info(<font color=#004488>"After setting filter.."</font>);
    sendLogMessages();
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"%% .* SimpleFilter sendLogMessages"</font>,
      <font color=#004488>"WARNING: A duck in the house!"</font>,
      <font color=#004488>"%% .* SimpleFilter sendLogMessages"</font>,
      <font color=#004488>"WARNING: A Wombat at large!"</font>,
      <font color=#004488>"%% .* SimpleFilter main"</font>,
      <font color=#004488>"INFO: After setting filter.."</font>,
      <font color=#004488>"%% .* SimpleFilter sendLogMessages"</font>,
      <font color=#004488>"WARNING: A duck in the house!"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Before setting the <b>Filter</b>, messages about <b>Duck</b>s and <b>Wombat</b>s are reported. The <b>Filter</b> is created as an anonymous inner class that looks at the <b>LogRecord</b> parameter to see if a <b>Duck</b> was passed as an extra argument to the <b>log(&#160;)</b> method. If so, it returns <b>true</b> to indicate that the message should be processed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0045" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Notice that the signature of <b>getParameters(&#160;)</b> says that it will return an <b>Object[]</b>. However, if no additional arguments have been passed to the <b>log(&#160;)</b> method, <b>getParameters(&#160;)</b> will return <b>null</b> (in violation of its signature&#151;this is a bad programming practice). So instead of assuming that an array is returned (as promised) and checking to see if it is of zero length, we must check for <b>null</b>. If you don&#146;t do this correctly, then the call to <b>logger.info(&#160;)</b> will cause an exception to be thrown. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0046" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775950"></a><a name="Heading23662"></a>Formatters</h3>
<p>A <b>Formatter</b> is a way to insert a formatting operation into a <b>Handler</b>&#146;s processing steps. If you register a <b>Formatter</b> object with a <b>Handler</b>, then before the <b>LogRecord</b> is published by the <b>Handler</b>, it is first sent to the <b>Formatter</b>. After formatting, the <b>LogRecord</b> is returned to the <b>Handler</b>, which then publishes it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0297" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To write a custom <b>Formatter</b>,<b> </b>extend the <b>Formatter </b>class and override <b>format(LogRecord record)</b>. Then, register the <b>Formatter</b> with the <b>Handler</b> by using the <b>setFormatter(&#160;) </b>call, as seen here: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0047" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:SimpleFormatterExample.java</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleFormatterExample {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"SimpleFormatterExample"</font>);
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> logMessages() {
    logger.info(<font color=#004488>"Line One"</font>);
    logger.info(<font color=#004488>"Line Two"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    logger.setUseParentHandlers(<font color=#0000ff>false</font>);
    Handler conHdlr = <font color=#0000ff>new</font> ConsoleHandler();
    conHdlr.setFormatter(<font color=#0000ff>new</font> Formatter() {
      <font color=#0000ff>public</font> String format(LogRecord record) {
        <font color=#0000ff>return</font> record.getLevel()  + <font color=#004488>"  :  "</font>
          + record.getSourceClassName()  + <font color=#004488>" -:- "</font>
          + record.getSourceMethodName()  + <font color=#004488>" -:- "</font>
          + record.getMessage() + <font color=#004488>"\n"</font>;
      }
    });
    logger.addHandler(conHdlr);
    logMessages();
    monitor.expect(<font color=#0000ff>new</font> String[] {
      <font color=#004488>"INFO  :  SimpleFormatterExample -:- logMessages "</font>
        + <font color=#004488>"-:- Line One"</font>,
      <font color=#004488>"INFO  :  SimpleFormatterExample -:- logMessages "</font>
        + <font color=#004488>"-:- Line Two"</font>
    });
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Remember that a logger like <b>myLogger</b> has a default handler that it gets from the parent logger (the root logger, in this case). Here, we are turning off the default handler by calling <b>setUseParentHandlers(false)</b>, and then adding in a console handler to use instead. The new <b>Formatter</b> is created as an anonymous inner class in the <b>setFormatter(&#160;) </b>statement. The overridden <b>format(&#160;)</b> statement simply extracts some of the information from the <b>LogRecord</b> and formats it into a string.<sup> </sup><font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0048" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775951"></a><a name="Heading23701"></a>Example: Sending email to
report log messages</h3>
<p>You can actually have one of your logging handlers send you an email so that you can be automatically notified of important problems. The following example uses the JavaMail API to develop a mail user agent to send an email. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0298" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2059"></a>The JavaMail API is a set of classes that interface to the underlying mailing protocol (IMAP, POP, SMTP). You can devise a notification mechanism on some exceptional condition in the running code by registering an additional <b>Handler</b> to send an email. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0299" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:EmailLogger.java</font>
<font color=#009900>// {RunByHand} Must be connected to the Internet</font>
<font color=#009900>// {Depends: mail.jar,activation.jar}</font>
<font color=#0000ff>import</font> java.util.logging.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.Properties;
<font color=#0000ff>import</font> javax.mail.*;
<font color=#0000ff>import</font> javax.mail.internet.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> EmailLogger {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger logger =
    Logger.getLogger(<font color=#004488>"EmailLogger"</font>);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) <font color=#0000ff>throws</font> Exception {
    logger.setUseParentHandlers(<font color=#0000ff>false</font>);
    Handler conHdlr = <font color=#0000ff>new</font> ConsoleHandler();
    conHdlr.setFormatter(<font color=#0000ff>new</font> Formatter() {
      <font color=#0000ff>public</font> String format(LogRecord record) {
        <font color=#0000ff>return</font> record.getLevel() + <font color=#004488>"  :  "</font>
          + record.getSourceClassName() + <font color=#004488>":"</font>
          + record.getSourceMethodName() + <font color=#004488>":"</font>
          + record.getMessage() + <font color=#004488>"\n"</font>;
      }
    });
    logger.addHandler(conHdlr);
    logger.addHandler(
      <font color=#0000ff>new</font> FileHandler(<font color=#004488>"EmailLoggerOutput.xml"</font>));
    logger.addHandler(<font color=#0000ff>new</font> MailingHandler());
    logger.log(Level.INFO,
      <font color=#004488>"Testing Multiple Handlers"</font>, <font color=#004488>"SendMailTrue"</font>);
  }
}

<font color=#009900>// A handler that sends mail messages</font>
<font color=#0000ff>class</font> MailingHandler <font color=#0000ff>extends</font> Handler {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> publish(LogRecord record) {
    Object[] params = record.getParameters();
    <font color=#0000ff>if</font>(params == <font color=#0000ff>null</font>) <font color=#0000ff>return</font>;
    <font color=#009900>// Send mail only if the parameter is true</font>
    <font color=#0000ff>if</font>(params[0].equals(<font color=#004488>"SendMailTrue"</font>)) {
      <font color=#0000ff>new</font> MailInfo(<font color=#004488>"bruce@theunixman.com"</font>,
        <font color=#0000ff>new</font> String[] { <font color=#004488>"bruce@theunixman.com"</font> },
        <font color=#004488>"smtp.theunixman.com"</font>, <font color=#004488>"Test Subject"</font>,
        <font color=#004488>"Test Content"</font>).sendMail();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> close() {}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> flush() {}
}

<font color=#0000ff>class</font> MailInfo {
  <font color=#0000ff>private</font> String fromAddr;
  <font color=#0000ff>private</font> String[] toAddr;
  <font color=#0000ff>private</font> String serverAddr;
  <font color=#0000ff>private</font> String subject;
  <font color=#0000ff>private</font> String message;
  <font color=#0000ff>public</font> MailInfo(String from, String[] to,
    String server, String subject, String message) {
    fromAddr = from;
    toAddr = to;
    serverAddr = server;
    <font color=#0000ff>this</font>.subject = subject;
    <font color=#0000ff>this</font>.message = message;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> sendMail() {
    <font color=#0000ff>try</font> {
      Properties prop = <font color=#0000ff>new</font> Properties();
      prop.put(<font color=#004488>"mail.smtp.host"</font>, serverAddr);
      Session session =
        Session.getDefaultInstance(prop, <font color=#0000ff>null</font>);
      session.setDebug(<font color=#0000ff>true</font>);
      <font color=#009900>// Create a message</font>
      Message mimeMsg = <font color=#0000ff>new</font> MimeMessage(session);
      <font color=#009900>// Set the from and to address</font>
      Address addressFrom = <font color=#0000ff>new</font> InternetAddress(fromAddr);
      mimeMsg.setFrom(addressFrom);
      Address[] to = <font color=#0000ff>new</font> InternetAddress[toAddr.length];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; toAddr.length; i++)
        to[i] = <font color=#0000ff>new</font> InternetAddress(toAddr[i]);
      mimeMsg.setRecipients(Message.RecipientType.TO,to);
      mimeMsg.setSubject(subject);
      mimeMsg.setText(message);
      Transport.send(mimeMsg);
    } <font color=#0000ff>catch</font> (Exception e) {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(e);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>MailingHandler</b> is one of the <b>Handler</b>s registered with the logger. To send an email, the <b>MailingHandler </b>uses the <b>MailInfo</b> object. When a logging message is sent with an additional parameter of &#147;<b>SendMailTrue</b>,&#148; the <b>MailingHandler </b>sends an email. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0300" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The<b> MailInfo </b>object contains the necessary state information, such as the <i>to </i>address, <i>from</i> address, and the subject information required to send an email. This state information is provided to the <b>MailInfo </b>object through the constructor when it is instantiated. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0301" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To send an email you must first establish a <b>Session</b> with the <a name="Index2060"></a><a name="Index2061"></a><i>Simple Mail Transfer Protocol</i> (SMTP) server. This is done by passing the address of the server inside a <b>Properties</b> object, in a property named <b>mail.smtp.host</b>. You establish a session by calling <b>Session.getDefaultInstance(&#160;)</b>, passing it the <b>Properties</b> object as the first argument. The second argument is an instance of <b>Authenticator</b> that may be used for authenticating the user. Passing a <b>null</b> value for the <b>Authenticator</b> argument specifies no authentication. If the debugging flag in the <b>Properties</b> object is set, information regarding the communication between the <b>SMTP</b> server and the program will be printed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0302" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>MimeMessage </b>is an abstraction of an Internet email message that extends the class <b>Message</b>. It constructs a message that complies with the MIME (Multipurpose Internet Mail Extensions) format. A <b>MimeMessage </b>is constructed by passing it an instance of <b>Session</b>. You may set the <i>from</i> and <i>to</i> addresses by creating an instance of <b>InternetAddress </b>class (a subclass of <b>Address</b>). You send the message using the static call <b>Transport.send(&#160;) </b>from the abstract class <b>Transport</b>. An implementation of <b>Transport</b> uses a specific protocol (generally SMTP) to communicate with the server to send the message. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0049" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775952"></a><a name="Heading23796"></a>Controlling Logging Levels
through Namespaces</h3>
<p>Although not mandatory, it&#146;s advisable to give a logger the name of the class in which it is used. This allows you to manipulate the logging level of groups of loggers that reside in the same package hierarchy, at the granularity of the directory package structure. For example, you can modify all the logging levels of all the packages in <b>com</b>, or just the ones in <b>com.bruceeckel</b>, or just the ones in <b>com.bruceeckel.util</b>, as shown in the following example: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0050" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:LoggingLevelManipulation.java</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.Level;
<font color=#0000ff>import</font> java.util.logging.Logger;
<font color=#0000ff>import</font> java.util.logging.Handler;
<font color=#0000ff>import</font> java.util.logging.LogManager;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LoggingLevelManipulation {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Logger
    lgr = Logger.getLogger(<font color=#004488>"com"</font>),
    lgr2 = Logger.getLogger(<font color=#004488>"com.bruceeckel"</font>),
    util = Logger.getLogger(<font color=#004488>"com.bruceeckel.util"</font>),
    test = Logger.getLogger(<font color=#004488>"com.bruceeckel.test"</font>),
    rand = Logger.getLogger(<font color=#004488>"random"</font>);
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printLogMessages(Logger logger) {
    logger.finest(logger.getName() + <font color=#004488>" Finest"</font>);
    logger.finer(logger.getName() + <font color=#004488>" Finer"</font>);
    logger.fine(logger.getName() + <font color=#004488>" Fine"</font>);
    logger.config(logger.getName() + <font color=#004488>" Config"</font>);
    logger.info(logger.getName() + <font color=#004488>" Info"</font>);
    logger.warning(logger.getName() + <font color=#004488>" Warning"</font>);
    logger.severe(logger.getName() + <font color=#004488>" Severe"</font>);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> logMessages() {
    printLogMessages(lgr);
    printLogMessages(lgr2);
    printLogMessages(util);
    printLogMessages(test);
    printLogMessages(rand);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printLevels() {
    System.out.println(<font color=#004488>" -- printing levels -- "</font>
      + lgr.getName() + <font color=#004488>" : "</font> + lgr.getLevel()
      + <font color=#004488>" "</font> + lgr2.getName() + <font color=#004488>" : "</font> + lgr2.getLevel()
      + <font color=#004488>" "</font> + util.getName() + <font color=#004488>" : "</font> + util.getLevel()
      + <font color=#004488>" "</font> + test.getName() + <font color=#004488>" : "</font> + test.getLevel()
      + <font color=#004488>" "</font> + rand.getName() + <font color=#004488>" : "</font> + rand.getLevel());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    printLevels();
    lgr.setLevel(Level.SEVERE);
    printLevels();
    System.out.println(<font color=#004488>"com level: SEVERE"</font>);
    logMessages();
    util.setLevel(Level.FINEST);
    test.setLevel(Level.FINEST);
    rand.setLevel(Level.FINEST);
    printLevels();
    System.out.println(
      <font color=#004488>"individual loggers set to FINEST"</font>);
    logMessages();
    lgr.setLevel(Level.FINEST);
    printLevels();
    System.out.println(<font color=#004488>"com level: FINEST"</font>);
    logMessages();
    monitor.expect(<font color=#004488>"LoggingLevelManipulation.out"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>As you can see in this code, if you pass <b>getLogger(&#160;) </b>a string representing a namespace, the resulting <b>Logger</b> will control the severity levels of that namespace; that is, all the packages within that namespace will be affected by changes to the severity level of the logger. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0168" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Each <b>Logger</b> keeps a track of its existing ancestor <b>Logger. </b>If a child logger already has a logging level set, then that level is used instead of the parent's logging level. Changing the logging level of the parent does not affect the logging level of the child once the child has its own logging level. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0053" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Although the level of individual loggers is set to <b>FINEST</b>, only messages with a logging level equal to or more severe than <b>INFO</b> are printed because we are using the <b>ConsoleHandler</b> of the root logger, which is at <b>INFO</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0167" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Because it isn&#146;t in the same namespace, the logging level of <b>random</b> remains unaffected when the logging level of the logger <b>com</b> or <b>com.bruceeckel</b> is changed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0054" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775953"></a><a name="Heading23862"></a>Logging Practices for
Large Projects</h3>
<p>At first glance, the Java logging API can seem rather over-engineered for most programming problems. The extra features and abilities don&#146;t come in handy until you start building larger projects. In this section we&#146;ll look at these features and recommended ways to use them. If you&#146;re only using logging on smaller projects, you probably won&#146;t need to use these features. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0055" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading23864"></a>Configuration files</h4>
<p>The following file shows how you can configure loggers in a project by using a properties file:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//:! c15:log.prop</font>
#### Configuration File ####
# Global Params
# Handlers installed <font color=#0000ff>for</font> the root logger
handlers= java.util.logging.ConsoleHandler java.util.logging.FileHandler
# Level <font color=#0000ff>for</font> root logger&#151;is used by any logger 
# that does not have its level set
.level= FINEST
# Initialization <font color=#0000ff>class</font>&#151;the <font color=#0000ff>public</font> <font color=#0000ff>default</font> constructor 
# of <font color=#0000ff>this</font> <font color=#0000ff>class</font> is called by the Logging framework
config = ConfigureLogging

# Configure FileHandler
# Logging file name - %u specifies unique
java.util.logging.FileHandler.pattern = java%g.log
# Write 100000 bytes before rotating <font color=#0000ff>this</font> file
java.util.logging.FileHandler.limit = 100000
# Number of rotating files to be used
java.util.logging.FileHandler.count = 3
# Formatter to be used with <font color=#0000ff>this</font> FileHandler
java.util.logging.FileHandler.formatter =   java.util.logging.SimpleFormatter

# Configure ConsoleHandler
java.util.logging.ConsoleHandler.level = FINEST
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter

# Set Logger Levels #
com.level=SEVERE
com.bruceeckel.level = FINEST
com.bruceeckel.util.level = INFO
com.bruceeckel.test.level = FINER
random.level= SEVERE
<font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The configuration file allows you to associate handlers with the root logger. The property handlers specify the comma-separated list of handlers you wish to register with the root logger. Here, we register the <b>FileHandler</b> and the <b>ConsoleHandler</b> with the root logger. The <b>.level</b> property species the default level for the logger. This level is used by all the loggers that are children of the root logger and do not have their own level specified. Note that, without a properties file, the default logging level of the root logger is INFO. This is because, in absence of a custom configuration file, the virtual machine uses the configuration from the JAVA_HOME\jre\lib\logging.properties file.<sup> </sup><font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0056" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading23901"></a>Rotating log files</h4>
<p>The preceding configuration file generates <i>rotating log files</i>, which are used to prevent any log file from becoming too large. By setting the <b>FileHandler.limit</b> value, you give the maximum number of bytes allowed in one log file before the next one begins to fill. <b>FileHandler.count</b> determines the number of rotating log files to use; the configuration file shown here specifies three files. If all three files are filled to their maximum, then the first file begins to fill again, overwriting the old contents. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0057" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Alternatively, all the output can be put in a single file by giving a <b>FileHandler.count</b> value of one. (<b>FileHandler</b> parameters are explained in detail in the JDK documentation). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0058" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In order for the following program to use the preceding configuration file, you must specify the parameter <b>java.util.logging.config.file</b> on the command line: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0059" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java -Djava.util.logging.config.file=log.prop ConfigureLogging</PRE></FONT></BLOCKQUOTE><p><br></p>
<p> The configuration file can only modify the root logger. If you want to add filters and handlers for other loggers, you must write the code to do it inside a Java file, as noted in the constructor: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0060" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:ConfigureLogging.java</font>
<font color=#009900>// {JVMArgs: -Djava.util.logging.config.file=log.prop}</font>
<font color=#009900>// {Clean: java0.log,java0.log.lck}</font>
<font color=#0000ff>import</font> com.bruceeckel.simpletest.*;
<font color=#0000ff>import</font> java.util.logging.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ConfigureLogging {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Test monitor = <font color=#0000ff>new</font> Test();
  <font color=#0000ff>static</font> Logger lgr = Logger.getLogger(<font color=#004488>"com"</font>),
    lgr2 = Logger.getLogger(<font color=#004488>"com.bruceeckel"</font>),
    util = Logger.getLogger(<font color=#004488>"com.bruceeckel.util"</font>),
    test = Logger.getLogger(<font color=#004488>"com.bruceeckel.test"</font>),
    rand = Logger.getLogger(<font color=#004488>"random"</font>);
  <font color=#0000ff>public</font> ConfigureLogging() {
    <font color=#009900>/* Set Additional formatters, Filters and Handlers for
       the loggers here. You cannot specify the Handlers
       for loggers except the root logger from the
       configuration file. */</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    sendLogMessages(lgr);
    sendLogMessages(lgr2);
    sendLogMessages(util);
    sendLogMessages(test);
    sendLogMessages(rand);
    monitor.expect(<font color=#004488>"ConfigureLogging.out"</font>);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> sendLogMessages(Logger logger) {
    System.out.println(<font color=#004488>" Logger Name : "</font>
      + logger.getName() + <font color=#004488>" Level: "</font> + logger.getLevel());
    logger.finest(<font color=#004488>"Finest"</font>);
    logger.finer(<font color=#004488>"Finer"</font>);
    logger.fine(<font color=#004488>"Fine"</font>);
    logger.config(<font color=#004488>"Config"</font>);
    logger.info(<font color=#004488>"Info"</font>);
    logger.warning(<font color=#004488>"Warning"</font>);
    logger.severe(<font color=#004488>"Severe"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The configuration will result in the output being sent to the files named <b>java0.log</b>, <b>java1.log</b>, and <b>java2.log </b>in the directory from which this program is executed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0061" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading23949"></a>Suggested practices</h4>
<p>Although it&#146;s not mandatory, you should generally consider using a logger for each class, following the standard of setting the logger name to be the same as the fully qualified name of the class. As shown earlier, this allows for finer-grained control of logging because of the ability to turn logging on and off based on namespaces. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0062" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you don&#146;t set the logging level for individual classes in that package, then the individual classes default to the logging level set for the package (assuming that you name the loggers according to their package and class). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0063" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you control the logging level in a configuration file instead of changing it dynamically in your code, then you can modify logging levels without recompiling your code. Recompilation is not always an option when the system is deployed; often, only the class files are shipped to the destination environment. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0064" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Sometimes there is a requirement to execute some code to perform initialization activities such as adding <b>Handler</b>s, <b>Filter</b>s, and <b>Formatter</b>s to loggers. This can be achieved by setting the <b>config</b> property in the properties file. You can have multiple classes whose initialization can be done using the <b>config</b> property. These classes should be specified using space-delimited values like this: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0065" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>config = ConfigureLogging1 ConfigureLogging2 Bar Baz</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Classes specified in this fashion will have their default constructors invoked. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0066" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775954"></a><a name="Heading23957"></a>Summary</h3>
<p>Although this has been a fairly thorough introduction to the logging API, it doesn&#146;t include everything. For instance, we haven&#146;t talked about the <b>LogManager</b> or details of the various built-in handlers, such as <b>MemoryHandler</b>, <b>FileHandler</b>, <b>ConsoleHandler</b>, etc. You should go to the JDK documentation for further details. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0067" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775955"></a><a name="Heading23959"></a>Debugging</h2>
<p>Although judicious use of <b>System.out</b> statements or logging information can produce valuable insight into the behavior of a program,<sup><a name="fnB101" href="#fn101">[101]</a></sup> for difficult problems this approach becomes cumbersome and time-consuming. In addition, you may need to peek more deeply into the program than print statements will allow. For this, you need a <a name="Index2062"></a><i>debugger</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0303" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In addition to more quickly and easily displaying information that you could produce with print statements, a debugger will also set <a name="Index2063"></a><i>breakpoints </i>and then stop the program when it reaches those breakpoints. A debugger can also display the state of the program at any instant, view the values of variables that you&#146;re interested in, step through the program line-by-line, connect to a remotely running program, and more. Especially when you start building larger systems (where bugs can easily become buried), it pays to become familiar with debuggers. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0304" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775956"></a><a name="Heading23963"></a>Debugging with JDB</h3>
<p>The <a name="Index2064"></a><i>Java Debugger </i>(JDB) is a command-line debugger that ships with the JDK. JDB is at least conceptually a descendant of the Gnu Debugger (GDB, which was inspired by the original Unix DB), in terms of the instructions for debugging and its command-line interface. JDB is useful for learning about debugging and performing simpler debugging tasks, and it&#146;s helpful to know that it&#146;s always available wherever the JDK is installed. However, for larger projects you&#146;ll probably want to use a graphical debugger, described later. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0305" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Suppose you&#146;ve written the following program:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:SimpleDebugging.java</font>
<font color=#009900>// {ThrowsException}</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleDebugging {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo1() {
    System.out.println(<font color=#004488>"In foo1"</font>);
    foo2();
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo2() {
    System.out.println(<font color=#004488>"In foo2"</font>);
    foo3();
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo3() {
    System.out.println(<font color=#004488>"In foo3"</font>);
    <font color=#0000ff>int</font> j = 1;
    j--;
    <font color=#0000ff>int</font> i = 5 / j;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    foo1();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>If you look at <b>foo3(&#160;)</b>, the problem is obvious; you&#146;re dividing by zero. But suppose this code is buried in a large program (as is implied here by the sequence of calls) and you don&#146;t know where to start looking for the problem. As it turns out, the exception that will be thrown will give enough information for you to locate the problem (this is just one of the great things about exceptions). But let&#146;s just suppose that the problem is more difficult than that, and that you need to drill into it more deeply and get more information than what an exception provides. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0306" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To run JDB, you must tell the compiler to generate debugging information by compiling <b>SimpleDebugging.java</b> with the <b>&#150;g</b> flag. Then you start debugging the program with the command line:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jdb SimpleDebugging</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This brings up JDB and gives you a command prompt. You can view the list of available JDB commands by typing &#145;?&#146; at the prompt. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0307" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here&#146;s an interactive debugging trace that shows how to chase down a problem:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Initializing jdb ...
&gt; <font color=#0000ff>catch</font> Exception</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>&gt;</b> indicates that JDB is waiting for a command, and the commands typed in by the user are shown in bold. The command <b>catch Exception </b>causes a breakpoint to be set at any point where an exception is thrown (however, the debugger will stop anyway, even if you don&#146;t explicitly give this comment&#151;exceptions appear to be default breakpoints in JDB). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0308" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Deferring exception <font color=#0000ff>catch</font> Exception.
It will be set after the <font color=#0000ff>class</font> is loaded.
&gt; run</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Now the program will run<b> </b>until the next breakpoint, which in this case is where the exception occurs. Here&#146;s the result of the <b>run</b> command:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>run SimpleDebugging
&gt;
VM Started: In foo1
In foo2
In foo3
Exception occurred: java.lang.ArithmeticException (uncaught)<font color=#004488>"thread=main"</font>, SimpleDebugging.foo3(), line=18 bci=15
18        <font color=#0000ff>int</font> i = 5 / j;</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The program runs until line 18, where the exception generated, but JDB does not exit when it hits the exception. The debugger also displays the line of code that caused the exception. You can list the point where the execution stopped in the program source by the <b>list</b> command as shown here: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0309" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>main[1] list
14      <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo3() {
15        System.out.println(<font color=#004488>"In foo3"</font>);
16        <font color=#0000ff>int</font> j = 1;
17        j--;
18 =&gt;     <font color=#0000ff>int</font> i = 5 / j;
19      }
20
21      <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
22        foo1();
23      }</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The pointer (&#147;=&gt;&#148;) in this listing shows the current point from where the execution will resume. You <i>could</i> resume the execution by the <b>cont </b>(continue) command. But doing that will make JDB exit at the exception, printing the stack trace. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0310" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>locals</b> command dumps the value of all the local variables:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>main[1] locals
Method arguments:
Local variables:
j = 0</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can see that the value of <b>j=0 </b>is what caused the exception. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0311" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>wherei</b> command prints the stack frames pushed in the method stack of the current thread:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>main[1] wherei
[1] SimpleDebugging.foo3 (SimpleDebugging.java:18), pc = 15
[2] SimpleDebugging.foo2 (SimpleDebugging.java:11), pc = 8
[3] SimpleDebugging.foo1 (SimpleDebugging.java:6), pc = 8
[4] SimpleDebugging.main (SimpleDebugging.java:22), pc = 0</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Each line after the <b>wherei </b>command represents a method call and the point where the call will return (which is shown by the value of the program counter <b>pc</b>). Here the calling sequence was <b>main(&#160;), foo1(&#160;), foo2(&#160;)</b>,<b> </b>and <b>foo3(&#160;)</b>. You can pop the stack frame pushed when the call was made to <b>foo3(&#160;)</b> with the <b>pop</b> command: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0312" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>main[1] pop
main[1] wherei
[1] SimpleDebugging.foo2 (SimpleDebugging.java:11), pc = 8
[2] SimpleDebugging.foo1 (SimpleDebugging.java:6), pc = 8
[3] SimpleDebugging.main (SimpleDebugging.java:22), pc = 0</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can make the JDB step through the call to <b>foo3(&#160;) </b>again<b> </b>with the <b>reenter</b> command:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>main[1] reenter
&gt;
Step completed: <font color=#004488>"thread=main"</font>, SimpleDebugging.foo3(), line=15 bci=0
System.out.println(<font color=#004488>"In foo3"</font>);</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The <b>list</b> command shows us that the execution begins at the start of <b>foo3(&#160;)</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>main[1] list
11        foo3();
12      }
13
14      <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo3() {
15 =&gt;     System.out.println(<font color=#004488>"In foo3"</font>);
16        <font color=#0000ff>int</font> j = 1;
17        j--;
18        <font color=#0000ff>int</font> i = 5 / j;
19      }
20</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>JDB also allows you to modify the value of the local variables. The divide by zero that was caused by executing this piece of code the last time can be avoided by changing the value of <b>j</b>. You can do this directly in the debugger, so you can continue debugging the program without going back and changing the source file. Before you set the value of <b>j</b>, you will have to execute through line 25 since that is where <b>j</b> is declared. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0313" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>main[1] step
&gt; In foo3

Step completed: <font color=#004488>"thread=main"</font>, SimpleDebugging.foo3(), line=16 bci=8
16        <font color=#0000ff>int</font> j = 1;

main[1] step
&gt;
Step completed: <font color=#004488>"thread=main"</font>, SimpleDebugging.foo3(), line=17 bci=10
17        j--;

main[1] list
13
14      <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo3() {
15        System.out.println(<font color=#004488>"In foo3"</font>);
16        <font color=#0000ff>int</font> j = 1;
17 =&gt;     j--;
18        <font color=#0000ff>int</font> i = 5 / j;
19      }
20
21      <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
22        foo1();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>At this point, <b>j </b>is defined and you can set its value so that the exception can be avoided.<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>main[1] set j=6
 j=6 = 6
main[1] next
&gt;
Step completed: <font color=#004488>"thread=main"</font>, SimpleDebugging.foo3(), line=18 bci=13
18        <font color=#0000ff>int</font> i = 5 / j;
main[1] next
&gt;
Step completed: <font color=#004488>"thread=main"</font>, SimpleDebugging.foo3(), line=19 bci=17
19      }
main[1] next
&gt;
Step completed: <font color=#004488>"thread=main"</font>, SimpleDebugging.foo2(), line=12 bci=11
12      }
main[1] list
8
9      <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo2() {
10        System.out.println(<font color=#004488>"In foo2"</font>);
11        foo3();
12 =&gt;   }
13
14      <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo3() {
15        System.out.println(<font color=#004488>"In foo3"</font>);
16        <font color=#0000ff>int</font> j = 1;
17        j--; 
main[1] next
&gt;
Step completed: <font color=#004488>"thread=main"</font>, SimpleDebugging.foo1(), line=7 bci=11
7      }
main[1] list
3    <font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleDebugging {
4      <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo1() {
5        System.out.println(<font color=#004488>"In foo1"</font>);
6        foo2();
7 =&gt;   }
8
9      <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> foo2() {
10        System.out.println(<font color=#004488>"In foo2"</font>);
11        foo3();
12      } 
main[1] next
&gt;
Step completed: <font color=#004488>"thread=main"</font>, SimpleDebugging.main(), line=23 bci=3
23      }

main[1] list
19      }
20
21      <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
22        foo1();
23 =&gt;   }
24    } <font color=#009900>///:~ </font>
main[1] next
&gt;
The application exited</PRE></FONT></BLOCKQUOTE><p><br></p>
<p><b>next</b> executes a line at a time. You can see that the exception is avoided and we can continue stepping through the program. <b>list </b>is used to show the position in the program from where execution will proceed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0149" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775957"></a><a name="Heading24147"></a>Graphical debuggers</h3>
<p>Using a command-line debugger like JDB can be inconvenient. You must use explicit commands to do things like looking at the state of the variables (locals, dump), listing the point of execution in the source code (list), finding out the threads in the system(threads), setting breakpoints (stop in, stop at), etc. A graphical debugger allows you to do all these things with a few clicks and also view the latest details of program being debugged without using explicit commands. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0314" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Thus, although you may want to get started by experimenting with JDB, you&#146;ll probably find it much more productive to learn to use a graphical debugger in order to quickly track down your bugs. During the development of this edition of this book, we began using IBM&#146;s <i>Eclipse</i> editor and development environment, which contains a very good graphical debugger for Java. Eclipse is well designed and implemented, and you can download it for free from <i>www.Eclipse.org</i> (this is a free tool, not a demo or shareware&#151;thanks to IBM for investing the money, time, and effort to make this available to everyone). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0315" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Other free development tools have graphical debuggers as well, such as Sun&#146;s <i>Netbeans</i> and the free version of Borland&#146;s <i>JBuilder</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0316" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775958"></a><a name="Heading24151"></a>Profiling and
optimizing</h2>
<p><i>&#147;We should forget about small efficiencies, say about 97% of the time: Premature optimization is the root of all evil.&#148;&#151;Donald Knuth </i><br></p>
<p><a name="Index2065"></a><a name="Index2066"></a>Although you should always keep this quote in mind, especially when you discover yourself on the slippery slope of premature optimization, sometimes you <i>do</i> need to determine where your program is spending all its time, to see if you can improve the performance of those sections. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0317" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A profiler gathers information that allows you to see which parts of the program consume memory and which methods consume maximum time. Some profilers even allow you to disable the garbage collector to help determine patterns of memory allocation. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0318" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A profiler can also be a useful tool in detecting threading deadlock in your program. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0319" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775959"></a><a name="Heading24156"></a>Tracking memory
consumption</h3>
<p>Here is the kind of data a profiler can show for memory usage:<br></p>
<ul>
<li>Number of object allocations for a specific type.</li>
<li>Places where the object allocations are taking place.</li>
<li>Methods involved in allocation of instances of this class. </li>
<li>Loitering objects: objects that are allocated, not used, and not garbage
collected. These keep increasing the size of the JVM heap and represent memory
leaks, which can cause an out-of-memory error or excessive overhead on the
garbage collector.</li>
<li>Excessive allocation of temporary objects that increase the work of the
garbage collector and thus reduce the performance of the application.</li>
<li>Failure to release instances added to a collection and not removed (this is
a special case of loitering objects). <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0320" title="Send BackTalk
Comment">Feedback</a></font></li></ul><h3>
<a name="_Toc24775960"></a><a name="Heading24164"></a>Tracking CPU usage</h3>
<p>Profilers also keep track of how much time the CPU spends in various parts of your code. They can tell you:<br></p>
<ul>
<li>The number of times a method was invoked.</li>
<li>The percentage of CPU time utilized by each method. If this method calls
other methods, the profiler can tell you the amount of time spent in these other
methods.</li>
<li>Total absolute time spent by each method, including the time it waits for
I/O, locks, etc. This time depends on the available resources of the
system.</li></ul><p>This way you can decide which sections of your code need optimizing. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0321" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775961"></a><a name="Heading24170"></a>Coverage testing<br></h3>
<p><a name="Index2067"></a><i>Coverage testing</i> shows the lines of code that were not executed during the test. This can draw your attention to code that is not used and might therefore be a candidate for removal or refactoring. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0322" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To get coverage testing information for <b>SimpleDebugging.java</b>, you use the command:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java &#150;Xrunjcov:type=M SimpleDebugging</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>As an experiment, try putting lines of code that will not be executed into <b>SimpleDebugging.java</b> (you&#146;ll have to be somewhat clever about this since the compiler can detect unreachable lines of code). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0323" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775962"></a><a name="Heading24176"></a>JVM Profiling
Interface</h3>
<p>The <i>profiler agent</i> communicates the events it is interested in to the JVM. The JVM profiling interface supports the following events:<br></p>
<ul>
<li><a name="Index2068"></a>Enter and exit a method</li>
<li>Allocate, move, and free an object</li>
<li>Create and delete a heap arena </li>
<li>Begin and end a garbage collection cycle </li>
<li>Allocate and free a JNI global reference</li>
<li>Allocate and free a JNI weak global reference</li>
<li>Load and unload a compiled method </li>
<li>Start and end a thread </li>
<li>Class file data ready for instrumentation </li>
<li>Load and unload a class </li>
<li>For a Java monitor under contention: Wait To Enter , entered, and exit </li>
<li>For a raw monitor under contention: Wait To Enter, entered, and exit </li>
<li>For an uncontended Java monitor: Wait and waited </li>
<li>Monitor Dump </li>
<li>Heap Dump </li>
<li>Object Dump </li>
<li>Request to dump or reset profiling data </li>
<li>JVM initialization and
shutdown</li></ul><p>While profiling, the JVM sends these events to the profiler agent, which then transfers the desired information to the <i>profiler front end</i>, which can be a process running on another machine, if desired. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0324" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775963"></a><a name="Heading24197"></a>Using HPROF<br></h3>
<p><a name="Index2069"></a>The example in this section shows how you can run the profiler that ships with the JDK. Although the information from this profiler is in the somewhat crude form of text files rather than the graphical representation that most commercial profilers produce, it still provides valuable help in determining the characteristics of your program. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0325" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You run the profiler by passing an extra argument to the JVM when you invoke the program. This argument must be a single string, without any spaces after the commas, like this (although it should be on a single line, it has wrapped in the book): <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0326" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java &#150;Xrunhprof:heap=sites,cpu=samples,depth=10,monitor=y,thread=y,doe=y ListPerformance</PRE></FONT></BLOCKQUOTE><p><br></p>
<ul>
<li>The <b>heap=sites</b> tells the profiler to write information about memory
utilization on the heap, indicating where it was allocated. </li>
<li><b>cpu=samples</b> tells the profiler to do statistical sampling to
determine CPU use. </li>
<li><b>depth=10</b> indicates the depth of the trace for threads. </li>
<li><b>thread=y</b> tells the profiler to identify the threads in the stack
traces.</li>
<li><b>doe=y</b> tells the profiler to produce dump of profiling data on
exit.</li></ul><p>The following listing contains only a portion of the file produced by HPROF. The output file is created in the current directory and is named <b>java.hprof.txt</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0327" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The beginning of <b>java.hprof.txt</b> describes the details of the remaining sections in the file. The data produced by the profiler is in different sections; for example, TRACE represents a trace section in the file. You will see many TRACE sections, each numbered so that they can be referenced later. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0740" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The SITES section shows memory allocation sites. The section has several rows, sorted by the number of bytes that are allocated and are being referenced&#151;the live bytes. The memory is listed in bytes. The column <i>self</i> represents the percentage of memory taken up by this site, the next column, <i>accum</i>, represents the cumulative memory percentage. The <i>live bytes</i> and <i>live objects</i> columns represent the number of live bytes at this site and the number of objects that were created that consumes these bytes. The <i>allocated bytes</i> <i>and objects </i>represent the total number of objects and bytes that are instantiated, including the ones being used and the ones not being used. The difference in the number of bytes listed in allocated and live represent the bytes that can be garbage collected. The <i>trace</i> column actually references a TRACE in the file. The first row references trace 668 as shown below. The <i>name</i> represents the class whose instance was created. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0328" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>SITES BEGIN (ordered by live bytes) Thu Jul 18 11:23:06 2002
          percent         live       alloc'ed  stack <font color=#0000ff>class</font>
 rank   self  accum    bytes objs   bytes objs trace name
    1 59.10% 59.10%   573488    3  573488    3   668 java.lang.Object
    2  7.41% 66.50%    71880  543   72624  559     1 [C
    3  7.39% 73.89%    71728    3   82000   10   649 java.lang.Object
    4  5.14% 79.03%    49896  232   49896  232     1 [B
    5  2.53% 81.57%    24592  310   24592  310     1 [S 

TRACE 668: (thread=1)
	java.util.Vector.ensureCapacityHelper(Vector.java:222)
	java.util.Vector.insertElementAt(Vector.java:564)
	java.util.Vector.add(Vector.java:779)
	java.util.AbstractList$ListItr.add(AbstractList.java:495)
	ListPerformance$3.test(ListPerformance.java:40)
	ListPerformance.test(ListPerformance.java:63)
	ListPerformance.main(ListPerformance.java:93)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This trace shows the method call sequence that allocates the memory. If you go through the trace as indicated by the line numbers, you will find that an object allocation takes place on line number 222 of <b>Vector.java</b>:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>elementData = <font color=#0000ff>new</font> Object[newCapacity];</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This helps you discover parts of the program that use up significant amounts of memory (59.10 %, in this case). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0738" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Note the <b>[C</b> in SITE 1 represents the primitive type <b>char</b>. This is the internal representation of the JVM for the primitive types. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0329" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775964"></a><a name="Heading24233"></a>Thread
performance<br></h3>
<p><a name="Index2070"></a>The CPU SAMPLES section shows the CPU utilization. Here is part of a trace from this section. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0330" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>SITES END
CPU SAMPLES BEGIN (total = 514) Thu Jul 18 11:23:06 2002
rank   self  accum   count trace method
   1 28.21% 28.21%     145   662 java.util.AbstractList.iterator
   2 12.06% 40.27%      62   589 java.util.AbstractList.iterator
   3 10.12% 50.39%      52   632 java.util.LinkedList.listIterator
   4  7.00% 57.39%      36   231 java.io.FileInputStream.open
   5  5.64% 63.04%      29   605 ListPerformance$4.test
   6  3.70% 66.73%      19   636 java.util.LinkedList.addBefore</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The organization of this listing is similar to the organization of the SITES listings. The rows are sorted by CPU utilization. The row on the top has the maximum CPU utilization, as indicated in the <i>self</i> column. The <i>accum</i> column lists the cumulative CPU utilization. The <i>count</i> field specifies the number of times this trace was active. The next two columns specify the trace number and the method that took this time. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0739" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Consider the first row of the CPU SAMPLES section. 28.12% of total CPU time was utilized in the method <b>java.util.AbstractList.iterator(&#160;)</b>,<b> </b>and it was called 145 times. The details of this call can be seen by looking at trace number 662: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0331" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>TRACE 662: (thread=1)
	java.util.AbstractList.iterator(AbstractList.java:332)
	ListPerformance$2.test(ListPerformance.java:28)
	ListPerformance.test(ListPerformance.java:63)
	ListPerformance.main(ListPerformance.java:93)</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can infer that iterating through a list takes a significant amount of time. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0332" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>For large projects it is often more helpful to have the information represented in graphical form. A number of profilers produce graphical displays, but coverage of these is beyond the scope of this book. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0333" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775965"></a><a name="Heading24255"></a>Optimization
guidelines</h3>
<ul>
<li>Avoid sacrificing code readability for performance. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0334" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Performance should not be considered in isolation. Weigh the amount of
effort required versus the advantage gained. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0335" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Performance can be a concern in big projects but is often not an issue for
small projects. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0336" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Getting a program to work should have a higher priority than delving into
the performance of the program. Once you have a working program you can use the
profiler to make it more efficient. Performance should be considered during the
initial design/development process only if it is determined to be a critical
factor. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0337"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>Do not make assumptions about where the bottlenecks are. Run a profiler to
get the data. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0338" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Whenever possible try to explicitly discard an instance by setting it to
null. This can sometimes be a useful hint to the garbage collector. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0341" title="Send
BackTalk Comment">Feedback</a></font></li>
<li>The size of the program matters. Performance optimization is generally
valuable only when the size of the project is large, it runs for a long time and
speed is an issue. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0342" title="Send BackTalk
Comment">Feedback</a></font></li>
<li><b>static</b> <b>final</b> variables can be optimized by the JVM to improve
program speed. Program constants should thus be declared as <b>static</b> and
<b>final</b>. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0346" title="Send BackTalk
Comment">Feedback</a></font></li></ul><h2>
<a name="_Toc24775966"></a><a name="Heading24264"></a>Doclets</h2>
<p>Although it might be a bit surprising to think of a tool that was developed for documentation support as something that helps you track down problems in your programs, <a name="Index2071"></a><i>doclets</i> can be surprisingly useful. Because a doclet hooks into the javadoc parser, it has information available to that parser. With this, you can programmatically examine the class names, field names, and method signatures in your code and flag potential problems. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0347" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The process of producing the JDK documentation from the Java source files involves the parsing of the source file and the formatting of this parsed file by using the <i>standard doclet</i>. You can write a custom doclet to customize the formatting of your javadoc comments. However, doclets allow you to do far more than just formatting the comment because a doclet has available much of the information about the source file that&#146;s being parsed. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0348" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can extract information about all the members of the class: fields, constructors, methods, and the comments associated with each of the members (alas, the method code body is not available). Details about the members are encapsulated inside special objects, which contain information about the properties of the member (private, static, final etc.). This information can be helpful in detecting poorly written code, such as member variables that should be private but are public, method parameters without comments, and identifiers that do not follow naming conventions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0349" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Javadoc may not catch all compilation errors. It will spot syntax errors, such as an unmatched brace, but it may not catch semantic errors. The safest approach is to run the Java compiler on your code before attempting to use a doclet-based tool. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0350" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The parsing mechanism provided by javadoc parses the entire source file and stores it in memory in an object of class <b>RootDoc</b>. The entry point for the doclet submitted to javadoc is <b>start(RootDoc doc)</b>. It is comparable to a normal Java program&#146;s <b>main(String[] args)</b>. You may traverse through the <b>RootDoc </b>object and extract the necessary information. The following example shows how to write a simple doclet; it just prints out all the members of each class that was parsed: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0351" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c15:PrintMembersDoclet.java</font>
<font color=#009900>// Doclet that prints out all members of the class.</font>
<font color=#0000ff>import</font> com.sun.javadoc.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintMembersDoclet {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> start(RootDoc root) {
    ClassDoc[] classes = root.classes();
    processClasses(classes);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> processClasses(ClassDoc[] classes) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; classes.length; i++) {
      processOneClass(classes[i]);
    }
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> processOneClass(ClassDoc cls) {
    FieldDoc[] fd = cls.fields();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; fd.length; i++)
      processDocElement(fd[i]);
    ConstructorDoc[] cons = cls.constructors();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cons.length; i++)
      processDocElement(cons[i]);
    MethodDoc[] md = cls.methods();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; md.length; i++)
      processDocElement(md[i]);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> processDocElement(Doc dc) {
    MemberDoc md = (MemberDoc)dc;
    System.out.print(md.modifiers());
    System.out.print(<font color=#004488>" "</font> + md.name());
    <font color=#0000ff>if</font>(md.isMethod())
      System.out.println(<font color=#004488>"()"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(md.isConstructor())
      System.out.println();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><p><br></p>
<p>You can use the doclet to print the members like this:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>javadoc -doclet PrintMembersDoclet -<font color=#0000ff>private</font> PrintMembersDoclet.java</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This invokes javadoc on the last argument in the command, which means it will parse the <b>PrintMembersDoclet.java </b>file. The <b>-doclet</b> option tells javadoc to use the custom doclet <b>PrintMembersDoclet</b>. The <b>-private</b> tag instructs javadoc to also print <b>private</b> members (the default is to print only <b>protected</b> and <b>public</b> members). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0352" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>RootDoc </b>contains a collection of <b>ClassDoc</b> that holds all the information about the class. Classes such as <b>MethodDoc</b>, <b>FieldDoc</b>, and <b>ConstructorDoc</b> contain information regarding methods, fields, and constructors, respectively. The method <b>processOneClass(&#160;) </b>extracts the list of these members and prints them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0353" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can also create <i>taglets</i>, which allow you to implement custom javadoc tags. The JDK documentation presents an example that implements a <b>@todo</b> tag, which displays its text in yellow in the resulting Javadoc output. Search for &#147;taglet&#148; in the JDK documentation for more details. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0354" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775967"></a><a name="Heading24313"></a>Summary</h2>
<p>This chapter introduced what I&#146;ve come to realize may be the most essential issue in programming, superceding language syntax and design issues: <i>How do you make sure your code is correct, and keep it that way?</i><br></p>
<p>Recent experience has shown that the most useful and practical tool to date is unit testing, which, as shown in this chapter, may be combined very effectively with Design by Contract. There are other types of tests as well, such as conformance testing to verify that your use cases/user stories have all been implemented. But for some reason, we have in the past relegated testing to be done later by someone else. Extreme Programming insists that the unit tests be written before the code; you create the test framework for the class, and then the class itself (on one or two occasions I&#146;ve successfully done this, but I&#146;m generally pleased if testing appears somewhere during the initial coding process). There remains resistance to testing, usually by those who haven&#146;t tried it and believe they can write good code without testing. But the more experience I have, the more I repeat to myself:<br></p>
<p><i>If it&#146;s not tested, it&#146;s broken.</i><br></p>
<p>This a worthwhile mantra, especially when you&#146;re thinking about cutting corners. The more of your own bugs you discover, the more attached you grow to the security of built-in tests.<br></p>
<p>Build systems (in particular, Ant) and revision control (CVS) were also introduced in this chapter because they provide structure for your project and its tests. To me, the primary goal of Extreme Programming is <i>velocity</i>&#151;the ability to rapidly move your project forward (but in a reliable fashion), and to quickly refactor it when you realize that it can be improved. Velocity requires a support structure to give you confidence that things won&#146;t fall through the cracks when you start making big changes to your project. This includes a reliable repository, which allows you to roll back to any previous version, and an automatic build system that, once configured, guarantees that the project can be compiled and tested in a single step.<br></p>
<p>Once you have reason to believe that your program is healthy, logging provides a way to monitor its pulse, and even (as shown in this chapter) to automatically email you if something starts to go wrong. When it does, debugging and profiling help you track down bugs and performance issues.<br></p>
<p>Perhaps it&#146;s the nature of computer programming to want a single, clear, concrete answer. After all, we work with ones and zeros, which do not have fuzzy boundaries (they actually do, but the electronic engineers have gone to great lengths to give us the model we want). When it comes to solutions, it&#146;s great to believe that there&#146;s one answer. But I&#146;ve found that there are boundaries to any technique, and understanding where those boundaries are is far more powerful than any single approach can be, because it allows you to use a method where its greatest strength lies, and to combine it with other approaches where it isn&#146;t so strong. For example, in this chapter Design by Contract was presented in combination with white-box unit testing, and as I was creating the example, I discovered that the two working in concert were much more useful than either one alone.<br></p>
<p>I have found this idea to be true in more than just the issue of discovering problems, but also in building systems in the first place. For example, using a single programming language or tool to solve your problem is attractive from the standpoint of consistency, but I&#146;ve often found that I can solve certain problems much more quickly and effectively by using the Python programming language instead of Java, to the general benefit of the project. You may also discover that Ant works in some places, and in others, make is more useful. Or, if your clients are on Windows platforms, it may be sensible to make the radical decision of using Delphi or Visual BASIC to develop client-side programs more rapidly than you could in Java. The important thing is to keep an open mind and remember that you are trying to achieve results, not necessarily use a certain tool or technique. This can be difficult, but if you remember that the project failure rate is quite high and your chances of success are proportionally low, you could be a little more open to solutions that might be more productive. One of my favorite phrases from Extreme Programming (and one I find that I violate often for usually silly reasons) is &#147;do the simplest thing that could possibly work.&#148; Most of the time, the simplest and most expedient approach, if you can discover it, is the best one.<br></p>
<h2>
<a name="_Toc24775968"></a><a name="Heading24322"></a>Exercises</h2>
<ol>
<li>	Create a class containing a <b>static</b> clause that throws an exception
if assertions are not enabled. Demonstrate that this test works correctly.</li>
<li>	Modify the preceding exercise to use the approach in
<b>LoaderAssertions.java</b> to turn on assertions instead of throwing an
exception. Demonstrate that this works correctly.</li>
<li>	In <b>LoggingLevels.java</b>, comment out the code that sets the severity
level of the root logger handlers and verify that messages of level
<b>CONFIG</b> and below are not reported. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0150" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Inherit from <b>java.util.Logging.Level</b> and define your own level with
a value less than FINEST. Modify <b>LoggingLevels.java</b> to use your new level
and show that messages at your level will not appear when the logging level is
FINEST.</li>
<li>	Associate a <b>FileHandler</b> with the root logger. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0151" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify the <b>FileHandler</b> so that it formats output to a simple text
file. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0152"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Modify <b>MultipleHandlers.java</b> so that it generates output in plain
text format instead of XML. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0153" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Modify <b>LoggingLevels.java </b>to set different logging levels for the
handlers associated with the root logger. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0154" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Write a simple program that sets the root logger logging level based on a
command-line argument. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0155" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>	Write an example using Formatters and Handlers to output a log file as
HTML. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0156"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>	Write an example using Handlers and Filters to log messages with any
severity level over INFO in one file and any severity level including and below
INFO in other file. The files should be written in simple text. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0157" title="Send
BackTalk Comment">Feedback</a></font></li>
<li>	Modify <b>log.prop </b>to add an additional initialization class that
initializes a custom <b>Formatter</b> for the logger <b>com</b>. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0158" title="Send
BackTalk Comment">Feedback</a></font></li>
<li>	Run JDB on <b>SimpleDebugging.java</b>, but do not give the command
<b>catch Exception</b>. Show that it still catches the exception.</li>
<li>	Add an uninitialized reference to <b>SimpleDebugging.java</b> (you&#146;ll
have to do it in a way that the compiler doesn&#146;t catch the error!) and use
JDB to track down the problem.</li>
<li>	Perform the experiment described in the &#147;Coverage Testing&#148;
section.</li>
<li>	Create a doclet that displays identifiers that might not follow the Java
naming convention by checking how capital letters are used for those
identifiers.</li></ol><hr><p class="footnote text"><sup><a name="fn86" href="#fnB86">[86]</a></sup> It is primarily oriented to static checking, however. There is an alternative system, called <i>latent typing</i> or <i>dynamic typing </i>or <i>weak typing</i>, in which the type of an object is still enforced, but it is enforced at run time, when the type is used, rather than at compile time. Writing code in such a language&#151;Python (http://www.python.org) is an excellent example&#151;gives the programmer much more flexibility and requires far less verbiage to satisfy the compiler, and yet still guarantees that objects are used properly. However, to a programmer convinced that strong, static type checking is the only sensible solution, latent typing is anathema and serious flame wars have resulted from comparisons between the two approaches. As someone who is always in pursuit of greater productivity, I have found the value of latent typing to be very compelling. In addition, the ability to think about the issues of latent typing help you, I believe, to solve problems that are difficult to think about in strong, statically typed languages.<br></p>
<p class="footnote text"><sup><a name="fn87" href="#fnB87">[87]</a></sup> Although the electronic version of this book is freely available, it is not open source.<br></p>
<p class="footnote text"><sup><a name="fn88" href="#fnB88">[88]</a></sup> The first try, anyway. I find that the process of building something for the first time eventually produces insights and new ideas.<br></p>
<p class="footnote text"><sup><a name="fn89" href="#fnB89">[89]</a></sup> Inspired by Python&#146;s <b>doctest</b> module.<br></p>
<p class="footnote text"><sup><a name="fn90" href="#fnB90">[90]</a></sup> Originally placed in <i>Thinking in Patterns (with Java)</i> at www.BruceEckel.com. However, with the addition of the reflection approach in JUnit, my framework doesn&#146;t make much sense anymore and will probably be removed.<br></p>
<p class="footnote text"><sup><a name="fn91" href="#fnB91">[91]</a></sup> A key phrase from Extreme Programming (XP). Ironically, one of the JUnit authors (Kent Beck) is also the author of <i>Extreme Programming Explained</i> (Addison-Wesley 2000) and a main proponent of XP.<br></p>
<p class="footnote text"><sup><a name="fn92" href="#fnB92">[92]</a></sup> Bill Venners and I have discussed this at some length, and we haven&#146;t been able to figure out why it is done this way rather than creating each object right before the test is run. It is likely that it is simply an artifact of the way JUnit was originally implemented.<br></p>
<p class="footnote text"><sup><a name="fn93" href="#fnB93">[93]</a></sup> Design by contract is described in detail in Chapter 11 of <i>Object-Oriented Software Construction, 2<sup>nd</sup> Edition,</i> by Bertrand Meyer, Prentice Hall 1997.<br></p>
<p class="footnote text"><sup><a name="fn94" href="#fnB94">[94]</a></sup> Except by the occasional company which, for reasons beyond comprehension, is still convinced that closed-source tools are somehow better or have superior tech support. The only situations where I&#146;ve seen this to be true are when tools have a very small user base, but even then it would be safer to hire consultants to modify open-source tools, and thus leverage prior work and guarantee that the work you pay for won&#146;t become unavailable to you (and also make it more likely that you&#146;ll find other consultants already up to speed on the program).<br></p>
<p class="footnote text"><sup><a name="fn95" href="#fnB95">[95]</a></sup> This is not available on the web site because it&#146;s too customized to be generally useful.<br></p>
<p class="footnote text"><sup><a name="fn96" href="#fnB96">[96]</a></sup> Other tools are under development, that attempt to repair the problems with <b>make</b> without making Ant&#146;s compromises. See, for example, <i>www.a-a-p.org</i> or search the Web for &#147;bjam.&#148;<br></p>
<p class="footnote text"><sup><a name="fn97" href="#fnB97">[97]</a></sup> <b>Cron</b> is a program that was developed under Unix to run programs at specified times. However, it is also available in free versions under Windows, and as a Windows NT/2000 service: http://www.kalab.com/freeware/cron/cron.htm.<br></p>
<p class="footnote text"><sup><a name="fn98" href="#fnB98">[98]</a></sup> A pluggable algorithm. Strategies allow you to easily change one part of a solution while leaving the rest unchanged. They are often used (as in this case) as ways to allow the client programmer to provide a portion of the code needed to solve a particular problem. For more details, see <i>Thinking in Patterns (with Java)</i> at <i>www.BruceEckel.com</i>.<br></p>
<p class="footnote text"><sup><a name="fn99" href="#fnB99">[99]</a></sup> A term coined by Bill Venners. This may or may not be a design pattern.<br></p>
<p class="footnote text"><sup><a name="fn100" href="#fnB100">[100]</a></sup> This is the <i>Observer</i> design pattern (ibid).<br></p>
<p class="footnote text"><sup><a name="fn101" href="#fnB101">[101]</a></sup> I learned C++ primarily by printing information, since at the time I was learning there were no debuggers available.<br></p>

<!-- <hr><b>Placeholder</b> -->

<hr>

<div align="CENTER"><a href="TIJ316.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ318.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>

</font></body>

</html>

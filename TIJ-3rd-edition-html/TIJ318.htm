<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en">
<!--
This document was converted from RTF source: 
By r2net 5.8 r2netcmd Windows 
See http://www.logictran.com
-->
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Thinking in Java, 3rd ed. Revision 4.0: 16: Analysis and Design</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css"></head>

<body >
   <CENTER>     <a href="http://www.MindView.net">     <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>     <Font FACE="Verdana, Tahoma, Arial, Helvetica, Sans">     <h2>Thinking in Java, 3<sup>rd</sup> ed. Revision 4.0</h2>     <FONT size = "-1"><br>     [ <a href="README.txt">Viewing Hints</a> ]     [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]     [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>     [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]     [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]     [ <a href="http://www.mindview.net/Services">Consulting</a> ] <br><br>     </FONT></FONT>   </CENTER> 
<font face="Georgia"><div align="CENTER"><a href="TIJ317.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ319.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>
<hr>

<h1>
<a name="_Toc375545505"></a><a name="_Toc375545421"></a><a name="_Toc472654691"></a><a name="_Toc24272655"></a><a name="_Toc24775969"></a><a name="Heading24340"></a>16:
Analysis and Design</h1>
<p class="Intro">The object-oriented paradigm is a new and different way of thinking about programming.<br></p>
<p><a name="Index2072"></a><a name="Index2073"></a><a name="Index2074"></a><a name="Index2075"></a>Many people have trouble at first knowing how to approach an OOP project. Now that you understand the concept of an object, and as you learn to think more in an object-oriented style, you can begin to create &#147;good&#148; designs that take advantage of all the benefits that OOP has to offer. This chapter introduces the ideas of analysis, design, and some ways to approach the problems of developing good object-oriented programs in a reasonable amount of time. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_251" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775970"></a><a name="Heading24343"></a>Methodology<br></h2>
<p><a name="Index2076"></a>A <i>methodology</i> (sometimes simply called a <i>method</i>)<i> </i>is a set of processes and heuristics used to break down the complexity of a programming problem. Many OOP methodologies have been formulated since the dawn of object-oriented programming. This section will give you a feel for what you&#146;re trying to accomplish when using a methodology. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_252" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Especially in OOP, methodology is a field of many experiments, so it is important to understand what problem the methodology is trying to solve before you consider adopting one. This is particularly true with Java, in which the programming language is intended to reduce the complexity (compared to C) involved in expressing a program. This may in fact alleviate the need for ever-more-complex methodologies. Instead, simple methodologies may suffice in Java for a much larger class of problems than you could handle using simple methodologies with procedural languages. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_253" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s also important to realize that the term &#147;methodology&#148; is often too grand and promises too much. Whatever you do now when you design and write a program is a methodology. It may be your own methodology, and you may not be conscious of doing it, but it is a process you go through as you create. If it is an effective process, it may need only a small tune-up to work with Java. If you are not satisfied with your productivity and the way your programs turn out, you may want to consider adopting a formal methodology, or choosing pieces from among the many formal methodologies.<i> </i><font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_254" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>While you&#146;re going through the development process, the most important issue is this: Don&#146;t get lost. It&#146;s easy to do. Most of the analysis and design methodologies are intended to solve the largest of problems. Remember that most projects don&#146;t fit into that category, so you can usually have successful analysis and design with a relatively small subset of what a methodology recommends.<a name="Index2077"></a><sup><a name="fnB102" href="#fn102">[102]</a></sup> But some sort of process, no matter how small or limited, will generally get you on your way in a much better fashion than simply beginning to code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_255" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s also easy to get stuck, to fall into &#147;analysis paralysis,&#148; where you feel like you can&#146;t move forward because you haven&#146;t nailed down every little detail at the current stage. Remember, no matter how much analysis you do, there are some things about a system that won&#146;t reveal themselves until design time, and more things that won&#146;t reveal themselves until you&#146;re coding, or not even until a program is up and running. Because of this, it&#146;s crucial to move fairly quickly through analysis and design, and to implement a test of the proposed system. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_256" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2079"></a><a name="Index2080"></a>This point is worth emphasizing. Because of the history we&#146;ve had with procedural languages, it is commendable that a team will want to proceed carefully and understand every minute detail before moving to design and implementation. Certainly, when creating a Database Management System (<i>DBMS</i>), it pays to understand a customer&#146;s needs thoroughly. But a DBMS is in a class of problems that is very well-posed and well-understood; in many such programs, the database structure <i>is</i> the problem to be tackled. The class of programming problem discussed in this chapter is of the &#147;wild-card&#148; (my term) variety, in which the solution isn&#146;t simply re-forming a well-known solution, but instead involves one or more &#147;wild-card<a name="Index2081"></a> factors&#148;&#151;elements for which there is no well-understood previous solution, and for which research is necessary.<sup><a name="fnB103" href="#fn103">[103]</a></sup> Attempting to thoroughly analyze a wild-card problem before moving into design and implementation results in analysis paralysis because you don&#146;t have enough information to solve this kind of problem during the analysis phase. Solving such a problem requires iteration through the whole cycle, and that requires risk-taking behavior (which makes sense, because you&#146;re trying to do something new and the potential rewards are higher). It may seem like the risk is compounded by &#147;rushing&#148; into a preliminary implementation, but it can instead reduce the risk in a wild-card project because you&#146;re finding out early whether a particular approach to the problem is viable. Product development is risk management. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_257" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s often proposed that you &#147;build one to throw away.&#148; With OOP, you may still throw <i>part</i> of it away, but because code is encapsulated into classes, during the first pass you will inevitably produce some useful class designs and develop some worthwhile ideas about the system design that do not need to be thrown away. Thus, the first rapid pass at a problem not only produces critical information for the next analysis, design, and implementation pass, it also creates a code foundation. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_258" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>That said, if you&#146;re looking at a methodology that contains tremendous detail and suggests many steps and documents, it&#146;s still difficult to know when to stop. Keep in mind what you&#146;re trying to discover: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_259" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>What are the objects? (How do you partition your project into its component
parts?)</li>
<li>What are their interfaces? (What messages do you need to send to each
object?)</li></ol><p>If you come up with nothing more than the objects and their interfaces, then you can write a program. For various reasons you might need more descriptions and documents than this, but you can&#146;t get away with any less. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_260" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The process can be undertaken in five phases, and a Phase 0 that is just the initial commitment to using some kind of structure. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_261" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc408018410"></a><a name="_Toc472654692"></a><a name="_Toc24775971"></a><a name="Heading24358"></a>Phase
0: Make a plan</h2>
<p>You must first decide what steps you&#146;re going to have in your process. It sounds simple (in fact, <i>all</i> of this sounds simple), and yet people often don&#146;t make this decision before they start coding. If your plan is &#147;let&#146;s jump in and start coding,&#148; fine. (Sometimes that&#146;s appropriate when you have a well-understood problem.) At least agree that this is the plan. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_262" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2082"></a>You might also decide at this phase that some additional process structure is necessary, but not the whole nine yards. Understandably, some programmers like to work in &#147;vacation mode,&#148; in which no structure is imposed on the process of developing their work; &#147;It will be done when it&#146;s done.&#148; This can be appealing for a while, but I&#146;ve found that having a few milestones along the way helps to focus and galvanize your efforts around those milestones instead of being stuck with the single goal of &#147;finish the project.&#148; In addition, it divides the project into more bite-sized pieces and makes it seem less threatening (plus the milestones offer more opportunities for celebration). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_263" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When I began to study story structure (so that I will someday write a novel) I was initially resistant to the idea of structure, feeling that I wrote best when I simply let it flow onto the page. But I later realized that when I write about computers the structure is clear enough to me that I don&#146;t have to think about it very much. I still structure my work, albeit only semi-consciously in my head. Even if you think that your plan is to just start coding, you still somehow go through the subsequent phases while asking and answering certain questions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_264" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc408018411"></a><a name="_Toc24775972"></a><a name="Heading24362"></a>The
mission statement<br></h3>
<p><a name="Index2083"></a><a name="Index2084"></a>Any system you build, no matter how complicated, has a fundamental purpose&#151;the business that it&#146;s in, the basic need that it satisfies. If you can look past the user interface, the hardware- or system-specific details, the coding algorithms and the efficiency problems, you will eventually find the core of its being&#151;simple and straightforward. Like the so-called <a name="Index2085"></a><a name="Index2086"></a><i>high concept</i> from a Hollywood movie, you can describe it in one or two sentences. This pure description is the starting point. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_265" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The high concept is quite important because it sets the tone for your project; it&#146;s a mission statement. You won&#146;t necessarily get it right the first time (you may be in a later phase of the project before it becomes completely clear), but keep trying until it feels right. For example, in an air-traffic control system you may start out with a high concept focused on the system that you&#146;re building: &#147;The tower program keeps track of the aircraft.&#148; But consider what happens when you shrink the system to a very small airfield; perhaps there&#146;s only a human controller, or none at all. A more useful model won&#146;t concern the solution you&#146;re creating as much as it describes the problem: &#147;Aircraft arrive, unload, service and reload, then depart.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_266" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc472654693"></a><a name="_Toc24775973"></a><a name="Heading24365"></a>Phase
1: What are we making?</h2>
<p>In the previous generation of program design (called <i>procedural design</i>), this is called &#147;creating the <a name="Index2087"></a><a name="Index2088"></a><i>requirements analysis</i> and <a name="Index2089"></a><a name="Index2090"></a><i>system specification</i>.&#148; These, of course, were places to get lost; documents with intimidating names that could become big projects in their own right. Their intention was good, however. The requirements analysis says &#147;Make a list of the guidelines we will use to know when the job is done and the customer is satisfied.&#148;<sup><a name="fnB104" href="#fn104">[104]</a></sup> The system specification says &#147;Here&#146;s a description of <i>what</i> the program will do (not <i>how</i>) to satisfy the requirements.&#148; The requirements analysis is really a contract between you and the customer (even if the customer works within your company, or is some other object or system). The system specification is a top-level exploration into the problem and in some sense a discovery of whether it can be done and how long it will take. Since both of these will require consensus among people (and because they will usually change over time), I think it&#146;s best to keep them as bare as possible&#151;ideally, to lists and basic diagrams&#151;to save time (this is in line with Extreme Programming, which advocates very minimal documentation, albeit for small- to medium-sized projects). You might have other constraints that require you to expand them into bigger documents, but by keeping the initial document small and concise, it can be created in a few sessions of group brainstorming with a leader who dynamically creates the description. This not only solicits input from everyone, it also fosters initial buy-in and agreement by everyone on the team. Perhaps most importantly, it can kick off a project with a lot of enthusiasm. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_267" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s necessary to stay focused on the heart of what you&#146;re trying to accomplish in this phase: Determine what the system is supposed to do. The most valuable tool for this is a collection of what are called &#147;use cases,&#148; or in Extreme Programming, &#147;user stories.&#148; Use cases identify key features in the system that will reveal some of the fundamental classes you&#146;ll be using. These are essentially descriptive answers to questions like:<a name="Index2091"></a><sup><a name="fnB105" href="#fn105">[105]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_268" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ul>
<li>&#147;Who will use this system?&#148; </li>
<li>&#147;What can those actors do with the system?&#148; </li>
<li>&#147;How does <i>this</i> actor do <i>that</i> with this
system?&#148;</li>
<li>&#147;How else might this work if someone else were doing this, or if the
same actor had a different objective?&#148; (to reveal variations)</li>
<li>&#147;What problems might happen while doing this with the system?&#148;
(to reveal
exceptions)</li></ul><p>If you are designing a bank auto-teller, for example, the use case for a particular aspect of the functionality of the system is able to describe what the auto-teller does in every possible situation. Each of these &#147;situations&#148; is referred to as a <a name="Index2092"></a><i>scenario</i>, and a use case can be considered a collection of scenarios. You can think of a scenario as a question that starts with: &#147;What does the system do if...?&#148; For example, &#147;What does the auto-teller do if a customer has just deposited a check within the last 24 hours, and there&#146;s not enough in the account without the check having cleared to provide a desired withdrawal?&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_269" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2093"></a>Use case diagrams are intentionally simple to prevent you from getting bogged down in system implementation details prematurely:<br></p>
<p align="center"><img src="TIJ337.png" 	alt="TIJ337.png" border="0" ><br></p>
<p>Each stick person represents an &#147;actor,&#148; which is typically a human or some other kind of free agent. (These can even be other computer systems, as is the case with &#147;ATM.&#148;) The box represents the boundary of your system. The ellipses represent the use cases, which are descriptions of valuable work that can be performed with the system. The lines between the actors and the use cases represent the interactions. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_270" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2094"></a>It doesn&#146;t matter how the system is actually implemented, as long as it looks like this to the user. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_271" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A use case does not need to be terribly complex, even if the underlying system is complex. It is only intended to show the system as it appears to the user. For example: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_272" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><img src="TIJ338.png" 	alt="TIJ338.png" border="0" ><br></p>
<p>The use cases produce the requirements specifications by determining all the interactions that the user may have with the system. You try to discover a full set of use cases for your system, and once you&#146;ve done that you have the core of what the system is supposed to do. The nice thing about focusing on use cases is that they always bring you back to the essentials and keep you from drifting off into issues that aren&#146;t critical for getting the job done. That is, if you have a full set of use cases, you can describe your system and move on to the next phase. You probably won&#146;t get it all figured out perfectly on the first try, but that&#146;s OK. Everything will reveal itself in time, and if you demand a perfect system specification at this point you&#146;ll get stuck. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_273" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you do get stuck, you can kick-start this phase by using a rough approximation tool: Describe the system in a few paragraphs and then look for nouns and verbs. The nouns can suggest actors, context of the use case (e.g., &#147;lobby&#148;), or artifacts manipulated in the use case. Verbs can suggest interactions between actors and use cases, and specify steps within the use case. You&#146;ll also discover that nouns and verbs produce objects and messages during the design phase (and note that use cases describe interactions between subsystems, so the &#147;noun and verb&#148; technique can be used only as a brainstorming tool because it does not generate use cases).<sup><a name="fnB106" href="#fn106">[106]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_274" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The boundary between a use case and an actor can point out the existence of a user interface, but it does not define such a user interface. For a process of defining and creating user interfaces, see <a name="Index2095"></a><a name="Index2096"></a><i>Software for Use</i> by Larry Constantine and Lucy Lockwood, (Addison-Wesley Longman, 1999) or go to <i>www.ForUse.com</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_275" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Although it&#146;s a black art, at this point some kind of basic scheduling is important. You now have an overview of what you&#146;re building, so you&#146;ll probably be able to get some idea of how long it will take. A lot of factors come into play here. If you estimate a long schedule then the company might decide not to build it (and thus use their resources on something more reasonable&#151;that&#146;s a <a name="Index2097"></a><i>good</i> thing). Or a manager might have already decided how long the project should take and will try to influence your estimate. But it&#146;s best to have an honest schedule from the beginning and deal with the tough decisions early. There have been a lot of attempts to come up with accurate scheduling techniques (much like techniques to predict the stock market), but probably the best approach is to rely on your experience and intuition. Get a gut feeling for how long it will really take, then double that and add 10 percent. Your gut feeling is probably correct; you <i>can</i> get something working in that time. The &#147;doubling&#148; will turn that into something decent, and the 10 percent will deal with the final polishing and details.<sup><a name="fnB107" href="#fn107">[107]</a></sup> However you want to explain it, and regardless of the moans and manipulations that happen when you reveal such a schedule, it just seems to work out that way.<sup><a name="fnB108" href="#fn108">[108]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_276" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc408018412"></a><a name="_Toc472654694"></a><a name="_Toc24775974"></a><a name="Heading24389"></a>Phase
2: How will we build it?</h2>
<p>In this phase you must come up with a design that describes what the classes look like and how they will interact. An excellent technique in determining classes and interactions is the <a name="Index2098"></a><a name="Index2099"></a><i>Class-Responsibility-Collaboration</i> (CRC) card. Part of the value of this tool is that it&#146;s so low-tech: You start out with a set of blank 3 x 5 cards, and you write on them. Each card represents a single class, and on the card you write: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_277" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>The name of the class. It&#146;s important that this name capture the
essence of what the class does, so that it makes sense at a glance. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_278"
title="Send BackTalk Comment">Feedback</a></font></li>
<li>The &#147;responsibilities&#148; of the class: what it should do. This can
typically be summarized by just stating the names of the methods (since those
names should be descriptive in a good design), but it does not preclude other
notes. If you need to seed the process, look at the problem from a lazy
programmer&#146;s standpoint: What objects would you like to magically appear
to solve your problem? <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_279" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>The &#147;collaborations&#148; of the class: What other classes does it
interact with? &#147;Interact&#148; is an intentionally broad term; it could
mean aggregation or simply that some other object exists that will perform
services for an object of the class. Collaborations should also consider the
audience for this class. For example, if you create a class <b>Firecracker</b>,
who is going to observe it, a <b>Chemist</b> or a <b>Spectator</b>? The former
will want to know what chemicals go into the construction, and the latter will
respond to the colors and shapes released when it explodes. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_280" title="Send BackTalk
Comment">Feedback</a></font></li></ol><p>You may feel that the cards should be bigger because of all the information you&#146;d like to get on them. However, they are intentionally small, not only to keep your classes small but also to keep you from getting into too much detail too early. If you can&#146;t fit all you need to know about a class on a small card, then the class is too complex (either you&#146;re getting too detailed, or you should create more than one class). The ideal class should be understood at a glance. The idea of CRC cards is to assist you in coming up with a first cut of the design so that you can get the big picture and then refine your design. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_281" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One of the great benefits of CRC cards is in communication. It&#146;s best done in real time, in a group, without computers. Each person takes responsibility for several classes (which at first have no names or other information). You run a live simulation by solving one scenario at a time, deciding which messages are sent to the various objects to satisfy each scenario. As you go through this process, you discover the classes that you need along with their responsibilities and collaborations, and you fill out the cards as you do this. When you&#146;ve moved through all the use cases, you should have a fairly complete first cut of your design. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_282" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Before I began using CRC cards, the most successful consulting experiences I had when coming up with an initial design involved standing in front of a team&#151;who hadn&#146;t built an OOP project before&#151;and drawing objects on a whiteboard. We talked about how the objects should communicate with each other, and erased some of them and replaced them with other objects. Effectively, I was managing all the &#147;CRC cards&#148; on the whiteboard. The team (who knew what the project was supposed to do) actually created the design; they &#147;owned&#148; the design rather than having it given to them. All I was doing was guiding the process by asking the right questions, trying out the assumptions, and taking the feedback from the team to modify those assumptions. The true beauty of the process was that the team learned how to do object-oriented design not by reviewing abstract examples, but by working on the one design that was most interesting to them at that moment: theirs. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_283" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once you&#146;ve come up with a set of CRC cards, you may want to create a more formal description of your design using UML.<sup><a name="fnB109" href="#fn109">[109]</a></sup> You don&#146;t need to use UML, but it can be helpful, especially if you want to put up a diagram on the wall for everyone to ponder, which is a good idea (there is a plethora of UML diagramming tools available). An alternative to UML is a textual description of the objects and their interfaces, or, depending on your programming language, the code itself.<a name="Index2100"></a><sup><a name="fnB110" href="#fn110">[110]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_284" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>UML also provides an additional diagramming notation for describing the dynamic model of your system. This is helpful in situations in which the state transitions of a system or subsystem are dominant enough that they need their own diagrams (such as in a control system). You may also need to describe the data structures, for systems or subsystems in which data is a dominant factor (such as a database). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_285" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You&#146;ll know you&#146;re done with Phase 2 when you have described the objects and their interfaces. Well, most of them&#151;there are usually a few that slip through the cracks and don&#146;t make themselves known until Phase 3. But that&#146;s OK. What&#146;s important is that you eventually discover all of your objects. It&#146;s nice to discover them early in the process, but OOP provides enough structure so that it&#146;s not so bad if you discover them later. In fact, the design of an object tends to happen in five stages, throughout the process of program development. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_286" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc408018413"></a><a name="_Toc312373799"></a><a name="_Toc24775975"></a><a name="Heading24402"></a>Five
stages of object design<br></h3>
<p><a name="Index2102"></a><a name="Index2103"></a>The design life of an object is not limited to the time when you&#146;re writing the program. Instead, the design of an object appears over a sequence of stages. It&#146;s helpful to have this perspective because you stop expecting perfection right away; instead, you realize that the understanding of what an object does and what it should look like happens over time. This view also applies to the design of various types of programs; the pattern for a particular type of program emerges through struggling again and again with that problem (which is chronicled in the book <i>Thinking in Patterns (with Java)</i> at <i>www.BruceEckel.com</i>). Objects, too, have their patterns that emerge through understanding, use, and reuse. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_287" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>1. Object discovery. </b>This stage occurs during the initial analysis of a program. Objects may be discovered by looking for external factors and boundaries, duplication of elements in the system, and the smallest conceptual units. Some objects are obvious if you already have a set of class libraries. Commonality between classes suggesting base classes and inheritance may appear right away, or later in the design process. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_288" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>2. Object assembly. </b>As you&#146;re building an object you&#146;ll discover the need for new members that didn&#146;t appear during discovery. The internal needs of the object may require other classes to support it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_289" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>3. System construction. </b>Once again, more requirements for an object may appear at this later stage. As you learn, you evolve your objects. The need for communication and interconnection with other objects in the system may change the needs of your classes or require new classes. For example, you may discover the need for facilitator or helper classes, such as a linked list, that contain little or no state information and simply help other classes function. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_290" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>4. System extension. </b>As you add new features to a system you may discover that your previous design doesn&#146;t support easy system extension. With this new information, you can restructure parts of the system, possibly adding new classes or class hierarchies. This is also a good time to consider taking features <i>out</i> of a project. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_291" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><b>5. Object reuse. </b><a name="Index2104"></a>This is the real stress test for a class. If someone tries to reuse the class in an entirely new situation, they&#146;ll probably discover some shortcomings. As you change it to adapt to more new programs, the general principles of the class will become clearer, until you have a truly reusable type. However, don&#146;t expect most objects from a system design to be reusable&#151;it is perfectly acceptable for the bulk of your objects to be system-specific. Reusable types tend to be less common, and they must solve more general problems in order to be reusable. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_292" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775976"></a><a name="Heading24409"></a>Guidelines for object
development<br></h3>
<p><a name="Index2105"></a><a name="Index2106"></a>These stages suggest some guidelines when thinking about developing your classes: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_293" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li>Let a specific problem generate a class, then let the class grow and mature
during the solution of other problems. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_294" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Remember, discovering the classes you need (and their interfaces) is the
majority of the system design. If you already had those classes, this would be
an easy project. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_295" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Don&#146;t force yourself to know everything at the beginning. Learn as you
go. This will happen anyway. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_296" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Start programming. Get something working so you can prove or disprove your
design. Don&#146;t fear that you&#146;ll end up with procedural-style
spaghetti code&#151;classes partition the problem and help control anarchy and
entropy. Bad classes do not break good classes. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_297" title="Send BackTalk
Comment">Feedback</a></font></li>
<li>Always keep it simple. Little clean objects with obvious utility are better
than big complicated interfaces. When decision points come up, use an
Ockham&#146;s Razor<sup><a name="fnB111" href="#fn111">[111]</a></sup>
approach: Consider the choices and select the one that is simplest, because
simple classes are almost always best. Start small and simple, and you can
expand the class interface when you understand it better. It&#146;s easy to add
methods, but as time goes on, it&#146;s difficult to remove methods from a
class. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_298" title="Send BackTalk
Comment">Feedback</a></font></li></ol><h2>
<a name="_Toc472654695"></a><a name="_Toc24775977"></a><a name="Heading24417"></a>Phase
3: Build the core</h2>
<p>This is the initial conversion from the rough design into a compiling and executing body of code that can be tested, and especially that will prove or disprove your architecture. This is not a one-pass process, but rather the beginning of a series of steps that will iteratively build the system, as you&#146;ll see in Phase 4. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_299" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Your goal is to find the core of your system architecture that needs to be implemented in order to generate a running system, no matter how incomplete that system is in this initial pass. You&#146;re creating a framework that you can build on with further iterations. You&#146;re also performing the first of many system integrations and tests, and giving the stakeholders feedback about what their system will look like and how it is progressing. Ideally, you are exposing some of the critical risks. You&#146;ll probably discover changes and improvements that can be made to your original architecture&#151;things you would not have learned without implementing the system. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_300" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Part of building the system is the reality check that you get from testing against your requirements analysis and system specification (in whatever form they exist). Make sure that your tests verify the requirements and use cases. When the core of the system is stable, you&#146;re ready to move on and add more functionality. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_301" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc408018414"></a><a name="_Toc472654696"></a><a name="_Toc24775978"></a><a name="Heading24421"></a>Phase
4: Iterate the use cases</h2>
<p><a name="Index2107"></a>Once the core framework is running, each feature set you add is a small project in itself. You add a feature set during an <a name="Index2108"></a><i>iteration</i>, a reasonably short period of development. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_302" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>How big is an iteration? Ideally, each iteration lasts one to three weeks (this can vary based on the implementation language). At the end of that period, you have an integrated, tested system with more functionality than it had before. But what&#146;s particularly interesting is the basis for the iteration: a single use case. Each use case is a package of related functionality that you build into the system all at once, during one iteration. Not only does this give you a better idea of what the scope of a use case should be, but it also gives more validation to the idea of a use case, since the concept isn&#146;t discarded after analysis and design, but instead it is a fundamental unit of development throughout the software-building process. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_303" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2109"></a><a name="Index2110"></a>You stop iterating when you achieve target functionality or an external deadline arrives and the customer can be satisfied with the current version. (Remember, software is a subscription business.) Because the process is iterative, you have many opportunities to ship a product rather than having a single endpoint; open-source projects work exclusively in an iterative, high-feedback environment, which is precisely what makes them successful. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_304" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>An iterative development process is valuable for many reasons. You can reveal and resolve critical risks early, the customers have ample opportunity to change their minds, programmer satisfaction is higher, and the project can be steered with more precision. But an additional important benefit is the feedback to the stakeholders, who can see by the current state of the product exactly where everything lies. This may reduce or eliminate the need for mind-numbing status meetings and increase the confidence and support from the stakeholders. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_305" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc472654697"></a><a name="_Toc24775979"></a><a name="Heading24426"></a>Phase
5: Evolution</h2>
<p><a name="Index2111"></a>This is the point in the development cycle that has traditionally been called &#147;maintenance,&#148; a catch-all term that can mean everything from &#147;getting it to work the way it was really supposed to in the first place&#148; to &#147;adding features that the customer forgot to mention&#148; to the more traditional &#147;fixing the bugs that show up&#148; and &#147;adding new features as the need arises.&#148; So many misconceptions have been applied to the term &#147;maintenance&#148; that it has taken on a slightly deceiving quality, partly because it suggests that you&#146;ve actually built a pristine program and all you need to do is change parts, oil it, and keep it from rusting. Perhaps there&#146;s a better term to describe what&#146;s going on. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_306" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2112"></a><a name="Index2113"></a>I&#146;ll use the term <i>evolution.</i><sup><a name="fnB112" href="#fn112">[112]</a></sup> That is, &#147;You won&#146;t get it right the first time, so give yourself the latitude to learn and to go back and make changes.&#148; You might need to make a lot of changes as you learn and understand the problem more deeply. The elegance you&#146;ll produce if you evolve until you get it right will pay off, both in the short and the long term. Evolution is where your program goes from good to great, and where those issues that you didn&#146;t really understand in the first pass become clear. It&#146;s also where your classes can evolve from single-project usage to reusable resources. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_307" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>What it means to &#147;get it right&#148; isn&#146;t just that the program works according to the requirements and the use cases. It also means that the internal structure of the code makes sense to you, and feels like it fits together well, with no awkward syntax, oversized objects, or ungainly exposed bits of code. In addition, you must have some sense that the program structure will survive the changes that it will inevitably go through during its lifetime, and that those changes can be made easily and cleanly. This is no small feat. You must not only understand what you&#146;re building, but also how the program will evolve (what I call the <a name="Index2116"></a><i>vector of change</i>). Fortunately, object-oriented programming languages are particularly adept at supporting this kind of continuing modification&#151;the boundaries created by the objects are what tend to keep the structure from breaking down. They also allow you to make changes&#151;ones that would seem drastic in a procedural program&#151;without causing earthquakes throughout your code. In fact, support for evolution might be the most important benefit of OOP. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_308" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>With evolution, you create something that at least approximates what you think you&#146;re building, and then you kick the tires, compare it to your requirements, and see where it falls short. Then you can go back and fix it by redesigning and reimplementing the portions of the program that didn&#146;t work right.<sup><a name="fnB113" href="#fn113">[113]</a></sup> You might actually need to solve the problem, or an aspect of the problem, several times before you hit on the right solution. (A study of <a name="Index2119"></a><a name="Index2120"></a><i>Design Patterns </i>is usually helpful here. You can find information in <i>Thinking in Patterns (with Java)</i> at <i>www.BruceEckel.com</i>.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_309" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Evolution also occurs when you build a system, see that it matches your requirements, and then discover it wasn&#146;t actually what you wanted. When you see the system in operation, you may find that you really wanted to solve a different problem. If you think this kind of evolution is going to happen, then you owe it to yourself to build your first version as quickly as possible so you can find out if it is indeed what you want. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_310" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Perhaps the most important thing to remember is that by default&#151;by definition, really&#151;if you modify a class, its super- and subclasses will still function. You need not fear modification (especially if you have a built-in set of unit tests to verify the correctness of your modifications). Modification won&#146;t necessarily break the program, and any change in the outcome will be limited to subclasses and/or specific collaborators of the class you change. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_311" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc408018415"></a><a name="_Toc472654698"></a><a name="_Toc24775980"></a><a name="Heading24435"></a>Plans
pay off</h2>
<p>Of course you wouldn&#146;t build a house without a lot of carefully drawn plans. If you build a deck or a dog house your plans won&#146;t be so elaborate, but you&#146;ll probably still start with some kind of sketches to guide you on your way. Software development has gone to extremes. For a long time, people didn&#146;t have much structure in their development, but then big projects began failing. In reaction, we ended up with methodologies that had an intimidating amount of structure and detail, primarily intended for those big projects. These methodologies were too scary to use&#151;it looked like you&#146;d spend all your time writing documents and no time programming. (This was often the case.) I hope that what I&#146;ve shown you here suggests a middle path&#151;a sliding scale. Use an approach that fits your needs (and your personality). No matter how minimal you choose to make it, <i>some</i> kind of plan will make a big improvement in your project, as opposed to no plan at all. Remember that, by most estimates, over 50 percent of projects fail (some estimates go up to 70 percent!). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_312" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="_Toc312373783"></a>By following a plan&#151;preferably one that is simple and brief&#151;and coming up with design structure before coding, you&#146;ll discover that things fall together far more easily than if you dive in and start hacking. You&#146;ll also realize a great deal of satisfaction. It&#146;s my experience that coming up with an elegant solution is deeply satisfying at an entirely different level; it feels closer to art than technology. And elegance always pays off; it&#146;s not a frivolous pursuit. Not only does it give you a program that&#146;s easier to build and debug, but it&#146;s also easier to understand and maintain, and that&#146;s where the financial value lies. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_313" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="Index2121"></a><a name="_Toc472654699"></a><a name="_Toc24775981"></a><a name="Heading24438"></a>Extreme
Programming</h2>
<p>I have studied analysis and design techniques, on and off, since I was in graduate school. The concept of <a name="Index2122"></a><a name="Index2123"></a><a name="Index2124"></a><i>Extreme Programming</i> (XP) is the most radical, and delightful, that I&#146;ve seen. You can find it chronicled in <i>Extreme Programming Explained</i> by Kent Beck (Addison-Wesley, 2000) and on the Web at <i>www.xprogramming.com</i>. Addison-Wesley also seems to come out with a new book in the XP series every month or two; the goal seems to be to convince everyone to convert using sheer weight of books (generally, however, these books are small and pleasant to read). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_314" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>XP is both a philosophy about programming work and a set of guidelines to do it. Some of these guidelines are reflected in other recent methodologies, but the two most important and distinct contributions, in my opinion, are &#147;write tests first&#148; and &#147;pair programming.&#148; Although he argues strongly for the whole process, Beck points out that if you adopt only these two practices you&#146;ll greatly improve your productivity and reliability. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_315" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc472654700"></a><a name="_Toc24775982"></a><a name="Heading24441"></a>Write
tests first<br></h3>
<p><a name="Index2125"></a>Testing has traditionally been relegated to the last part of a project, after you&#146;ve &#147;gotten everything working, but just to be sure.&#148; It has implicitly had a low priority, and people who specialize in it have not been given a lot of status and have often even been cordoned off in a basement, away from the &#147;real programmers.&#148; Test teams have responded in kind, going so far as to wear black clothing and cackling with glee whenever they break something (to be honest, I&#146;ve had this feeling myself when breaking compilers). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_316" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>XP completely revolutionizes the concept of testing by giving it equal (or even greater) priority than the code. In fact, you write the tests <i>before</i> you write the code that will be tested, and the tests stay with the code forever. The tests must be executed successfully every time you do a build of the project (which is often, sometimes more than once a day). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_317" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Writing tests first has two extremely important effects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_318" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>First, it forces a clear definition of the interface of a class. I&#146;ve often suggested that people &#147;imagine the perfect class to solve a particular problem&#148; as a tool when trying to design the system. The XP testing strategy goes further than that&#151;it specifies exactly what the class must look like, to the consumer of that class, and exactly how the class must behave. In no uncertain terms. You can write all the prose, or create all the diagrams you want, describing how a class should behave and what it looks like, but nothing is as real as a set of tests. The former is a wish list, but the tests are a contract that is enforced by the compiler and the test framework. It&#146;s hard to imagine a more concrete description of a class than the tests. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_319" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2126"></a><a name="Index2127"></a>While creating the tests, you are forced to completely think out the class and will often discover needed functionality that might be missed during the thought experiments of UML diagrams, CRC cards, use cases, etc. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_320" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index2128"></a>The second important effect of writing the tests first comes from running the tests every time you do a build of your software. This activity gives you the other half of the testing that&#146;s performed by the compiler. If you look at the evolution of programming languages from this perspective, you&#146;ll see that the real improvements in the technology have actually revolved around testing. Assembly language checked only for syntax, but C imposed some semantic restrictions, and these prevented you from making certain types of mistakes. OOP languages impose even more semantic restrictions, which if you think about it are actually forms of testing. &#147;Is this data type being used properly?&#148; and &#147;Is this method being called properly?&#148; are the kinds of tests that are being performed by the compiler or run-time system. We&#146;ve seen the results of having these tests built into the language: People have been able to write more complex systems, and get them to work, with much less time and effort. I&#146;ve puzzled over why this is, but now I realize it&#146;s the tests: You do something wrong, and the safety net of the built-in tests tells you there&#146;s a problem and points you to where it is. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_321" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>But the built-in testing afforded by the design of the language can only go so far. At some point, <i>you</i> must step in and add the rest of the tests that produce a full suite (in cooperation with the compiler and run-time system) that verifies all of your program. And, just like having a compiler watching over your shoulder, wouldn&#146;t you want these tests helping you right from the beginning? That&#146;s why you write them first, and run them automatically with every build of your system. Your tests become an extension of the safety net provided by the language. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_322" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One of the things that I&#146;ve discovered about the use of more and more powerful programming languages is that I am emboldened to try more brazen experiments, because I know that the language will keep me from wasting my time chasing bugs. The XP test scheme does the same thing for your entire project. Because you know your tests will always catch any problems that you introduce (and you regularly add any new tests as you think of them), you can make big changes when you need to without worrying that you&#146;ll throw the whole project into complete disarray. This is incredibly powerful. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_323" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In this third edition of this book, I realized that testing was so important that it must also be applied to the examples in the book itself. With the help of the Crested Butte Summer 2002 Interns, we developed the testing system that you will see used throughout this book. The code and description is in Chapter 15. This system has increased the robustness of the code examples in this book immeasurably. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0443" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p class="heading 3,H3"><br></p>
<h3>
<a name="Index2129"></a><a name="Index2130"></a><a name="_Toc472654701"></a><a name="_Toc24775983"></a><a name="Heading24451"></a>Pair
programming</h3>
<p>Pair programming goes against the rugged individualism that we&#146;ve been indoctrinated into from the beginning, through school (where we succeed or fail on our own, and working with our neighbors is considered &#147;cheating&#148;), and media, especially Hollywood movies in which the hero is usually fighting against mindless conformity.<sup><a name="fnB114" href="#fn114">[114]</a></sup> Programmers, too, are considered paragons of individuality&#151;&#147;cowboy coders,&#148; as Larry Constantine likes to say. And yet XP, which is itself battling against conventional thinking, says that code should be written with two people per workstation. And that this should be done in an area with a group of workstations, without the barriers that the facilities-design people are so fond of. In fact, Beck says that the first task of converting to XP is to arrive with screwdrivers and Allen wrenches and take apart everything that gets in the way.<sup><a name="fnB115" href="#fn115">[115]</a></sup> (This will require a manager who can deflect the ire of the facilities department.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_324" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The value of pair programming is that one person is actually doing the coding while the other is thinking about it. The thinker keeps the big picture in mind&#151;not only the picture of the problem at hand, but the guidelines of XP. If two people are working, it&#146;s less likely that one of them will get away with saying, &#147;I don&#146;t want to write the tests first,&#148; for example. And if the coder gets stuck, they can swap places. If both of them get stuck, their musings may be overheard by someone else in the work area who can contribute. Working in pairs keeps things flowing and on track. Probably more important, it makes programming a lot more social and fun. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_325" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>I&#146;ve begun using pair programming during the exercise periods in some of my seminars, and it seems to significantly improve everyone&#146;s experience. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_326" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc312373815"></a><a name="_Toc472654711"></a><a name="_Toc24775984"></a><a name="Heading24457"></a>Strategies
for transition<br></h2>
<p><a name="Index2131"></a>If you buy into OOP, your next question is probably, &#147;How can I get my manager/colleagues/department/peers to start using objects?&#148; Think about how you&#151;one independent programmer&#151;would go about learning to use a new language and a new programming paradigm. You&#146;ve done it before. First comes education and examples; then comes a trial project to give you a feel for the basics without doing anything too confusing. Then comes a &#147;real world&#148; project that actually does something useful. Throughout your first projects you continue your education by reading, asking questions of experts, and trading hints with friends. This is the approach many experienced programmers suggest for the switch to Java. Switching an entire company will of course introduce certain group dynamics, but it will help at each step to remember how one person would do it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_334" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc472654712"></a><a name="_Toc24775985"></a><a name="Heading24459"></a>Guidelines</h3>
<p>Here are some guidelines to consider when making the transition to OOP and Java: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_335" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading24461"></a>1. Training</h4>
<p><a name="Index2132"></a>The first step is some form of education. Remember the company&#146;s investment in code, and try not to throw everything into disarray for six to nine months while everyone puzzles over unfamiliar features. Pick a small group for indoctrination, preferably one composed of people who are curious, work well together, and can function as their own support network while they&#146;re learning Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0106" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>An alternative approach is the education of all company levels at once, including overview courses for strategic managers as well as design and programming courses for project builders. This is especially good for smaller companies making fundamental shifts in the way they do things, or at the division level of larger companies. Because the cost is higher, however, some may choose to start with project-level training, do a pilot project (possibly with an outside mentor), and let the project team become the teachers for the rest of the company. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_336" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading24464"></a>2. Low-risk project</h4>
<p>Try a low-risk project first and allow for mistakes. Once you&#146;ve gained some experience, you can either seed other projects from members of this first team or use the team members as an OOP technical support staff. This first project may not work right the first time, so it should not be mission-critical for the company. It should be simple, self-contained, and instructive; this means that it should involve creating classes that will be meaningful to the other programmers in the company when they get their turn to learn Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_337" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading24466"></a>3. Model from success</h4>
<p>Seek out examples of good object-oriented design before starting from scratch. There&#146;s a good probability that someone has solved your problem already, and if they haven&#146;t solved it exactly you can probably apply what you&#146;ve learned about abstraction to modify an existing design to fit your needs. This is the general concept of <i>design patterns, </i>covered in <i>Thinking in Patterns (with Java)</i> at <i>www.BruceEckel.com</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_338" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Index2133"></a><a name="Index2134"></a><a name="Heading24468"></a>4.
Use existing class libraries</h4>
<p><a name="Index2135"></a>An important economic motivation for switching to OOP is the easy use of existing code in the form of class libraries (in particular, the Standard Java libraries, which are covered throughout this book). The shortest application development cycle will result when you can create and use objects from off-the-shelf libraries. However, some new programmers don&#146;t understand this, are unaware of existing class libraries, or, through fascination with the language, desire to write classes that may already exist. Your success with OOP and Java will be optimized if you make an effort to seek out and reuse other people&#146;s code early in the transition process. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_339" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading24470"></a>5. Don&#146;t rewrite existing code in Java</h4>
<p>It is not usually the best use of your time to take existing, functional code and rewrite it in Java. If you must turn it into objects, you can interface to the C or C++ code using the Java Native Interface or <i>Extensible Markup Language </i>(XML). There are incremental benefits, especially if the code is slated for reuse. But chances are you aren&#146;t going to see the dramatic increases in productivity that you hope for in your first few projects unless that project is a new one. Java and OOP shine best when taking a project from concept to reality. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_340" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p class="heading 3,H3"><br></p>
<h3>
<a name="_Toc312373817"></a><a name="Index2136"></a><a name="Index2137"></a><a name="_Toc472654713"></a><a name="_Toc24775986"></a><a name="Heading24472"></a>Management
obstacles</h3>
<p>If you&#146;re a manager, your job is to acquire resources for your team, to overcome barriers to your team&#146;s success, and in general to try to provide the most productive and enjoyable environment so your team is most likely to perform those miracles that are always being asked of you. Moving to Java falls in all three of these categories, and it would be wonderful if it didn&#146;t cost you anything as well. Although moving to Java may be cheaper&#151;depending on your constraints&#151;than the OOP alternatives for a team of C programmers (and probably for programmers in other procedural languages), it isn&#146;t free, and there are obstacles you should be aware of before trying to sell the move to Java within your company and embarking on the move itself. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_341" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p class="heading 4,H4"><br></p>
<h4>
<a name="Index2138"></a><a name="Index2139"></a><a name="Heading24474"></a>Startup
costs</h4>
<p>The cost of moving to Java is more than just the acquisition of Java compilers (the Sun Java compiler is free, so this is hardly an obstacle). Your medium- and long-term costs will be minimized if you invest in training (and possibly mentoring for your first project) and also if you identify and purchase class libraries that solve your problem rather than trying to build those libraries yourself. These are hard-money costs that must be factored into a realistic proposal. In addition, there are the hidden costs in loss of productivity while learning a new language and possibly a new programming environment. Training and mentoring can certainly minimize these, but team members must overcome their own struggles to understand the new technology. During this process they will make more mistakes (this is a feature, because acknowledged mistakes are the fastest path to learning) and be less productive. Even then, with some types of programming problems, the right classes, and the right development environment, it&#146;s possible to be more productive while you&#146;re learning Java (even considering that you&#146;re making more mistakes and writing fewer lines of code per day) than if you&#146;d stayed with C. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_342" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Index2140"></a><a name="Index2141"></a><a name="Heading24476"></a>Performance
issues<br></h4>
<p><a name="Index2142"></a>A common question is, &#147;Doesn&#146;t OOP automatically make my programs a lot bigger and slower?&#148; The answer is, &#147;It depends.&#148; The extra safety features in Java have traditionally extracted a performance penalty over a language like C++. Technologies such as &#147;hotspot&#148; and compilation technologies have improved the speed significantly in most cases, and efforts continue toward higher performance. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_343" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When your focus is on rapid prototyping, you can throw together components as fast as possible while ignoring efficiency issues. If you&#146;re using any third-party libraries, these are usually already optimized by their vendors; in any case it&#146;s not an issue while you&#146;re in rapid-development mode. When you have a system that you like, if it&#146;s small and fast enough, then you&#146;re done. If not, you begin tuning with a profiler, looking first for speedups that can be done by rewriting small portions of code. If that doesn&#146;t help, you look for modifications that can be made in the underlying implementation so no code that uses a particular class needs to be changed. Only if nothing else solves the problem do you need to change the design. If performance is so critical in that portion of the design, it must be part of the primary design criteria. You have the benefit of finding this out early using rapid development.<br></p>
<p>Chapter 15 introduces <i>profilers</i>, which can help you discover bottlenecks in your system so you can optimize that portion of your code (with the hotspot technologies, Sun no longer recommends using native methods for performance optimization). Optimization tools are also available. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_344" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading24480"></a>Common design errors</h4>
<p>When starting your team into OOP and Java, programmers will typically go through a series of common design errors. This often happens due to insufficient feedback from experts during the design and implementation of early projects, because no experts have been developed within the company, and because there may be resistance to retaining consultants. It&#146;s easy to feel that you understand OOP too early in the cycle and go off on a bad tangent. Something that&#146;s obvious to someone experienced with the language may be a subject of great internal debate for a novice. Much of this trauma can be skipped by using an experienced outside expert for training and mentoring. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_345" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="Index2143"></a><a name="Index2144"></a><a name="_Toc24775987"></a><a name="Heading24482"></a>Summary</h2>
<p>This chapter was only intended to give you concepts of OOP methodologies, and the kinds of issues you will encounter when moving your own company to OOP and Java. More about Object design can be learned at the MindView seminar &#147;Designing Objects and Systems&#148; (see &#147;Seminars&#148; at <i>www.MindView.net</i>).<br></p>
<hr><p class="footnote text"><sup><a name="fn102" href="#fnB102">[102]</a></sup> An excellent example of this is <i>UML Distilled</i>, 2<sup>nd</sup> edition, by <a name="Index2078"></a>Martin Fowler (Addison-Wesley 2000), which reduces the sometimes-overwhelming UML process to a manageable subset.<br></p>
<p class="footnote text"><sup><a name="fn103" href="#fnB103">[103]</a></sup> My rule of thumb for estimating such projects: If there&#146;s more than one wild card, don&#146;t even try to plan how long it&#146;s going to take or how much it will cost until you&#146;ve created a working prototype. There are too many degrees of freedom.<br></p>
<p class="footnote text"><sup><a name="fn104" href="#fnB104">[104]</a></sup> An excellent resource for requirements analysis is <i>Exploring Requirements: Quality Before Design</i>, by Gause &amp; Weinberg (Dorset House 1989).<br></p>
<p class="footnote text"><sup><a name="fn105" href="#fnB105">[105]</a></sup> Thanks for help from James H Jarrett.<br></p>
<p class="footnote text"><sup><a name="fn106" href="#fnB106">[106]</a></sup> More information on use cases can be found in <i>Use Case Driven Object Modeling with UML</i> by Rosenberg (Addison-Wesley 1999) . A good overview of user stories is found in <i>Planning Extreme Programming</i>, by Beck &amp; Fowler (Addison-Wesley 2001).<br></p>
<p class="footnote text"><sup><a name="fn107" href="#fnB107">[107]</a></sup> My personal take on this has changed lately. Doubling and adding 10 percent will give you a reasonably accurate estimate (assuming there are not too many wild-card factors), but you still have to work quite diligently to finish in that time. If you want time to really make it elegant and to enjoy yourself in the process, the correct multiplier is more like three or four times, I believe. See <i>PeopleWare</i>, by DeMarco &amp; Lister (Dorset House 1999) for studies of the effect of schedule estimates on productivity and a debunking of &#147;Parkinson&#146;s Law.&#148;<br></p>
<p class="footnote text"><sup><a name="fn108" href="#fnB108">[108]</a></sup> <i>Planning Extreme Programming </i>(ibid.) has some valuable insights on planning and time estimation.<br></p>
<p class="footnote text"><sup><a name="fn109" href="#fnB109">[109]</a></sup> For starters, I recommend the aforementioned <i>UML Distilled</i>, 2<sup>nd</sup> edition.<br></p>
<p class="footnote text"><sup><a name="fn110" href="#fnB110">[110]</a></sup> <a name="Index2101"></a>Python (www.Python.org) is often used as &#147;executable pseudocode.&#148;<br></p>
<p class="footnote text"><sup><a name="fn111" href="#fnB111">[111]</a></sup> &#147;What can be done with fewer ... is done in vain with more ... the mind should not multiply things without necessity.&#148; William of Ockham, 1290-1349.<br></p>
<p class="footnote text"><sup><a name="fn112" href="#fnB112">[112]</a></sup> At least one aspect of evolution is covered in <a name="Index2114"></a>Martin Fowler&#146;s book <a name="Index2115"></a><i>Refactoring: Improving the Design of Existing Code</i> (Addison-Wesley 1999), which uses Java examples exclusively.<br></p>
<p class="footnote text"><sup><a name="fn113" href="#fnB113">[113]</a></sup> This is something like &#147;<a name="Index2117"></a><a name="Index2118"></a>rapid prototyping,&#148; in which you were supposed to build a quick-and-dirty version so that you could learn about the system, and then throw away your prototype and build it right. The trouble with rapid prototyping is that people didn&#146;t throw away the prototype, but instead built upon it. Combined with the lack of structure in procedural programming, this often leads to messy systems that are expensive to maintain.<br></p>
<p class="footnote text"><sup><a name="fn114" href="#fnB114">[114]</a></sup> Although this may be a more American perspective, the stories of Hollywood reach everywhere.<br></p>
<p class="footnote text"><sup><a name="fn115" href="#fnB115">[115]</a></sup> Including (especially) the PA system. I once worked in a company that insisted on broadcasting every phone call that arrived for every executive, and it constantly interrupted our productivity (but the managers couldn&#146;t begin to conceive of stifling such an important service as the PA). Finally, when no one was looking I started snipping speaker wires.<br></p>

<!-- <hr><b>Placeholder</b> -->

<hr>

<div align="CENTER"><a href="TIJ317.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ319.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>

</font></body>

</html>

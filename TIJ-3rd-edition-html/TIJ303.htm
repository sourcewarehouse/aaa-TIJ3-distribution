<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en">
<!--
This document was converted from RTF source: 
By r2net 5.8 r2netcmd Windows 
See http://www.logictran.com
-->
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Thinking in Java, 3rd ed. Revision 4.0: 1: Introduction  to Objects</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css"></head>

<body >
   <CENTER>     <a href="http://www.MindView.net">     <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>     <Font FACE="Verdana, Tahoma, Arial, Helvetica, Sans">     <h2>Thinking in Java, 3<sup>rd</sup> ed. Revision 4.0</h2>     <FONT size = "-1"><br>     [ <a href="README.txt">Viewing Hints</a> ]     [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]     [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>     [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]     [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]     [ <a href="http://www.mindview.net/Services">Consulting</a> ] <br><br>     </FONT></FONT>   </CENTER> 
<font face="Georgia"><div align="CENTER"><a href="TIJ302.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ304.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>
<hr>

<h1>
<a name="_Toc375545187"></a><a name="_Toc24272640"></a><a name="_Toc24775512"></a><a name="Heading991"></a>1:
Introduction <br>to Objects</h1>
<p class="Intro">&#147;We cut nature up, organize it into concepts, and ascribe significances as we do, largely because we are parties to an agreement that holds throughout our speech community and is codified in the patterns of our language ... we cannot talk at all except by subscribing to the organization and classification of data which the agreement decrees.&#148; Benjamin Lee Whorf (1897-1941)<br></p>
<p>The genesis of the computer revolution was in a machine. The genesis of our programming languages thus tends to look like that machine.<br></p>
<p>But computers are not so much machines as they are mind amplification tools (&#147;bicycles for the mind,&#148; as Steve Jobs is fond of saying) and a different kind of expressive medium. As a result, the tools are beginning to look less like machines and more like parts of our minds, and also like other forms of expression such as writing, painting, sculpture, animation, and filmmaking. Object-oriented programming (OOP) is part of this movement toward using the computer as an expressive medium. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_103" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This chapter will introduce you to the basic concepts of OOP, including an overview of development methods. This chapter, and this book, assume that you have had experience in a procedural programming language, although not necessarily C. If you think you need more preparation in programming and the syntax of C before tackling this book, you should work through the <a name="Index24"></a><a name="Index25"></a><a name="Index26"></a><a name="Index27"></a><a name="Index28"></a><i>Foundations for Java</i> training CD ROM, bound in the back of this book. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_104" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This chapter is background and supplementary material. Many people do not feel comfortable wading into object-oriented programming without understanding the big picture first. Thus, there are many concepts that are introduced here to give you a solid overview of OOP. However, other people may not get the big picture concepts until they&#146;ve seen some of the mechanics first; these people may become bogged down and lost without some code to get their hands on. If you&#146;re part of this latter group and are eager to get to the specifics of the language, feel free to jump past this chapter&#151;skipping it at this point will not prevent you from writing programs or learning the language. However, you will want to come back here eventually to fill in your knowledge so you can understand why objects are important and how to design with them. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_105" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545188"></a><a name="_Toc408018385"></a><a name="_Toc472654682"></a><a name="_Toc24775513"></a><a name="Heading997"></a>The
progress of abstraction</h2>
<p>All programming languages provide abstractions. It can be argued that the complexity of the problems you&#146;re able to solve is directly related to the kind and quality of abstraction. By &#147;kind&#148; I mean, &#147;What is it that you are abstracting?&#148; Assembly language is a small abstraction of the underlying machine. Many so-called &#147;imperative&#148; languages that followed (such as FORTRAN, BASIC, and C) were abstractions of assembly language. These languages are big improvements over assembly language, but their primary abstraction still requires you to think in terms of the structure of the computer rather than the structure of the problem you are trying to solve. The programmer must establish the association between the machine model (in the &#147;solution space,&#148; which is the place where you&#146;re modeling that problem, such as a computer) and the model of the problem that is actually being solved (in the &#147;problem space,&#148; which is the place where the problem exists). The effort required to perform this mapping, and the fact that it is extrinsic to the programming language, produces programs that are difficult to write and expensive to maintain, and as a side effect created the entire &#147;programming methods&#148; industry. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_106" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index29"></a><a name="Index30"></a><a name="Index31"></a><a name="Index32"></a><a name="Index33"></a>The alternative to modeling the machine is to model the problem you&#146;re trying to solve. Early languages such as LISP and APL chose particular views of the world (&#147;All problems are ultimately lists&#148; or &#147;All problems are algorithmic,&#148; respectively). PROLOG casts all problems into chains of decisions. Languages have been created for constraint-based programming and for programming exclusively by manipulating graphical symbols. (The latter proved to be too restrictive.) Each of these approaches is a good solution to the particular class of problem they&#146;re designed to solve, but when you step outside of that domain they become awkward. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_107" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The object-oriented approach goes a step further by providing tools for the programmer to represent elements in the problem space. This representation is general enough that the programmer is not constrained to any particular type of problem. We refer to the elements in the problem space and their representations in the solution space as &#147;objects.&#148; (You will also need other objects that don&#146;t have problem-space analogs.) The idea is that the program is allowed to adapt itself to the lingo of the problem by adding new types of objects, so when you read the code describing the solution, you&#146;re reading words that also express the problem. This is a more flexible and powerful language abstraction than what we&#146;ve had before.<a name="Index34"></a><sup><a name="fnB2" href="#fn2">[2]</a></sup> Thus, OOP allows you to describe the problem in terms of the problem, rather than in terms of the computer where the solution will run. There&#146;s still a connection back to the computer: each object looks quite a bit like a little computer&#151;it has a state, and it has operations that you can ask it to perform. However, this doesn&#146;t seem like such a bad analogy to objects in the real world&#151;they all have characteristics and behaviors. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_108" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Alan Kay summarized five basic characteristics of Smalltalk, the first successful object-oriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_110" title="Send BackTalk Comment">Feedback</a></font><br></p>
<ol>
<li><a name="Index37"></a><a name="Index38"></a><a name="Index39"></a><a name="Index40"></a><a name="Index41"></a><a name="Index42"></a><b>Everything
is an object.</b> Think of an object as a fancy variable; it stores data, but
you can &#147;make requests&#148; to that object, asking it to perform
operations on itself. In theory, you can take any conceptual component in the
problem you&#146;re trying to solve (dogs, buildings, services, etc.) and
represent it as an object in your program. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_111" title="Send BackTalk
Comment">Feedback</a></font></li>
<li><b>A program is a bunch of objects telling each other what to do by sending
messages</b>. To make a request of an object, you &#147;send a message&#148;
to that object. More concretely, you can think of a message as a request to call
a method that belongs to a particular object. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_112" title="Send BackTalk
Comment">Feedback</a></font></li>
<li><b>Each object has its own memory made up of other objects</b>. Put another
way, you create a new kind of object by making a package containing existing
objects. Thus, you can build complexity into a program while hiding it behind
the simplicity of objects. <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_113" title="Send BackTalk
Comment">Feedback</a></font></li>
<li><b>Every object has a type</b>. Using the parlance, each object is an
<i>instance</i> of a <i>class</i>, in which &#147;class&#148; is synonymous
with &#147;type.&#148; The most important distinguishing characteristic of a
class is &#147;What messages can you send to it?&#148; <font size="-2"><a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_114" title="Send BackTalk
Comment">Feedback</a></font></li>
<li><b>All objects of a particular type can receive the same messages</b>. This
is actually a loaded statement, as you will see later. Because an object of type
&#147;circle&#148; is also an object of type &#147;shape,&#148; a circle is
guaranteed to accept shape messages. This means you can write code that talks to
shapes and automatically handle anything that fits the description of a shape.
This <i>substitutability</i> is one of the powerful concepts in OOP. <font
size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_115"
title="Send BackTalk
Comment">Feedback</a></font></li></ol><p><a name="_Toc375545189"></a><a name="_Toc408018386"></a><a name="_Toc472654683"></a>Booch offers an even more succinct description of an object:<br></p>
<p class="heading 7"><i>An object has state, behavior and identity.</i><br></p>
<p>This means that an object can have internal data (which gives it state), methods (to produce behavior), and each object can be uniquely distinguished from every other object&#151;to put this in a concrete sense, each object has a unique address in memory.<sup><a name="fnB3" href="#fn3">[3]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0105" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775514"></a><a name="Heading1012"></a>An object has an
interface<br></h2>
<p><a name="Index43"></a><a name="Index44"></a>Aristotle was probably the first to begin a careful study of the concept of <i>type;</i> he spoke of &#147;the class of fishes and the class of birds.&#148; The idea that all objects, while being unique, are also part of a class of objects that have characteristics and behaviors in common was used directly in the first object-oriented language, Simula-67, with its fundamental keyword <b>class</b> that introduces a new type into a program. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_116" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index45"></a><a name="Index46"></a>Simula, as its name implies, was created for developing simulations such as the classic &#147;bank teller problem.&#148; In this, you have a bunch of tellers, customers, accounts, transactions, and units of money&#151;a lot of &#147;objects.&#148; Objects that are identical except for their state during a program&#146;s execution are grouped together into &#147;classes of objects&#148; and that&#146;s where the keyword <a name="Index47"></a><b>class</b> came from. Creating abstract data types (classes) is a fundamental concept in object-oriented programming. Abstract data types work almost exactly like built-in types: You can create variables of a type (called <i>objects </i>or <i>instances</i> in object-oriented parlance) and manipulate those variables (called <a name="Index48"></a><a name="Index49"></a><i>sending messages</i> or <a name="Index50"></a><i>requests;</i> you send a message and the object figures out what to do with it). The members (elements) of each class share some commonality: every account has a balance, every teller can accept a deposit, etc. At the same time, each member has its own state: each account has a different balance, each teller has a name. Thus, the tellers, customers, accounts, transactions, etc., can each be represented with a unique entity in the computer program. This entity is the object, and each object belongs to a particular class that defines its characteristics and behaviors. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_117" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>So, although what we really do in object-oriented programming is create new data types, virtually all object-oriented programming languages use the &#147;class&#148; keyword. When you see the word &#147;type&#148; think &#147;class&#148; and vice versa.<sup><a name="fnB4" href="#fn4">[4]</a></sup> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_118" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Since a class describes a set of objects that have identical characteristics (data elements) and behaviors (functionality), a class is really a data type because a floating point number, for example, also has a set of characteristics and behaviors. The difference is that a programmer defines a class to fit a problem rather than being forced to use an existing data type that was designed to represent a unit of storage in a machine. You extend the programming language by adding new data types specific to your needs. The programming system welcomes the new classes and gives them all the care and type-checking that it gives to built-in types. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_119" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index51"></a><a name="Index52"></a>The object-oriented approach is not limited to building simulations. Whether or not you agree that any program is a simulation of the system you&#146;re designing, the use of OOP techniques can easily reduce a large set of problems to a simple solution. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_120" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Once a class is established, you can make as many objects of that class as you like, and then manipulate those objects as if they are the elements that exist in the problem you are trying to solve. Indeed, one of the challenges of object-oriented programming is to create a one-to-one mapping between the elements in the problem space and objects in the solution space. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_121" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>But how do you get an object to do useful work for you? There must be a way to make a request of the object so that it will do something, such as complete a transaction, draw something on the screen, or turn on a switch. And each object can satisfy only certain requests. The requests you can make of an object are defined by its <i>interface,</i> and the type is what determines the interface. A simple example might be a representation of a light bulb: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_122" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><img src="TIJ304.png" 	alt="TIJ304.png" border="0" ><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Light lt = <font color=#0000ff>new</font> Light();
lt.on();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>The interface establishes <i>what</i> requests you can make for a particular object. However, there must be code somewhere to satisfy that request. This, along with the hidden data, comprises the <a name="Index53"></a><i>implementation</i>. From a procedural programming standpoint, it&#146;s not that complicated. A type has a method associated with each possible request, and when you make a particular request to an object, that method is called. This process is usually summarized by saying that you &#147;send a message&#148; (make a request) to an object, and the object figures out what to do with that message (it executes code). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_123" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here, the name of the type/class is <b>Light</b>, the name of this particular <b>Light </b>object is <b>lt</b>,<b> </b>and the requests that you can make of a <b>Light</b> object are to turn it on, turn it off, make it brighter, or make it dimmer. You create a <b>Light </b>object by defining a &#147;reference&#148; (<b>lt</b>) for that object and calling <b>new</b> to request a new object of that type. To send a message to the object, you state the name of the object and connect it to the message request with a period (dot). From the standpoint of the user of a predefined class, that&#146;s pretty much all there is to programming with objects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_124" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The preceding diagram follows the format of the <a name="Index54"></a><a name="Index55"></a><i>Unified Modeling Language</i> (UML). Each class is represented by a box, with the type name in the top portion of the box, any data members that you care to describe in the middle portion of the box, and the <a name="Index56"></a><a name="Index57"></a><i>methods</i> (the functions that belong to this object, which receive any messages you send to that object) in the bottom portion of the box. Often, only the name of the class and the public methods are shown in UML design diagrams, so the middle portion is not shown. If you&#146;re interested only in the class name, then the bottom portion doesn&#146;t need to be shown, either. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_125" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545190"></a><a name="_Toc408018387"></a><a name="_Toc472654684"></a><a name="_Toc24775515"></a><a name="Heading1028"></a>An
object provides services</h2>
<p>While you&#146;re trying to develop or understand a program design, one of the best ways to think about objects is as &#147;service providers.&#148; Your program itself will provide services to the user, and it will accomplish this by using the services offered by other objects. Your goal is to produce (or even better, locate in existing code libraries) a set of objects that provide the ideal services to solve your problem. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0437" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A way to start doing this is to ask &#147;if I could magically pull them out of a hat, what objects would solve my problem right away?&#148; For example, suppose you are creating a bookkeeping program. You might imagine some objects that contain pre-defined bookkeeping input screens, another set of objects that perform bookkeeping calculations, and an object that handles printing of checks and invoices on all different kinds of printers. Maybe some of these objects already exist, and for the ones that don&#146;t, what would they look like? What services would <i>those</i> objects provide, and what objects would <i>they</i> need to fulfill their obligations? If you keep doing this, you will eventually reach a point where you can say either &#147;that object seems simple enough to sit down and write&#148; or &#147;I&#146;m sure that object must exist already.&#148; This is a reasonable way to decompose a problem into a set of objects. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0438" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Thinking of an object as a service provider has an additional benefit: it helps to improve the cohesiveness of the object. <i>High</i> <i>cohesion</i> is a fundamental quality of software design: It means that the various aspects of a software component (such as an object, although this could also apply to a method or a library of objects) &#147;fit together&#148; well. One problem people have when designing objects is cramming too much functionality into one object. For example, in your check printing module, you may decide you need an object that knows all about formatting and printing. You&#146;ll probably discover that this is too much for one object, and that what you need is three or more objects. One object might be a catalog of all the possible check layouts, which can be queried for information about how to print a check. One object or set of objects could be a generic printing interface that knows all about different kinds of printers (but nothing about bookkeeping&#151;this one is a candidate for buying rather than writing yourself). And a third object could use the services of the other two to accomplish the task. Thus, each object has a cohesive set of services it offers. In a good object-oriented design, each object does one thing well, but doesn&#146;t try to do too much. As seen here, this not only allows the discovery of objects that might be purchased (the printer interface object), but it also produces the possibility of an object that might be reused somewhere else (the catalog of check layouts). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0439" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Treating objects as service providers is a great simplifying tool, and it&#146;s very useful not only during the design process, but also when someone else is trying to understand your code or reuse an object&#151;if they can see the value of the object based on what service it provides, it makes it much easier to fit it into the design. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0440" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775516"></a><a name="Heading1033"></a>The hidden
implementation</h2>
<p>It is helpful to break up the playing field into <a name="Index58"></a><i>class creators</i> (those who create new data types) and <a name="Index59"></a><a name="Index60"></a><i>client programmers</i><sup><a name="fnB5" href="#fn5">[5]</a></sup> (the class consumers who use the data types in their applications). The goal of the client programmer is to collect a toolbox full of classes to use for rapid application development. The goal of the class creator is to build a class that exposes only what&#146;s necessary to the client programmer and keeps everything else hidden. Why? Because if it&#146;s hidden, the client programmer can&#146;t access it, which means that the class creator can change the hidden portion at will without worrying about the impact on anyone else. The hidden portion usually represents the tender insides of an object that could easily be corrupted by a careless or uninformed client programmer, so hiding the implementation reduces program bugs. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_126" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The concept of implementation hiding cannot be overemphasized. In any relationship it&#146;s important to have boundaries that are respected by all parties involved. When you create a library, you establish a relationship with the client<a name="Index62"></a><a name="Index63"></a><i> </i>programmer, who is also a programmer, but one who is putting together an application by using your library, possibly to build a bigger library. If all the members of a class are available to everyone, then the client programmer can do anything with that class and there&#146;s no way to enforce rules. Even though you might really prefer that the client programmer not directly manipulate some of the members of your class, without access control there&#146;s no way to prevent it. Everything&#146;s naked to the world. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_128" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>So the first reason for access control is to keep client programmers&#146; hands off portions they shouldn&#146;t touch&#151;parts that are necessary for the internal operation of the data type but not part of the interface that users need in order to solve their particular problems. This is actually a service to users because they can easily see what&#146;s important to them and what they can ignore. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_129" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The second reason for access control is to allow the library designer to change the internal workings of the class without worrying about how it will affect the client programmer. For example, you might implement a particular class in a simple fashion to ease development, and then later discover that you need to rewrite it in order to make it run faster. If the interface and implementation are clearly separated and protected, you can accomplish this easily. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_130" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index64"></a><a name="Index65"></a><a name="Index66"></a>Java uses three explicit keywords to set the boundaries in a class: <b>public</b>, <b>private</b>, and <b>protected</b>. Their use and meaning are quite straightforward. These <i>access specifiers</i> <a name="Index67"></a><a name="Index68"></a><a name="Index69"></a>determine who can use the definitions that follow. <b>public</b> <a name="Index70"></a>means the following element is available to everyone. The <b>private</b> <a name="Index71"></a>keyword, on the other hand, means that no one can access that element except you, the creator of the type, inside methods of that type. <b>private</b> is a brick wall between you and the client programmer. Someone who tries to access a <b>private</b> member will get a compile-time error. The <b>protected</b><a name="Index72"></a> keyword acts like <b>private</b>, with the exception that an inheriting class has access to <b>protected</b> members, but not <b>private</b> members. Inheritance will be introduced shortly. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_131" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Java also has a &#147;default&#148; access, which comes into play if you don&#146;t use one of the aforementioned specifiers. This is usually called <i>package</i> <i>access</i> because classes can access the members of other classes in the same package, but outside of the package those same members appear to be <b>private</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_132" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545191"></a><a name="_Toc408018388"></a><a name="_Toc472654685"></a><a name="_Toc24775517"></a><a name="Heading1041"></a>Reusing
the implementation</h2>
<p>Once a class has been created and tested, it should (ideally) represent a useful unit of code. It turns out that this reusability is not nearly so easy to achieve as many would hope; it takes experience and insight to produce a reusable object design. But once you have such a design, it begs to be reused. Code reuse is one of the greatest advantages that object-oriented programming languages provide. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_133" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index73"></a>The simplest way to reuse a class is to just use an object of that class directly, but you can also place an object of that class inside a new class. We call this &#147;creating a member object.&#148; Your new class can be made up of any number and type of other objects, in any combination that you need to achieve the functionality desired in your new class. Because you are composing a new class from existing classes, this concept is called <a name="Index74"></a><a name="Index75"></a><a name="Index76"></a><i>composition</i> (if the composition happens dynamically, it&#146;s usually called <a name="Index77"></a><i>aggregation</i>). Composition is often referred to as a &#147;has-a&#148; relationship, as in &#147;a car has an engine.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_134" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><a name="Index78"></a><img src="TIJ305.png" 	alt="TIJ305.png" border="0" ><br></p>
<p>(This UML diagram indicates composition with the filled diamond, which states there is one car. I will typically use a simpler form: just a line, without the diamond, to indicate an association.<a name="Index79"></a><sup><a name="fnB6" href="#fn6">[6]</a></sup>) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_135" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Composition comes with a great deal of flexibility. The member objects of your new class are typically private, making them inaccessible to the client programmers who are using the class. This allows you to change those members without disturbing existing client code. You can also change the member objects at run time, to dynamically change the behavior of your program. Inheritance, which is described next, does not have this flexibility since the compiler must place compile-time restrictions on classes created with inheritance. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_136" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Because inheritance is so important in object-oriented programming it is often highly emphasized, and the new programmer can get the idea that inheritance should be used everywhere. This can result in awkward and overly complicated designs. Instead, you should first look to composition when creating new classes, since it is simpler and more flexible. If you take this approach, your designs will be cleaner. Once you&#146;ve had some experience, it will be reasonably obvious when you need inheritance. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_137" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545192"></a><a name="_Toc408018389"></a><a name="_Toc472654686"></a><a name="_Toc24775518"></a><a name="Heading1049"></a>Inheritance:<br>reusing
the interface</h2>
<p>By itself, the idea of an object is a convenient tool. It allows you to package data and functionality together by <i>concept</i>, so you can represent an appropriate problem-space idea rather than being forced to use the idioms of the underlying machine. These concepts are expressed as fundamental units in the programming language by using the <a name="Index80"></a><b>class</b> keyword. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_138" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It seems a pity, however, to go to all the trouble to create a class and then be forced to create a brand new one that might have similar functionality. It&#146;s nicer if we can take the existing class, clone it, and then make additions and modifications to the clone. This is effectively what you get with <a name="Index81"></a><i>inheritance</i>, with the exception that if the original class (called the <i>base class</i> or <i>superclass </i>or <i>parent</i> <i>class</i>) is changed, the modified &#147;clone&#148; (called the <i>derived class </i>or <i>inherited class</i> or <i>subclass</i> or <i>child</i><b> </b><i>class</i>) also reflects those changes. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_139" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><img src="TIJ306.png" 	alt="TIJ306.png" border="0" ><br></p>
<p>(The arrow in this UML diagram points from the derived class to the base class. As you will see, there is commonly more than one derived class.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_140" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A type does more than describe the constraints on a set of objects; it also has a relationship with other types. Two types can have characteristics and behaviors in common, but one type may contain more characteristics than another and may also handle more messages (or handle them differently). Inheritance expresses this similarity between types by using the concept of base types and derived types. A base type contains all of the characteristics and behaviors that are shared among the types derived from it. You create a base type to represent the core of your ideas about some objects in your system. From the base type, you derive other types to express the different ways that this core can be realized. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_141" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index82"></a><a name="Index83"></a><a name="Index84"></a><a name="Index85"></a>For example, a trash-recycling machine sorts pieces of trash. The base type is &#147;trash,&#148; and each piece of trash has a weight, a value, and so on, and can be shredded, melted, or decomposed. From this, more specific types of trash are derived that may have additional characteristics (a bottle has a color) or behaviors (an aluminum can may be crushed, a steel can is magnetic). In addition, some behaviors may be different (the value of paper depends on its type and condition). Using inheritance, you can build a type hierarchy that expresses the problem you&#146;re trying to solve in terms of its types. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_142" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A second example is the classic &#147;shape&#148; example, perhaps used in a computer-aided design system or game simulation. The base type is &#147;shape,&#148; and each shape has a size, a color, a position, and so on. Each shape can be drawn, erased, moved, colored, etc. From this, specific types of shapes are derived (inherited)&#151;circle, square, triangle, and so on &#151; each of which may have additional characteristics and behaviors. Certain shapes can be flipped, for example. Some behaviors may be different, such as when you want to calculate the area of a shape. The type hierarchy embodies both the similarities and differences between the shapes. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_143" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><a name="Index86"></a><img src="TIJ307.png" 	alt="TIJ307.png" border="0" ><br></p>
<p>Casting the solution in the same terms as the problem is tremendously beneficial because you don&#146;t need a lot of intermediate models to get from a description of the problem to a description of the solution. With objects, the type hierarchy is the primary model, so you go directly from the description of the system in the real world to the description of the system in code. Indeed, one of the difficulties people have with object-oriented design is that it&#146;s too simple to get from the beginning to the end. A mind trained to look for complex solutions can initially be stumped by this simplicity. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_144" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When you inherit from an existing type, you create a new type. This new type contains not only all the members of the existing type (although the <b>private</b> ones are hidden away and inaccessible), but more importantly it duplicates the interface of the base class. That is, all the messages you can send to objects of the base class you can also send to objects of the derived class. Since we know the type of a class by the messages we can send to it, this means that the derived class <i>is the same type as the base class</i>. In the previous example, &#147;a circle is a shape.&#148; This type equivalence via inheritance is one of the fundamental gateways in understanding the meaning of object-oriented programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_145" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Since both the base class and derived class have the same fundamental interface, there must be some implementation to go along with that interface. That is, there must be some code to execute when an object receives a particular message. If you simply inherit a class and don&#146;t do anything else, the methods from the base-class interface come right along into the derived class. That means objects of the derived class have not only the same type, they also have the same behavior, which isn&#146;t particularly interesting. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_146" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You have two ways to differentiate your new derived class from the original base class. The first is quite straightforward: You simply add brand new methods to the derived class. These new methods are not part of the base class interface. This means that the base class simply didn&#146;t do as much as you wanted it to, so you added more methods. This simple and primitive use for inheritance is, at times, the perfect solution to your problem. However, you should look closely for the possibility that your base class might also need these additional methods. This process of discovery and iteration of your design happens regularly in object-oriented programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_147" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><a name="Index87"></a><a name="Index88"></a><img src="TIJ308.png" 	alt="TIJ308.png" border="0" ><br></p>
<p>Although inheritance may sometimes imply (especially in Java, where the keyword for inheritance is <b>extends</b>)<b> </b>that you are going to add new methods to the interface, that&#146;s not necessarily true. The second and more important way to differentiate your new class is to <i>change</i> the behavior of an existing base-class method. This is referred to as <a name="Index89"></a><a name="Index90"></a><i>overriding</i> that method. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_148" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><img src="TIJ309.png" 	alt="TIJ309.png" border="0" ><br></p>
<p>To override a method, you simply create a new definition for the method in the derived class. You&#146;re saying, &#147;I&#146;m using the same interface method here, but I want it to do something different for my new type.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_149" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545194"></a><a name="_Toc408018391"></a><a name="_Toc472654687"></a><a name="_Toc24775519"></a><a name="Heading1066"></a>Is-a
vs. is-like-a relationships<br></h3>
<p><a name="Index91"></a>There&#146;s a certain debate that can occur about inheritance: Should inheritance override <i>only</i> base-class methods (and not add new methods that aren&#146;t in the base class)? This would mean that the derived type is <i>exactly</i> the same type as the base class since it has exactly the same interface. As a result, you can exactly substitute an object of the derived class for an object of the base class. This can be thought of as <i>pure substitution</i><a name="Index92"></a>, and it&#146;s often referred to as the <a name="Index93"></a><i>substitution principle</i>. In a sense, this is the ideal way to treat inheritance. We often refer to the relationship between the base class and derived classes in this case as an <i>is-a</i> relationship, because you can say &#147;a circle <i>is a</i> shape.&#148; A test for inheritance is to determine whether you can state the is-a relationship about the classes and have it make sense. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_150" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There are times when you must add new interface elements to a derived type, thus extending the interface and creating a new type. The new type can still be substituted for the base type, but the substitution isn&#146;t perfect because your new methods are not accessible from the base type. This can be described as an <i>is-like-a</i> relationship (my term). The new type has the interface of the old type but it also contains other methods, so you can&#146;t really say it&#146;s exactly the same. For example, consider an air conditioner. Suppose your house is wired with all the controls for cooling; that is, it has an interface that allows you to control cooling. Imagine that the air conditioner breaks down and you replace it with a heat pump, which can both heat and cool. The heat pump <i>is-like-an</i> air conditioner, but it can do more. Because the control system of your house is designed only to control cooling, it is restricted to communication with the cooling part of the new object. The interface of the new object has been extended, and the existing system doesn&#146;t know about anything except the original interface. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_151" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><img src="TIJ310.png" 	alt="TIJ310.png" border="0" ><br></p>
<p>Of course, once you see this design it becomes clear that the base class &#147;cooling system&#148; is not general enough, and should be renamed to &#147;temperature control system&#148; so that it can also include heating&#151;at which point the substitution principle will work. However, this diagram is an example of what can happen with design in the real world. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_152" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When you see the substitution principle it&#146;s easy to feel like this approach (pure substitution) is the only way to do things, and in fact it <i>is</i> nice if your design works out that way. But you&#146;ll find that there are times when it&#146;s equally clear that you must add new methods to the interface of a derived class. With inspection both cases should be reasonably obvious. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_153" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545195"></a><a name="_Toc408018392"></a><a name="_Toc472654688"></a><a name="_Toc24775520"></a><a name="Heading1072"></a>Interchangeable
objects <br>with polymorphism<br></h2>
<p><a name="Index94"></a>When dealing with type hierarchies, you often want to treat an object not as the specific type that it is, but instead as its base type. This allows you to write code that doesn&#146;t depend on specific types. In the shape example, methods manipulate generic shapes without respect to whether they&#146;re circles, squares, triangles, or some shape that hasn&#146;t even been defined yet. All shapes can be drawn, erased, and moved, so these methods simply send a message to a shape object; they don&#146;t worry about how the object copes with the message. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_154" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Such code is unaffected by the addition of new types, and adding new types is the most common way to extend an object-oriented program to handle new situations. For example, you can derive a new subtype of shape called pentagon<i> </i>without modifying the methods that deal only with generic shapes. This ability to easily extend a design by deriving new subtypes is one of the essential ways to encapsulate change. This greatly improves designs while reducing the cost of software maintenance. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_155" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There&#146;s a problem, however, with attempting to treat derived-type objects as their generic base types (circles as shapes, bicycles as vehicles, cormorants as birds, etc.). If a method is going to tell a generic shape to draw itself, or a generic vehicle to steer, or a generic bird to move, the compiler cannot know at compile time precisely what piece of code will be executed. That&#146;s the whole point&#151;when the message is sent, the programmer doesn&#146;t <i>want</i> to know what piece of code will be executed; the draw method can be applied equally to a circle, a square, or a triangle, and the object will execute the proper code depending on its specific type. If you don&#146;t have to know what piece of code will be executed, then when you add a new subtype, the code it executes can be different without requiring changes to the method call. Therefore, the compiler cannot know precisely what piece of code is executed, so what does it do? For example, in the following diagram the <b>BirdController</b> object just works with generic <b>Bird</b> objects and does not know what exact type they are. This is convenient from <b>BirdController</b>&#146;s perspective because it doesn&#146;t have to write special code to determine the exact type of <b>Bird</b> it&#146;s working with or that <b>Bird</b>&#146;s behavior. So how does it happen that, when <b>move(&#160;)</b> is called while ignoring the specific type of <b>Bird</b>, the right behavior will occur (a <b>Goose </b>runs, flies, or swims, and a <b>Penguin</b> runs or swims)? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_156" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><img src="TIJ311.png" 	alt="TIJ311.png" border="0" ><br></p>
<p>The answer is the primary twist in object-oriented programming: the compiler cannot make a function call in the traditional sense. The function call generated by a non-OOP compiler causes what is called <a name="Index95"></a><a name="Index96"></a><i>early binding</i>, a term you may not have heard before because you&#146;ve never thought about it any other way. It means the compiler generates a call to a specific function name and the linker resolves this call to the absolute address of the code to be executed. In OOP, the program cannot determine the address of the code until run time, so some other scheme is necessary when a message is sent to a generic object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_157" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To solve the problem, object-oriented languages use the concept of <a name="Index97"></a><a name="Index98"></a><i>late binding</i>. When you send a message to an object, the code being called isn&#146;t determined until run time. The compiler does ensure that the method exists and performs type checking on the arguments and return value (a language in which this isn&#146;t true is called <a name="Index99"></a><a name="Index100"></a><i>weakly typed</i>), but it doesn&#146;t know the exact code to execute. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_158" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To perform late binding, Java uses a special bit of code in lieu of the absolute call. This code calculates the address of the method body, using information stored in the object (this process is covered in great detail in Chapter 7). Thus, each object can behave differently according to the contents of that special bit of code. When you send a message to an object, the object actually does figure out what to do with that message. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_159" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In some languages you must explicitly state that you want a method to have the flexibility of late-binding properties (C++ uses the <b>virtual</b> keyword to do this). In these languages, by default, methods are <i>not</i> dynamically bound. In Java, dynamic binding is the default behavior and you don&#146;t need to remember to add any extra keywords in order to get polymorphism. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_160" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Consider the shape example. The family of classes (all based on the same uniform interface) was diagrammed earlier in this chapter. To demonstrate polymorphism, we want to write a single piece of code that ignores the specific details of type and talks only to the base class. That code is <a name="Index101"></a><i>decoupled</i> from type-specific information and thus is simpler to write and easier to understand. And, if a new type&#151;a <b>Hexagon</b>, for example&#151;is added through inheritance, the code you write will work just as well for the new type of <b>Shape</b> as it did on the existing types. Thus, the program is <i>extensible</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_161" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you write a method in Java (as you will soon learn how to do): <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_162" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> doStuff(Shape s) {
  s.erase();
  <font color=#009900>// ...</font>
  s.draw();
}</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>This method speaks to any <b>Shape</b>, so it is independent of the specific type of object that it&#146;s drawing and erasing. If some other part of the program uses the <b>doStuff(&#160;)</b> method: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_163" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Circle c = <font color=#0000ff>new</font> Circle();
Triangle t = <font color=#0000ff>new</font> Triangle();
Line l = <font color=#0000ff>new</font> Line();
doStuff(c);
doStuff(t);
doStuff(l);</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>the calls to <b>doStuff(&#160;) </b>automatically work correctly, regardless of the exact type of the object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_164" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This is a rather amazing trick. Consider the line:<br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>doStuff(c);</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>What&#146;s happening here is that a <b>Circle</b> is being passed into a method that&#146;s expecting a <b>Shape</b>. Since a <b>Circle</b> <i>is</i> a <b>Shape</b> it can be treated as one by <b>doStuff(&#160;)</b>. That is, any message that <b>doStuff(&#160;)</b> can send to a <b>Shape</b>, a <b>Circle</b> can accept. So it is a completely safe and logical thing to do. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_165" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>We call this process of treating a derived type as though it were its base type <a name="Index102"></a><i>upcasting</i>. The name <a name="Index103"></a><i>cast </i>is used in the sense of casting into a mold and the <i>up</i> comes from the way the inheritance diagram is typically arranged, with the base type at the top and the derived classes fanning out downward. Thus, casting to a base type is moving up the inheritance diagram: &#147;upcasting.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_166" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p align="center"><a name="Index104"></a><a name="Index105"></a><img src="TIJ312.png" 	alt="TIJ312.png" border="0" ><br></p>
<p>An object-oriented program contains some upcasting somewhere, because that&#146;s how you decouple yourself from knowing about the exact type you&#146;re working with. Look at the code in <b>doStuff(&#160;)</b>: <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_167" title="Send BackTalk Comment">Feedback</a></font><br></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  s.erase();
  <font color=#009900>// ...</font>
  s.draw();</PRE></FONT></BLOCKQUOTE><p><br></p>
<p>Notice that it doesn&#146;t say &#147;If you&#146;re a <b>Circle</b>, do this, if you&#146;re a <b>Square</b>, do that, etc.&#148; If you write that kind of code, which checks for all the possible types that a <b>Shape</b> can actually be, it&#146;s messy and you need to change it every time you add a new kind of <b>Shape</b>. Here, you just say &#147;You&#146;re a shape, I know you can <b>erase(&#160;) </b>and <b>draw(&#160;) </b>yourself, do it, and take care of the details correctly.&#148; <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_168" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>What&#146;s impressive about the code in <b>doStuff(&#160;)</b> is that, somehow, the right thing happens. Calling <b>draw(&#160;)</b> for <b>Circle</b> causes different code to be executed than when calling <b>draw(&#160;) </b>for a <b>Square</b> or a <b>Line</b>, but when the <b>draw(&#160;)</b> message is sent to an anonymous <b>Shape</b>, the correct behavior occurs based on the actual type of the <b>Shape</b>. This is amazing because, as mentioned earlier, when the Java compiler is compiling the code for <b>doStuff(&#160;)</b>, it cannot know exactly what types it is dealing with. So ordinarily, you&#146;d expect it to end up calling the version of <b>erase(&#160;)</b> and <b>draw(&#160;) </b>for the base class <b>Shape</b>, and not for the specific <b>Circle</b>, <b>Square</b>, or <b>Line</b>. And yet the right thing happens because of polymorphism. The compiler and run-time system handle the details; all you need to know right now is that it does happen, and more importantly, how to design with it. When you send a message to an object, the object will do the right thing, even when upcasting is involved. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_169" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc375545197"></a><a name="_Toc473421287"></a><a name="_Toc24775521"></a><a name="Heading1111"></a>Abstract
base classes and interfaces</h3>
<p>Often in a design, you want the base class to present <i>only</i> an interface for its derived classes. That is, you don&#146;t want anyone to actually create an object of the base class, only to upcast to it so that its interface can be used. This is accomplished by making that class <i>abstract </i>by using the <b>abstract</b> keyword. If anyone tries to make an object of an <b>abstract</b> class, the compiler prevents it. This is a tool to enforce a particular design. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_170" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You can also use the <b>abstract</b> keyword to describe a method that hasn&#146;t been implemented yet&#151;as a stub indicating &#147;here is an interface method for all types inherited from this class, but at this point I don&#146;t have any implementation for it.&#148; An <b>abstract </b>method may be created only inside an <b>abstract </b>class. When the class is inherited, that method must be implemented, or the inheriting class becomes <b>abstract</b> as well. Creating an <b>abstract</b> method allows you to put a method in an interface without being forced to provide a possibly meaningless body of code for that method. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_171" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The <b>interface</b> keyword takes the concept of an <b>abstract</b> class one step further by preventing any method definitions at all. The <b>interface</b> is a very handy and commonly used tool, as it provides the perfect separation of interface and implementation. In addition, you can combine many interfaces together, if you wish, whereas inheriting from multiple regular classes or abstract classes is not possible. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_172" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545198"></a><a name="_Toc408018395"></a><a name="_Toc408018408"></a><a name="_Toc312373795"></a><a name="_Toc24775522"></a><a name="Heading1115"></a>Object
creation, use &amp; lifetimes</h2>
<p>Technically, OOP is just about abstract data typing, inheritance, and polymorphism, but other issues can be at least as important. This section will cover these issues. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_173" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One of the most important factors of objects is the way they are created and destroyed. Where is the data for an object and how is the lifetime of the object controlled? There are different philosophies at work here. C++ takes the approach that control of efficiency is the most important issue, so it gives the programmer a choice. For maximum run-time speed, the storage and lifetime can be determined while the program is being written, by placing the objects on the stack (these are sometimes called <i>automatic</i> or <i>scoped</i> variables) or in the static storage area. This places a priority on the speed of storage allocation and release, and control of these can be very valuable in some situations. However, you sacrifice flexibility because you must know the exact quantity, lifetime, and type of objects while you're writing the program. If you are trying to solve a more general problem such as computer-aided design, warehouse management, or air-traffic control, this is too restrictive. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_174" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The second approach is to create objects dynamically in a pool of memory called the heap. In this approach, you don't know until run time how many objects you need, what their lifetime is, or what their exact type is. Those are determined at the spur of the moment while the program is running. If you need a new object, you simply make it on the heap at the point that you need it. Because the storage is managed dynamically, at run time, the amount of time required to allocate storage on the heap can be noticeably longer than the time to create storage on the stack. (Creating storage on the stack is often a single assembly instruction to move the stack pointer down and another to move it back up. The time to create heap storage depends on the design of the storage mechanism.) The dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object. In addition, the greater flexibility is essential to solve the general programming problem. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_175" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Java uses the second approach, exclusively.<sup><a name="fnB7" href="#fn7">[7]</a></sup> Every time you want to create an object, you use the <b>new</b> keyword to build a dynamic instance of that object. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_176" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>There's another issue, however, and that's the lifetime of an object. With languages that allow objects to be created on the stack, the compiler determines how long the object lasts and can automatically destroy it. However, if you create it on the heap the compiler has no knowledge of its lifetime. In a language like C++, you must determine programmatically when to destroy the object, which can lead to memory leaks if you don&#146;t do it correctly (and this is a common problem in C++ programs). Java provides a feature called a <i>garbage collector</i> that automatically discovers when an object is no longer in use and destroys it. A garbage collector is much more convenient because it reduces the number of issues that you must track and the code you must write. More important, the garbage collector provides a much higher level of insurance against the insidious problem of memory leaks (which has brought many a C++ project to its knees). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_177" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775523"></a><a name="Heading1122"></a>Collections and
iterators</h3>
<p>If you don&#146;t know how many objects you&#146;re going to need to solve a particular problem, or how long they will last, you also don&#146;t know how to store those objects. How can you know how much space to create for those objects? You can&#146;t, since that information isn&#146;t known until run time. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_179" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The solution to most problems in object-oriented design seems flippant: You create another type of object. The new type of object that solves this particular problem holds references to other objects. Of course, you can do the same thing with an array, which is available in most languages. But this new object, generally called a <i>container</i> (also called a <i>collection</i>, but the Java library uses that term in a different sense so this book will use &#147;container&#148;), will expand itself whenever necessary to accommodate everything you place inside it. So you don&#146;t need to know how many objects you&#146;re going to hold in a container. Just create a container object and let it take care of the details. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_180" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Fortunately, a good OOP language comes with a set of containers as part of the package. In C++, it&#146;s part of the Standard C++ Library and is sometimes called the Standard Template Library (STL). Object Pascal has containers in its Visual Component Library (VCL). Smalltalk has a very complete set of containers. Java also has containers in its standard library. In some libraries, a generic container is considered good enough for all needs, and in others (Java, for example) the library has different types of containers for different needs: several different kinds of <b>List</b> classes (to hold sequences), <b>Map </b>classes (also known as <i>associative arrays</i>, to associate objects with other objects), and <b>Set</b> classes (to hold one of each type of object). Container libraries may also include queues, trees, stacks, etc. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_181" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>All containers have some way to put things in and get things out; there are usually methods to add elements to a container, and others to fetch those elements back out. But fetching elements can be more problematic, because a single-selection method is restrictive. What if you want to manipulate or compare a set of elements in the container instead of just one? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_182" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The solution is an <i>iterator</i>, which is an object whose job is to select the elements within a container and present them to the user of the iterator. As a class, it also provides a level of abstraction. This abstraction can be used to separate the details of the container from the code that&#146;s accessing that container. The container, via the iterator, is abstracted to be simply a sequence. The iterator allows you to traverse that sequence without worrying about the underlying structure&#151;that is, whether it&#146;s an <b>ArrayList</b>, a <b>LinkedList</b>, a <b>Stack</b>, or something else. This gives you the flexibility to easily change the underlying data structure without disturbing the code in your program. Java began (in version 1.0 and 1.1) with a standard iterator, called <b>Enumeration</b>, for all of its container classes. Java 2 added a much more complete container library that contains an iterator called <b>Iterator</b> that does more than the older <b>Enumeration</b>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_183" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>From a design standpoint, all you really want is a sequence that can be manipulated to solve your problem. If a single type of sequence satisfied all of your needs, there&#146;d be no reason to have different kinds. There are two reasons that you need a choice of containers. First, containers provide different types of interfaces and external behavior. A stack has a different interface and behavior than that of a queue, which is different from that of a set or a list. One of these might provide a more flexible solution to your problem than the other. Second, different containers have different efficiencies for certain operations. The best example compares two types of <b>List</b>:<b> </b>an <b>ArrayList</b> and a <b>LinkedList</b>. Both are simple sequences that can have identical interfaces and external behaviors. But certain operations can have radically different costs. Randomly accessing elements in an <b>ArrayList</b> is a constant-time operation; it takes the same amount of time regardless of the element you select. However, in a <b>LinkedList</b> it is expensive to move through the list to randomly select an element, and it takes longer to find an element that is farther down the list. On the other hand, if you want to insert an element in the middle of a sequence, it&#146;s cheaper in a <b>LinkedList </b>than in an <b>ArrayList</b>. These and other operations have different efficiencies depending on the underlying structure of the sequence. In the design phase, you might start with a <b>LinkedList</b> and, when tuning for performance, change to an <b>ArrayList</b>. Because of the abstraction via the base class <b>List </b>and via iterators, you can change from one to the other with minimal impact on your code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_184" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775524"></a><a name="Heading1129"></a>The singly rooted
hierarchy</h3>
<p>One of the issues in OOP that has become especially prominent since the introduction of C++ is whether all classes should ultimately be inherited from a single base class. In Java (as with virtually all other OOP languages <i>except</i> for C++) the answer is yes, and the name of this ultimate base class is simply <b>Object</b>. It turns out that the benefits of the singly rooted hierarchy are many. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_186" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>All objects in a singly rooted hierarchy have an interface in common, so they are all ultimately the same fundamental type. The alternative (provided by C++) is that you don&#146;t know that everything is the same basic type. From a backward-compatibility standpoint this fits the model of C better and can be thought of as less restrictive, but when you want to do full-on object-oriented programming you must then build your own hierarchy to provide the same convenience that&#146;s built into other OOP languages. And in any new class library you acquire, some other incompatible interface will be used. It requires effort (and possibly multiple inheritance) to work the new interface into your design. Is the extra &#147;flexibility&#148; of C++ worth it? If you need it&#151;if you have a large investment in C&#151;it&#146;s quite valuable. If you&#146;re starting from scratch, other alternatives such as Java can often be more productive. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_187" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>All objects in a singly rooted hierarchy (such as Java provides) can be guaranteed to have certain functionality. You know you can perform certain basic operations on every object in your system. A singly rooted hierarchy, along with creating all objects on the heap, greatly simplifies argument passing (one of the more complex topics in C++). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_188" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>A singly rooted hierarchy makes it much easier to implement a garbage collector (which is conveniently built into Java). The necessary support can be installed in the base class, and the garbage collector can thus send the appropriate messages to every object in the system. Without a singly rooted hierarchy and a system to manipulate an object via a reference, it is difficult to implement a garbage collector. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_189" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Since run time type information is guaranteed to be in all objects, you&#146;ll never end up with an object whose type you cannot determine. This is especially important with system-level operations, such as exception handling, and to allow greater flexibility in programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_190" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775525"></a><a name="Heading1135"></a>Downcasting vs.
templates/generics</h3>
<p>To make these containers reusable, they hold the one universal type in Java: <b>Object</b>. The singly rooted hierarchy means that everything is an <b>Object</b>, so a container that holds <b>Object</b>s can hold anything.<sup><a name="fnB8" href="#fn8">[8]</a></sup> This makes containers easy to reuse. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_192" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To use such a container, you simply add object references to it and later ask for them back. But, since the container holds only <b>Object</b>s, when you add your object reference into the container it is upcast to <b>Object</b>, thus losing its identity. When you fetch it back, you get an <b>Object</b> reference, and not a reference to the type that you put in. So how do you turn it back into something that has the useful interface of the object that you put into the container? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_193" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Here, the cast is used again, but this time you&#146;re not casting up the inheritance hierarchy to a more general type. Instead, you cast down the hierarchy to a more specific type. This manner of casting is called <i>downcasting</i>. With upcasting, you know, for example, that a <b>Circle</b> is a type of <b>Shape</b> so it&#146;s safe to upcast, but you don&#146;t know that an <b>Object</b> is necessarily a <b>Circle</b> or a <b>Shape</b> so it&#146;s hardly safe to downcast unless you know exactly what you&#146;re dealing with. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_194" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s not completely dangerous, however, because if you downcast to the wrong thing you&#146;ll get a run-time error called an <i>exception,</i> which will be described shortly. When you fetch object references from a container, though, you must have some way to remember exactly what they are so you can perform a proper downcast. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_195" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Downcasting and the run-time checks require extra time for the running program and extra effort from the programmer. Wouldn&#146;t it make sense to somehow create the container so that it knows the types that it holds, eliminating the need for the downcast and a possible mistake? The solution is called a <i>parameterized type </i>mechanism. A parameterized type is a class that the compiler can automatically customize to work with particular types. For example, with a parameterized container, the compiler could customize that container so that it would accept only <b>Shape</b>s and fetch only <b>Shape</b>s. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_196" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Parameterized types are an important part of C++, partly because C++ has no singly rooted hierarchy. In C++, the keyword that implements parameterized types is &#147;template.&#148; Java currently has no parameterized types since it is possible for it to get by&#151;however awkwardly&#151;using the singly rooted hierarchy. However, a current proposal for parameterized types uses a syntax that is strikingly similar to C++ templates, and we can expect to see parameterized types (which will be called <i>generics</i>) in the next version of Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_197" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775526"></a><a name="Heading1143"></a>Ensuring proper
cleanup</h3>
<p>Each object requires resources, most notably memory, in order to exist. When an object is no longer needed it must be cleaned up so that these resources are released for reuse. In simple programming situations the question of how an object is cleaned up doesn&#146;t seem too challenging: you create the object, use it for as long as it&#146;s needed, and then it should be destroyed. However, it&#146;s not hard to encounter situations that are more complex. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_198" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Suppose, for example, you are designing a system to manage air traffic for an airport. (The same model might also work for managing crates in a warehouse, or a video rental system, or a kennel for boarding pets.) At first it seems simple: Make a container to hold airplanes, then create a new airplane and place it in the container for each airplane that enters the air-traffic-control zone. For cleanup, simply delete the appropriate airplane object when a plane leaves the zone. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_199" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>But perhaps you have some other system to record data about the planes; perhaps data that doesn&#146;t require such immediate attention as the main controller function. Maybe it&#146;s a record of the flight plans of all the small planes that leave the airport. So you have a second container of small planes, and whenever you create a plane object you also put it in this second container if it&#146;s a small plane. Then some background process performs operations on the objects in this container during idle moments. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_200" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Now the problem is more difficult: How can you possibly know when to destroy the objects? When you&#146;re done with the object, some other part of the system might not be. This same problem can arise in a number of other situations, and in programming systems (such as C++) in which you must explicitly delete an object when you&#146;re done with it this can become quite complex. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_201" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>With Java, the garbage collector is designed to take care of the problem of releasing the memory (although this doesn&#146;t include other aspects of cleaning up an object). The garbage collector &#147;knows&#148; when an object is no longer in use, and it then automatically releases the memory for that object. This (combined with the fact that all objects are inherited from the single root class <b>Object</b> and that you can create objects only one way&#151;on the heap) makes the process of programming in Java much simpler than programming in C++. You have far fewer decisions to make and hurdles to overcome. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_202" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading1149"></a>Garbage collectors vs. efficiency and flexibility</h4>
<p>If all this is such a good idea, why didn&#146;t they do the same thing in C++? Well of course there&#146;s a price you pay for all this programming convenience, and that price is run time overhead. As mentioned before, in C++ you can create objects on the stack, and in this case they&#146;re automatically cleaned up (but you don&#146;t have the flexibility of creating as many as you want at run time). Creating objects on the stack is the most efficient way to allocate storage for objects and to free that storage. Creating objects on the heap can be much more expensive. Always inheriting from a base class and making all method calls polymorphic also exacts a small toll. But the garbage collector is a particular problem because you never quite know when it&#146;s going to start up or how long it will take. This means that there&#146;s an inconsistency in the rate of execution of a Java program, so you can&#146;t use it in certain situations, such as when the rate of execution of a program is uniformly critical. (These are generally called real time programs, although not all real time programming problems are this stringent.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_203" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The designers of the C++ language, trying to woo C programmers (and most successfully, at that), did not want to add any features to the language that would impact the speed or the use of C++ in any situation where programmers might otherwise choose C. This goal was realized, but at the price of greater complexity when programming in C++. Java is simpler than C++, but the trade-off is in efficiency and sometimes applicability. For a significant portion of programming problems, however, Java is the superior choice. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_204" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775527"></a><a name="Heading1152"></a>Exception handling: dealing
with errors</h2>
<p>Ever since the beginning of programming languages, error handling has been one of the most difficult issues. Because it&#146;s so hard to design a good error handling scheme, many languages simply ignore the issue, passing the problem on to library designers who come up with halfway measures that work in many situations but that can easily be circumvented, generally by just ignoring them. A major problem with most error handling schemes is that they rely on programmer vigilance in following an agreed-upon convention that is not enforced by the language. If the programmer is not vigilant&#151;often the case if they are in a hurry&#151;these schemes can easily be forgotten. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_205" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Exception handling wires error handling directly into the programming language and sometimes even the operating system. An exception is an object that is &#147;thrown&#148; from the site of the error and can be &#147;caught&#148; by an appropriate exception handler designed to handle that particular type of error. It&#146;s as if exception handling is a different, parallel path of execution that can be taken when things go wrong. And because it uses a separate execution path, it doesn&#146;t need to interfere with your normally executing code. This makes that code simpler to write because you aren&#146;t constantly forced to check for errors. In addition, a thrown exception is unlike an error value that&#146;s returned from a method or a flag that&#146;s set by a method in order to indicate an error condition&#151;these can be ignored. An exception cannot be ignored, so it&#146;s guaranteed to be dealt with at some point. Finally, exceptions provide a way to reliably recover from a bad situation. Instead of just exiting the program, you are often able to set things right and restore execution, which produces much more robust programs. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_206" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Java&#146;s exception handling stands out among programming languages, because in Java, exception handling was wired in from the beginning and you&#146;re forced to use it. If you don&#146;t write your code to properly handle exceptions, you&#146;ll get a compile-time error message. This guaranteed consistency can sometimes make error handling much easier. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_207" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>It&#146;s worth noting that exception handling isn&#146;t an object-oriented feature, although in object-oriented languages the exception is normally represented by an object. Exception handling existed before object-oriented languages. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_208" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775528"></a><a name="Heading1157"></a>Concurrency</h2>
<p>A fundamental concept in computer programming is the idea of handling more than one task at a time. Many programming problems require that the program be able to stop what it&#146;s doing, deal with some other problem, and then return to the main process. The solution has been approached in many ways. Initially, programmers with low-level knowledge of the machine wrote interrupt service routines, and the suspension of the main process was initiated through a hardware interrupt. Although this worked well, it was difficult and nonportable, so it made moving a program to a new type of machine slow and expensive. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_209" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Sometimes, interrupts are necessary for handling time-critical tasks, but there&#146;s a large class of problems in which you&#146;re simply trying to partition the problem into separately running pieces so that the whole program can be more responsive. Within a program, these separately running pieces are called threads, and the general concept is called <i>concurrency </i>or <i>multithreading.</i> A common example of multithreading is the user interface. By using threads, a user can press a button and get a quick response rather than being forced to wait until the program finishes its current task. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_210" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Ordinarily, threads are just a way to allocate the time of a single processor. But if the operating system supports multiple processors, each thread can be assigned to a different processor, and they can truly run in parallel. One of the convenient features of multithreading at the language level is that the programmer doesn&#146;t need to worry about whether there are many processors or just one. The program is logically divided into threads and if the machine has more than one processor, then the program runs faster, without any special adjustments. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_211" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>All this makes threading sound pretty simple. There is a catch: shared resources. If you have more than one thread running that&#146;s expecting to access the same resource, you have a problem. For example, two processes can&#146;t simultaneously send information to a printer. To solve the problem, resources that can be shared, such as the printer, must be locked while they are being used. So a thread locks a resource, completes its task, and then releases the lock so that someone else can use the resource. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_212" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Java&#146;s threading is built into the language, which makes a complicated subject much simpler. The threading is supported on an object level, so one thread of execution is represented by one object. Java also provides limited resource locking. It can lock the memory of any object (which is, after all, one kind of shared resource) so that only one thread can use it at a time. This is accomplished with the <a name="Index106"></a><b>synchronized</b> keyword. Other types of resources must be locked explicitly by the programmer, typically by creating an object to represent the lock that all threads must check before accessing that resource. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_213" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775529"></a><a name="Heading1163"></a>Persistence</h2>
<p>When you create an object, it exists for as long as you need it, but under no circumstances does it exist when the program terminates. While this makes sense at first, there are situations in which it would be incredibly useful if an object could exist and hold its information even while the program wasn&#146;t running. Then the next time you started the program, the object would be there and it would have the same information it had the previous time the program was running. Of course, you can get a similar effect by writing the information to a file or to a database, but in the spirit of making everything an object, it would be quite convenient to be able to declare an object persistent and have all the details taken care of for you. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_214" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Java provides support for &#147;lightweight persistence,&#148; which means that you can easily store objects on disk and later retrieve them. The reason it&#146;s &#147;lightweight&#148; is that you&#146;re still forced to make explicit calls to do the storage and retrieval. Lightweight persistence can be implemented both through <i>object serialization</i> (shown in Chapter 12) and <i>Java Data Objects</i> (JDO, shown in <i>Thinking in Enterprise Java</i>). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_215" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc24775530"></a><a name="Heading1166"></a>Java and the Internet</h2>
<p>If Java is, in fact, yet another computer programming language, you may question why it is so important and why it is being promoted as a revolutionary step in computer programming. The answer isn&#146;t immediately obvious if you&#146;re coming from a traditional programming perspective. Although Java is very useful for solving traditional standalone programming problems, it is also important because it will solve programming problems on the World Wide Web. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_216" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775531"></a><a name="Heading1168"></a>What is the Web?</h3>
<p>The Web can seem a bit of a mystery at first, with all this talk of &#147;surfing,&#148; &#147;presence,&#148; and &#147;home pages.&#148; It&#146;s helpful to step back and see what it really is, but to do this you must understand client/server systems, another aspect of computing that&#146;s full of confusing issues. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_217" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading1170"></a>Client/Server computing</h4>
<p>The primary idea of a client/server system is that you have a central repository of information&#151;some kind of data, often in a database&#151;that you want to distribute on demand to some set of people or machines. A key to the client/server concept is that the repository of information is centrally located so that it can be changed and so that those changes will propagate out to the information consumers. Taken together, the information repository, the software that distributes the information, and the machine(s) where the information and software reside is called the server. The software that resides on the remote machine, communicates with the server, fetches the information, processes it, and then displays it on the remote machine is called the <i>client.</i> <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_218" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The basic concept of client/server computing, then, is not so complicated. The problems arise because you have a single server trying to serve many clients at once. Generally, a database management system is involved, so the designer &#147;balances&#148; the layout of data into tables for optimal use. In addition, systems often allow a client to insert new information into a server. This means you must ensure that one client&#146;s new data doesn&#146;t walk over another client&#146;s new data, or that data isn&#146;t lost in the process of adding it to the database (this is called transaction processing). As client software changes, it must be built, debugged, and installed on the client machines, which turns out to be more complicated and expensive than you might think. It&#146;s especially problematic to support multiple types of computers and operating systems. Finally, there&#146;s the all-important performance issue: You might have hundreds of clients making requests of your server at any one time, so any small delay is crucial. To minimize latency, programmers work hard to offload processing tasks, often to the client machine, but sometimes to other machines at the server site, using so-called <i>middleware.</i> (Middleware is also used to improve maintainability.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_219" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The simple idea of distributing information has so many layers of complexity that the whole problem can seem hopelessly enigmatic. And yet it&#146;s crucial: Client/server computing accounts for roughly half of all programming activities. It&#146;s responsible for everything from taking orders and credit-card transactions to the distribution of any kind of data&#151;stock market, scientific, government, you name it. What we&#146;ve come up with in the past is individual solutions to individual problems, inventing a new solution each time. These were hard to create and hard to use, and the user had to learn a new interface for each one. The entire client/server problem needs to be solved in a big way. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_220" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading1174"></a>The Web as a giant server</h4>
<p>The Web is actually one giant client/server system. It&#146;s a bit worse than that, since you have all the servers and clients coexisting on a single network at once. You don&#146;t need to know that, because all you care about is connecting to and interacting with one server at a time (even though you might be hopping around the world in your search for the correct server). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_221" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Initially it was a simple one-way process. You made a request of a server and it handed you a file, which your machine&#146;s browser software (i.e., the client) would interpret by formatting onto your local machine. But in short order people began wanting to do more than just deliver pages from a server. They wanted full client/server capability so that the client could feed information back to the server, for example, to do database lookups on the server, to add new information to the server, or to place an order (which required more security than the original systems offered). These are the changes we&#146;ve been seeing in the development of the Web. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_222" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The Web browser was a big step forward: the concept that one piece of information could be displayed on any type of computer without change. However, browsers were still rather primitive and rapidly bogged down by the demands placed on them. They weren&#146;t particularly interactive, and tended to clog up both the server and the Internet because any time you needed to do something that required programming you had to send information back to the server to be processed. It could take many seconds or minutes to find out you had misspelled something in your request. Since the browser was just a viewer it couldn&#146;t perform even the simplest computing tasks. (On the other hand, it was safe, because it couldn&#146;t execute any programs on your local machine that might contain bugs or viruses.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_223" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To solve this problem, different approaches have been taken. To begin with, graphics standards have been enhanced to allow better animation and video within browsers. The remainder of the problem can be solved only by incorporating the ability to run programs on the client end, under the browser. This is called client-side programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_224" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775532"></a><a name="Heading1179"></a>Client-side
programming</h3>
<p>The Web&#146;s initial server-browser design provided for interactive content, but the interactivity was completely provided by the server. The server produced static pages for the client browser, which would simply interpret and display them. Basic <i>HyperText Markup Language </i>(HTML) contains simple mechanisms for data gathering: text-entry boxes, check boxes, radio boxes, lists and drop-down lists, as well as a button that can only be programmed to reset the data on the form or &#147;submit&#148; the data on the form back to the server. This submission passes through the <i>Common Gateway Interface </i>(CGI) provided on all Web servers. The text within the submission tells CGI what to do with it. The most common action is to run a program located on the server in a directory that&#146;s typically called &#147;cgi-bin.&#148; (If you watch the address window at the top of your browser when you push a button on a Web page, you can sometimes see &#147;cgi-bin&#148; within all the gobbledygook there.) These programs can be written in most languages. Perl has been a common choice because it is designed for text manipulation and is interpreted, so it can be installed on any server regardless of processor or operating system. However, Python (my favorite&#151;see www.Python.org) has been making inroads because of its greater power and simplicity. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_225" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Many powerful Web sites today are built strictly on CGI, and you can in fact do nearly anything with CGI. However, Web sites built on CGI programs can rapidly become overly complicated to maintain, and there is also the problem of response time. The response of a CGI program depends on how much data must be sent, as well as the load on both the server and the Internet. (On top of this, starting a CGI program tends to be slow.) The initial designers of the Web did not foresee how rapidly this bandwidth would be exhausted for the kinds of applications people developed. For example, any sort of dynamic graphing is nearly impossible to perform with consistency because a <i>Graphics Interchange Format </i>(GIF) file must be created and moved from the server to the client for each version of the graph. And you&#146;ve no doubt had direct experience with something as simple as validating the data on an input form. You press the submit button on a page; the data is shipped back to the server; the server starts a CGI program that discovers an error, formats an HTML page informing you of the error, and then sends the page back to you; you must then back up a page and try again. Not only is this slow, it&#146;s inelegant. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_226" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The solution is client-side programming. Most machines that run Web browsers are powerful engines capable of doing vast work, and with the original static HTML approach they are sitting there, just idly waiting for the server to dish up the next page. Client-side programming means that the Web browser is harnessed to do whatever work it can, and the result for the user is a much speedier and more interactive experience at your Web site. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_227" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The problem with discussions of client-side programming is that they aren&#146;t very different from discussions of programming in general. The parameters are almost the same, but the platform is different; a Web browser is like a limited operating system. In the end, you must still program, and this accounts for the dizzying array of problems and solutions produced by client-side programming. The rest of this section provides an overview of the issues and approaches in client-side programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_228" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading1184"></a>Plug-ins</h4>
<p>One of the most significant steps forward in client-side programming is the development of the plug-in. This is a way for a programmer to add new functionality to the browser by downloading a piece of code that plugs itself into the appropriate spot in the browser. It tells the browser &#147;from now on you can perform this new activity.&#148; (You need to download the plug-in only once.) Some fast and powerful behavior is added to browsers via plug-ins, but writing a plug-in is not a trivial task, and isn&#146;t something you&#146;d want to do as part of the process of building a particular site. The value of the plug-in for client-side programming is that it allows an expert programmer to develop a new language and add that language to a browser without the permission of the browser manufacturer. Thus, plug-ins provide a &#147;back door&#148; that allows the creation of new client-side programming languages (although not all languages are implemented as plug-ins). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_229" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading1186"></a>Scripting languages</h4>
<p>Plug-ins resulted in an explosion of scripting languages. With a scripting language, you embed the source code for your client-side program directly into the HTML page, and the plug-in that interprets that language is automatically activated while the HTML page is being displayed. Scripting languages tend to be reasonably easy to understand and, because they are simply text that is part of an HTML page, they load very quickly as part of the single server hit required to procure that page. The trade-off is that your code is exposed for everyone to see (and steal). Generally, however, you aren&#146;t doing amazingly sophisticated things with scripting languages, so this is not too much of a hardship. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_230" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>This points out that the scripting languages used inside Web browsers are really intended to solve specific types of problems, primarily the creation of richer and more interactive graphical user interfaces (GUIs). However, a scripting language might solve 80 percent of the problems encountered in client-side programming. Your problems might very well fit completely within that 80 percent, and since scripting languages can allow easier and faster development, you should probably consider a scripting language before looking at a more involved solution such as Java or ActiveX programming. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_231" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The most commonly discussed browser scripting languages are JavaScript (which has nothing to do with Java; it&#146;s named that way just to grab some of Java&#146;s marketing momentum), VBScript (which looks like Visual BASIC), and Tcl/Tk, which comes from the popular cross-platform GUI-building language. There are others out there, and no doubt more in development. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_232" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>JavaScript is probably the most commonly supported. It comes built into both Netscape Navigator and the Microsoft Internet Explorer (IE). Unfortunately, the flavor of JavaScript on the two browsers can vary widely (the Mozilla browser, freely downloadable from www.Mozilla.org, supports the ECMAScript standard, which may one day become universally supported). In addition, there are probably more JavaScript books available than there are for the other browser languages, and some tools automatically create pages using JavaScript. However, if you&#146;re already fluent in Visual BASIC or Tcl/Tk, you&#146;ll be more productive using those scripting languages rather than learning a new one. (You&#146;ll have your hands full dealing with the Web issues already.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_233" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Index107"></a><a name="Heading1191"></a>Java</h4>
<p>If a scripting language can solve 80 percent of the client-side programming problems, what about the other 20 percent&#151;the &#147;really hard stuff?&#148; Java is a popular solution for this. Not only is it a powerful programming language built to be secure, cross-platform, and international, but Java is being continually extended to provide language features and libraries that elegantly handle problems that are difficult in traditional programming languages, such as multithreading, database access, network programming, and distributed computing. Java allows client-side programming via the <i>applet</i> and with <i>Java Web Start</i>. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_234" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>An applet is a mini-program that will run only under a Web browser. The applet is downloaded automatically as part of a Web page (just as, for example, a graphic is automatically downloaded). When the applet is activated, it executes a program. This is part of its beauty&#151;it provides you with a way to automatically distribute the client software from the server at the time the user needs the client software, and no sooner. The user gets the latest version of the client software without fail and without difficult reinstallation. Because of the way Java is designed, the programmer needs to create only a single program, and that program automatically works with all computers that have browsers with built-in Java interpreters. (This safely includes the vast majority of machines.) Since Java is a full-fledged programming language, you can do as much work as possible on the client before and after making requests of the server. For example, you won&#146;t need to send a request form across the Internet to discover that you&#146;ve gotten a date or some other parameter wrong, and your client computer can quickly do the work of plotting data instead of waiting for the server to make a plot and ship a graphic image back to you. Not only do you get the immediate win of speed and responsiveness, but the general network traffic and load on servers can be reduced, preventing the entire Internet from slowing down. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_235" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>One advantage a Java applet has over a scripted program is that it&#146;s in compiled form, so the source code isn&#146;t available to the client. On the other hand, a Java applet can be decompiled without too much trouble, but hiding your code is often not an important issue. Two other factors can be important. As you will see later in this book, a compiled Java applet can require extra time to download, if it is large. A scripted program will just be integrated into the Web page as part of its text (and will generally be smaller and reduce server hits). This could be important to the responsiveness of your Web site. Another factor is the all-important learning curve. Regardless of what you&#146;ve heard, Java is not a trivial language to learn. If you&#146;re a VISUAL BASIC programmer, moving to VBScript will be your fastest solution (assuming you can constrain your customers to Windows platforms), and since it will probably solve most typical client/server problems, you might be hard pressed to justify learning Java. If you&#146;re experienced with a scripting language you will certainly benefit from looking at JavaScript or VBScript before committing to Java, because they might fit your needs handily and you&#146;ll be more productive sooner. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_236" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading1195"></a>.NET and C#</h4>
<p>For awhile, the main competitor to Java applets was Microsoft&#146;s ActiveX, although it required that the client be running Windows. Since then, Microsoft has produced a full competitor to Java in the form of the <a name="Index108"></a><b>.NET</b> platform and the <a name="Index109"></a><b>C# </b>programming language. The <b>.NET </b>platform is roughly the same as the Java virtual machine and Java libraries, and <b>C# </b>bears unmistakable similarities to Java. This is certainly the best work that Microsoft has done in the arena of programming languages and programming environments. Of course, they had the considerable advantage of being able to see what worked well and what didn&#146;t work so well in Java, and build upon that, but build they have. This is the first time since its inception that Java has had any real competition, and if all goes well, the result will be that the Java designers at Sun will take a hard look at C# and why programmers might want to move to it, and will respond by making fundamental improvements to Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_237" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Currently, the main vulnerability and important question concerning <b>.NET</b> is whether Microsoft will allow it to be <i>completely </i>ported to other platforms. They claim there&#146;s no problem doing this, and the Mono project (www.go-mono.com) has a partial implementation of <a name="Index110"></a><b>.NET</b> working on Linux, but until the implementation is complete and Microsoft has not decided to squash any part of it, <b>.NET</b> as a cross-platform solution is still a risky bet. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0441" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>To learn more about <b>.NET</b> and <b>C#</b>, see <a name="Index111"></a><a name="Index112"></a><i>Thinking in C#</i> by Larry O&#146;Brien and Bruce Eckel, Prentice Hall 2003.<br></p>
<h4>
<a name="Heading1199"></a>Security</h4>
<p>Automatically downloading and running programs across the Internet can sound like a virus-builder&#146;s dream. If you click on a Web site, you might automatically download any number of things along with the HTML page: GIF files, script code, compiled Java code, and ActiveX components. Some of these are benign; GIF files can&#146;t do any harm, and scripting languages are generally limited in what they can do. Java was also designed to run its applets within a &#147;sandbox&#148; of safety, which prevents it from writing to disk or accessing memory outside the sandbox. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_238" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Microsoft&#146;s ActiveX is at the opposite end of the spectrum. Programming with ActiveX is like programming Windows&#151;you can do anything you want. So if you click on a page that downloads an ActiveX component, that component might cause damage to the files on your disk. Of course, programs that you load onto your computer that are not restricted to running inside a Web browser can do the same thing. Viruses downloaded from Bulletin-Board Systems (BBSs) have long been a problem, but the speed of the Internet amplifies the difficulty. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_239" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The solution seems to be &#147;digital signatures,&#148; whereby code is verified to show who the author is. This is based on the idea that a virus works because its creator can be anonymous, so if you remove the anonymity, individuals will be forced to be responsible for their actions. This seems like a good plan because it allows programs to be much more functional, and I suspect it will eliminate malicious mischief. If, however, a program has an unintentional destructive bug, it will still cause problems. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_240" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The Java approach is to prevent these problems from occurring, via the sandbox. The Java interpreter that lives on your local Web browser examines the applet for any untoward instructions as the applet is being loaded. In particular, the applet cannot write files to disk or erase files (one of the mainstays of viruses). Applets are generally considered to be safe, and since this is essential for reliable client/server systems, any bugs in the Java language that allow viruses are rapidly repaired. (It&#146;s worth noting that the browser software actually enforces these security restrictions, and some browsers allow you to select different security levels to provide varying degrees of access to your system.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_241" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>You might be skeptical of this rather draconian restriction against writing files to your local disk. For example, you may want to build a local database or save data for later use offline. The initial vision seemed to be that eventually everyone would get online to do anything important, but that was soon seen to be impractical (although low-cost &#147;Internet appliances&#148; might someday satisfy the needs of a significant segment of users). The solution is the &#147;signed applet&#148; that uses public-key encryption to verify that an applet does indeed come from where it claims it does. A signed applet can still trash your disk, but the theory is that since you can now hold the applet creators accountable, they won&#146;t do vicious things. Java provides a framework for digital signatures so that you will eventually be able to allow an applet to step outside the sandbox if necessary. Chapter 14 contains an example of how to sign an applet. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_242" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>In addition, Java Web Start is a relatively new way to easily distribute standalone programs that don&#146;t need a web browser in which to run. This technology has the potential of solving many client side problems associated with running programs inside a browser. Web Start programs can either be signed, or they can ask the client for permission every time they are doing something potentially dangerous on the local system. Chapter 14 has a simple example and explanation of Java Web Start. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0442" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Digital signatures have missed an important issue, which is the speed that people move around on the Internet. If you download a buggy program and it does something untoward, how long will it be before you discover the damage? It could be days or even weeks. By then, how will you track down the program that&#146;s done it? And what good will it do you at that point? <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_243" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h4>
<a name="Heading1207"></a>Internet vs. intranet</h4>
<p>The Web is the most general solution to the client/server problem, so it makes sense to use the same technology to solve a subset of the problem, in particular the classic client/server problem <i>within</i> a company. With traditional client/server approaches you have the problem of multiple types of client computers, as well as the difficulty of installing new client software, both of which are handily solved with Web browsers and client-side programming. When Web technology is used for an information network that is restricted to a particular company, it is referred to as an intranet. Intranets provide much greater security than the Internet, since you can physically control access to the servers within your company. In terms of training, it seems that once people understand the general concept of a browser it&#146;s much easier for them to deal with differences in the way pages and applets look, so the learning curve for new kinds of systems seems to be reduced. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_244" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The security problem brings us to one of the divisions that seems to be automatically forming in the world of client-side programming. If your program is running on the Internet, you don&#146;t know what platform it will be working under, and you want to be extra careful that you don&#146;t disseminate buggy code. You need something cross-platform and secure, like a scripting language or Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_245" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you&#146;re running on an intranet, you might have a different set of constraints. It&#146;s not uncommon that your machines could all be Intel/Windows platforms. On an intranet, you&#146;re responsible for the quality of your own code and can repair bugs when they&#146;re discovered. In addition, you might already have a body of legacy code that you&#146;ve been using in a more traditional client/server approach, whereby you must physically install client programs every time you do an upgrade. The time wasted in installing upgrades is the most compelling reason to move to browsers, because upgrades are invisible and automatic (Java Web Start is also a solution to this problem). If you are involved in such an intranet, the most sensible approach to take is the shortest path that allows you to use your existing code base, rather than trying to recode your programs in a new language. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_246" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>When faced with this bewildering array of solutions to the client-side programming problem, the best plan of attack is a cost-benefit analysis. Consider the constraints of your problem and what would be the shortest path to your solution. Since client-side programming is still programming, it&#146;s always a good idea to take the fastest development approach for your particular situation. This is an aggressive stance to prepare for inevitable encounters with the problems of program development. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_247" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775533"></a><a name="Heading1212"></a>Server-side
programming</h3>
<p>This whole discussion has ignored the issue of server-side programming. What happens when you make a request of a server? Most of the time the request is simply &#147;send me this file.&#148; Your browser then interprets the file in some appropriate fashion: as an HTML page, a graphic image, a Java applet, a script program, etc. A more complicated request to a server generally involves a database transaction. A common scenario involves a request for a complex database search, which the server then formats into an HTML page and sends to you as the result. (Of course, if the client has more intelligence via Java or a scripting language, the raw data can be sent and formatted at the client end, which will be faster and less load on the server.) Or you might want to register your name in a database when you join a group or place an order, which will involve changes to that database. These database requests must be processed via some code on the server side, which is generally referred to as server-side programming. Traditionally, server-side programming has been performed using Perl, Python, C++, or some other language, to create CGI programs, but more sophisticated systems have been appearing. These include Java-based Web servers that allow you to perform all your server-side programming in Java by writing what are called servlets. Servlets and their offspring, JSPs, are two of the most compelling reasons that companies who develop Web sites are moving to Java, especially because they eliminate the problems of dealing with differently-abled browsers (these topics are covered in <i>Thinking in Enterprise Java</i>). <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_248" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc24775534"></a><a name="Heading1214"></a>Applications</h3>
<p>Much of the brouhaha over Java has been over applets. Java is actually a general-purpose programming language that can solve the kinds of problems you can solve with other languages&#151;at least in theory. And as pointed out previously, there might be more effective ways to solve most client/server problems. When you move out of the applet arena (and simultaneously release the restrictions, such as the one against writing to disk) you enter the world of general-purpose applications that run standalone, without a Web browser, just like any ordinary program does. Here, Java&#146;s strength is not only in its portability, but also its programmability. As you&#146;ll see throughout this book, Java has many features that allow you to create robust programs in a shorter period than with previous programming languages. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_249" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Be aware that this is a mixed blessing. You pay for the improvements through slower execution speed (although there is significant work going on in this area&#151;in particular, the so-called &#147;hotspot&#148; performance improvements in recent versions of Java). Like any language, Java has built-in limitations that might make it inappropriate to solve certain types of programming problems. Java is a rapidly evolving language, however, and as each new release comes out it becomes more and more attractive for solving larger sets of problems. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_250" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc312373787"></a><a name="_Toc472654702"></a><a name="_Toc24775535"></a><a name="Heading1217"></a>Why
Java succeeds</h2>
<p>The reason Java has been so successful is that the goal was to solve many of the problems facing developers today. A fundamental goal of Java is improved productivity. This productivity comes in many ways, but the language is designed to be a significant improvement over its predecessors, and to provide important benefits to the programmer. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_327" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="Index113"></a><a name="_Toc312373791"></a><a name="_Toc472654706"></a><a name="_Toc24775536"></a><a name="Heading1219"></a>Systems
are easier <br>to express and understand</h3>
<p>Classes designed to fit the problem tend to express it better. This means that when you write the code, you&#146;re describing your solution in the terms of the problem space (&#147;Put the grommet in the bin&#148;) rather than the terms of the computer, which is the solution space (&#147;Set the bit in the chip that means that the relay will close&#148;). You deal with higher-level concepts and can do much more with a single line of code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_328" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The other benefit of this ease of expression is maintenance, which (if reports can be believed) is a huge portion of the cost over a program&#146;s lifetime. If a program is easier to understand, then it&#146;s easier to maintain. This can also reduce the cost of creating and maintaining the documentation. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_329" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc312373792"></a><a name="_Toc472654707"></a><a name="_Toc24775537"></a><a name="Heading1222"></a>Maximal
leverage with libraries</h3>
<p>The fastest way to create a program is to use code that&#146;s already written: a library. A major goal in Java is to make library use easier. This is accomplished by casting libraries into new data types (classes), so that bringing in a library means adding new types to the language. Because the Java compiler takes care of how the library is used&#151;guaranteeing proper initialization and cleanup, and ensuring that methods are called properly&#151;you can focus on what you want the library to do, not how you have to do it. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_330" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc312373793"></a><a name="_Toc472654709"></a><a name="_Toc24775538"></a><a name="Heading1224"></a>Error
handling</h3>
<p>Error handling in C is a notorious problem, and one that is often ignored&#151;finger-crossing is usually involved. If you&#146;re building a large, complex program, there&#146;s nothing worse than having an error buried somewhere with no clue as to where it came from. Java <i>exception handling</i> is a way to guarantee that an error is noticed, and that something happens as a result. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_331" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h3>
<a name="_Toc312373794"></a><a name="_Toc472654710"></a><a name="_Toc24775539"></a><a name="Heading1226"></a>Programming
in the large</h3>
<p>Many traditional languages have built-in limitations to program size and complexity. BASIC, for example, can be great for pulling together quick solutions for certain classes of problems, but if the program gets more than a few pages long, or ventures out of the normal problem domain of that language, it&#146;s like trying to swim through an ever-more viscous fluid. There&#146;s no clear line that tells you when your language is failing you, and even if there were, you&#146;d ignore it. You don&#146;t say, &#147;My BASIC program just got too big; I&#146;ll have to rewrite it in C!&#148; Instead, you try to shoehorn a few more lines in to add that one new feature. So the extra costs come creeping up on you. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_332" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index114"></a>Java is designed to aid <a name="Index115"></a><i>programming in the large</i>&#151;that is, to erase those creeping-complexity boundaries between a small program and a large one. You certainly don&#146;t need to use OOP when you&#146;re writing a &#147;hello, world&#148; style utility program, but the features are there when you need them. And the compiler is aggressive about ferreting out bug-producing errors for small and large programs alike. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_333" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc375545210"></a><a name="_Toc473421309"></a><a name="_Toc24775540"></a><a name="Heading1229"></a>Java
vs. C++?</h2>
<p>Java looks a lot like C++, so naturally it would seem that C++ will be replaced by Java. But I&#146;m starting to question this logic. For one thing, C++ still has some features that Java doesn&#146;t, and although there have been a lot of promises about Java someday being as fast or faster than C++, we&#146;ve seen steady improvements but no dramatic breakthroughs. Also, there seems to be a continuing interest in C++, so I don&#146;t think that language is going away any time soon. Languages seem to hang around. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_346" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>I&#146;m beginning to think that the strength of Java lies in a slightly different arena than that of C++, which is a language that doesn&#146;t try to fit a mold. Certainly it has been adapted in a number of ways to solve particular problems. Some C++ tools combine libraries, component models, and code-generation tools to solve the problem of developing windowed end-user applications (for Microsoft Windows). And yet, what do the vast majority of Windows developers use? Microsoft&#146;s Visual BASIC (VB). This despite the fact that VB produces the kind of code that becomes unmanageable when the program is only a few pages long (and syntax that can be positively mystifying). As successful and popular as VB is, it&#146;s not a very good example of language design. It would be nice to have the ease and power of VB without the resulting unmanageable code. And that&#146;s where I think Java will shine: as the &#147;next VB.<sup><a name="fnB9" href="#fn9">[9]</a></sup>&#148; You may or may not shudder to hear this, but think about it: so much of Java is intended to make it easy for the programmer to solve application-level problems like networking and cross-platform UI, and yet it has a language design that allows the creation of very large and flexible bodies of code. Add to this the fact that Java&#146;s type checking and error handling is a big improvement over most languages and you have the makings of a significant leap forward in programming productivity. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_347" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>If you&#146;re developing all your code primarily from scratch, then the simplicity of Java over C++ will significantly shorten your development time&#151;the anecdotal evidence (stories from C++ teams that I&#146;ve talked to who have switched to Java) suggests a doubling of development speed over C++. If Java performance doesn&#146;t matter or you can somehow compensate for it, sheer time-to-market issues make it difficult to choose C++ over Java. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_349" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The biggest issue is performance. Interpreted Java has been slow, even 20 to 50 times slower than C in the original Java interpreters. This has improved greatly over time (especially with more recent versions of Java), but it will still remain an important number. Computers are about speed; if it wasn&#146;t significantly faster to do something on a computer then you&#146;d do it by hand. (I&#146;ve even heard it suggested that you start with Java, to gain the short development time, then use a tool and support libraries to translate your code to C++, if you need faster execution speed.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_350" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>The key to making Java feasible for many development projects is the appearance of speed improvements like so-called &#147;just-in-time&#148; (JIT) compilers, Sun&#146;s own &#147;hotspot&#148; technology, and even native code compilers. Of course, native code compilers will eliminate the touted cross-platform execution of the compiled programs, but they will also bring the speed of the executable closer to that of C and C++. And cross-compiling a program in Java should be a lot easier than doing so in C or C++. (In theory, you just recompile, but that promise has been made before for other languages.) <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_351" title="Send BackTalk Comment">Feedback</a></font><br></p>
<h2>
<a name="_Toc312373818"></a><a name="_Toc472654714"></a><a name="_Toc24775541"></a><a name="Heading1236"></a>Summary</h2>
<p>This chapter attempts to give you a feel for the broad issues of object-oriented programming and Java, including why OOP is different, and why Java in particular is different. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_353" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>OOP and Java may not be for everyone. It&#146;s important to evaluate your own needs and decide whether Java will optimally satisfy those needs, or if you might be better off with another programming system (including the one you&#146;re currently using). If you know that your needs will be very specialized for the foreseeable future and if you have specific constraints that may not be satisfied by Java, then you owe it to yourself to investigate the alternatives (In particular, I recommend looking at Python; see www.Python.org). Even if you eventually choose Java as your language, you&#146;ll at least understand what the options were and have a clear vision of why you took that direction. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_354" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p><a name="Index116"></a>You know what a procedural program looks like: data definitions and function calls. To find the meaning of such a program, you have to work a little, looking through the function calls and low-level concepts to create a model in your mind. This is the reason we need intermediate representations when designing procedural programs&#151;by themselves, these programs tend to be confusing because the terms of expression are oriented more toward the computer than to the problem you&#146;re solving. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_355" title="Send BackTalk Comment">Feedback</a></font><br></p>
<p>Because Java adds many new concepts on top of what you find in a procedural language, your natural assumption may be that the <b>main(&#160;)</b> in a Java program will be far more complicated than for the equivalent C program. Here, you&#146;ll be pleasantly surprised: A well-written Java program is generally far simpler and much easier to understand than the equivalent C program. What you&#146;ll see are the definitions of the objects that represent concepts in your problem space (rather than the issues of the computer representation) and messages sent to those objects to represent the activities in that space. One of the delights of object-oriented programming is that, with a well-designed program, it&#146;s easy to understand the code by reading it. Usually, there&#146;s a lot less code as well, because many of your problems will be solved by reusing existing library code. <font size="-2"><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]Chap01_356" title="Send BackTalk Comment">Feedback</a></font><br></p>
<hr><p class="footnote text"><sup><a name="fn2" href="#fnB2">[2]</a></sup> Some language designers have decided that object-oriented programming by itself is not adequate to easily solve all programming problems, and advocate the combination of various approaches into <i>multiparadigm</i> programming languages. See <a name="Index35"></a><a name="Index36"></a><i>Multiparadigm Programming in Leda</i> by Timothy Budd (Addison-Wesley 1995).<br></p>
<p class="footnote text"><sup><a name="fn3" href="#fnB3">[3]</a></sup> This is actually a bit restrictive, since objects can conceivably exist in different machines and address spaces, and they can also be stored on disk. In these cases, the identity of the object must be determined by something other than memory address.<br></p>
<p class="footnote text"><sup><a name="fn4" href="#fnB4">[4]</a></sup> Some people make a distinction, stating that type determines the interface while class is a particular implementation of that interface.<br></p>
<p class="footnote text"><sup><a name="fn5" href="#fnB5">[5]</a></sup> I&#146;m indebted to my friend <a name="Index61"></a>Scott Meyers for this term.<br></p>
<p class="footnote text"><sup><a name="fn6" href="#fnB6">[6]</a></sup> This is usually enough detail for most diagrams, and you don&#146;t need to get specific about whether you&#146;re using aggregation or composition.<br></p>
<p class="footnote text"><sup><a name="fn7" href="#fnB7">[7]</a></sup> Primitive types, which you&#146;ll learn about later, are a special case.<br></p>
<p class="footnote text"><sup><a name="fn8" href="#fnB8">[8]</a></sup> Except, unfortunately, for primitives. This is discussed in detail later in the book.<br></p>
<p class="footnote text"><sup><a name="fn9" href="#fnB9">[9]</a></sup> Microsoft is effectively saying &#147;not so fast&#148; with C# and .NET. Numerous people have raised the question of whether VB programmers want to change to <i>anything</i> else, whether that be Java, C#, or even VB.NET.<br></p>

<!-- <hr><b>Placeholder</b> -->

<hr>

<div align="CENTER"><a href="TIJ302.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ304.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>

</font></body>

</html>
